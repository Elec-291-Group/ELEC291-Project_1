0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 020F90       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 020469      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 0204D4      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   ; time buffer 
0030             38   current_time_sec:     ds 1
0031             39   current_time_minute:  ds 1
0032             40   soak_time_sec:        ds 1
0033             41   soak_time_minute:     ds 1
0034             42   reflow_time_sec:      ds 1
0035             43   reflow_time_minute:   ds 1
0036             44   soak_end_time_sec:      ds 1
0037             45   soak_end_time_minute:   ds 1
0038             46   reflow_end_time_sec:    ds 1
0039             47   reflow_end_time_minute: ds 1
003A             48   
003A             49   ; math32 buffer variables
003A             50   x:      ds  4
003E             51   y:      ds  4
0042             52   bcd:    ds  5
0047             53   
0047             54   current_temp: ds 4 ;
004B             55   soak_temp:    ds 4 ;
004F             56   reflow_temp:  ds 4 ;
0053             57   
0053             58   wait25_btn_cnt:    ds 1
0054             59   wait25_keypad_cnt: ds 1
0055             60   wait25_adc_cnt:    ds 1
0056             61   wait25_lcd_cnt:    ds 1
0057             62   wait25_count:      ds 1
0058             63   
0058             64   power_output:  ds 4 ;
005C             65   pwm_counter:   ds 4 ; counter for pwm (0-1500_timer: ds 1
0060             66   
0060             67   Control_FSM_state: ds 1 
0061             68   Current_State:     ds 1
0062             69   
0062             70   ;-- UI buffers I added (ayaan)
0062             71   Cursor_Idx: ds 1
0063             72   
0063             73   ; Buzzer module variables
0063             74   buzz_state:      ds 1   ; 0=IDLE, 1=ON, 2=OFF
0064             75   buzz_timer:      ds 1   ; counts ms within ON/OFF window
0065             76   buzz_beeps_left: ds 1   ; how many beeps remaining
0066             77   buzz_priority:   ds 1   ; 0 none, 1=state, 2=done, 3=error
0067             78   
0067             79   SEC_FSM_timer: ds 1
0068             80   SEC_FSM_state: ds 1
0069             81   ; Push buttons for globel interrupt 
0069             82   PB0_DEB_timer:  ds 1
006A             83   PB0_DEB_state:  ds 1
006B             84   PB2_DEB_timer:  ds 1
006C             85   PB2_DEB_state:  ds 1
006D             86   
0080             87   iseg at 0x80
0080             88   ; These hold the TEXT (ASCII) safely
0080             89   ; Digits Only + Null Terminator, got rid of C,:, and s 
0080             90   Buf_Soak_Temp: ds 4   
0084             91   Buf_Soak_Time: ds 5   
0089             92   Buf_Refl_Temp: ds 4   
008D             93   Buf_Refl_Time: ds 5
0092             94   ; 
0092             95   ;-------------------------------------------------------------------------------
0092             96   ; bit operation setb, clr, jb, and jnb
0000             97   bseg
0000             98   mf:     dbit 1 ; math32 sign
0001             99   one_second_flag: dbit 1
0002            100   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003            101   one_ms_buzz_flag: dbit 1 ; one_millisecond_flag for buzz
0004            102   one_second_lcd_flag: dbit 1
0005            103   
0005            104   soak_temp_reached: dbit 1
0006            105   reflow_temp_reached: dbit 1
0007            106   cooling_temp_reached: dbit 1
0008            107   
0008            108   soak_time_reached: dbit 1
0009            109   reflow_time_reached: dbit 1
000A            110   
000A            111   reset_signal: dbit 1
000B            112   stop_signal: dbit 1
000C            113   start_signal_count: dbit 1
000D            114   time_count_doing_signal: dbit 1
000E            115   config_finish_signal: dbit 1
000F            116   
000F            117   state_change_signal: dbit 1
0010            118   state_change_signal_TC: dbit 1
0011            119   state_change_signal_Count: dbit 1
0012            120   
0012            121   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
0013            122   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0014            123   
0014            124   PB0_flag: dbit 1 ; start entire program
0015            125   PB1_flag: dbit 1 ; start soak
0016            126   PB2_flag: dbit 1 ; pause process
0017            127   
0017            128   ; BSEG (Bit Segment)
0017            129   wait25_active: dbit 1 ; 1 = We are currently waiting
0018            130   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0019            131   wait25_btn_active:    dbit 1
001A            132   wait25_btn_done:      dbit 1
001B            133   wait25_keypad_active: dbit 1
001C            134   wait25_keypad_done:   dbit 1
001D            135   wait25_adc_active:    dbit 1
001E            136   wait25_adc_done:      dbit 1
001F            137   wait25_lcd_active:    dbit 1
0020            138   wait25_lcd_done:      dbit 1
0021            139   
0021            140   fullscreen_update_signal: dbit 1
0022            141   
0022            142   one_second_flag_test: dbit 1
0023            143   
0023            144   ;-------------------------------------------------------------------------------
0320            145   cseg
0320            146   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            147   BAUD           EQU 57600
0320            148   
0320            149   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            150   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            151   ; is always 12 unlike the N76E003 where is selectable.
0320            152   
0320            153   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            154   
0320            155   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            156   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            157   
0320            158   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            159   
0320            160   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            161   BEEP_ON_MS          EQU 100  ; 100ms
0320            162   BEEP_OFF_MS    EQU 100  ; 100ms
0320            163   
0320            164   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            165   
0320            166   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            167   ; P0 is in connector JPIO.
0320            168   
0320            169   ;Added correct I/O definitions
0320            170   ;-- LCD Pins ---
0320            171   ELCD_RS equ P1.7
0320            172   ELCD_E  equ P1.1
0320            173   ELCD_D4 equ P0.7
0320            174   ELCD_D5 equ P0.5
0320            175   ELCD_D6 equ P0.3
0320            176   ELCD_D7 equ P0.1
0320            177   
0320            178   ; -- Buttons --
0320            179   BTN_SOAK_TEMP equ P0.0
0320            180   BTN_SOAK_TIME equ P0.2
0320            181   BTN_REFL_TEMP equ P0.4
0320            182   BTN_REFL_TIME equ P0.6
0320            183   PB0                equ P1.0
0320            184   PB2                equ P3.7
0320            185   
0320            186   ; --- PB0PAD ---
0320            187   ROW1 equ P1.2
0320            188   ROW2 equ P1.4
0320            189   ROW3 equ P1.6
0320            190   ROW4 equ P2.0
0320            191   COL1 equ P2.2
0320            192   COL2 equ P2.4
0320            193   COL3 equ P2.6
0320            194   COL4 equ P3.0
0320            195   
0320            196   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   197   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   198   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   199   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            200   
0350            201   ; --- UI STRINGS (REQUIRED FOR PB0PAD LOGIC), <- I can fix if duplicates
0350 53656C65   202   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   203   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   204   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   205   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   206   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            207   
03A5            208   ;                       1234567890123456
03A5 53657420   209   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   210   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   211   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   212   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   213   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            214   
03E5            215   ;                     1234567890123456
03E5 52616D70   216   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03F5 536F616B   217   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
0405 52616D70   218   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
0415 5265666C   219   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
0425 436F6F6C   220   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
0435 50726F63   221   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
0445            222   
0445 20202020   223   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
0456            224   
0456            225   ;-------------------------------------------------------------------------------
0456            226   ; Timers Setting:
0456            227   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
0456            228   ;   Timer 1: Serial port baud rate 57600 generator
0456            229   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
0456            230   ;-------------------------------------------------------------------------------
0456            231   ; Routine to initialize the ISR for Timer 0 ;
0456            232   Timer0_Init:
0456 E589       233       mov a, TMOD
0458 54F0       234       anl a, #0xf0 ; Clear the bits for timer 0
045A 4401       235       orl a, #0x01 ; Configure timer 0 as 16-timer
045C F589       236       mov TMOD, a
045E 758CFD     237       mov TH0, #high(TIMER0_RELOAD)
0461 758A5A     238       mov TL0, #low(TIMER0_RELOAD)
0464            239       ; Enable the timer and interrupts
0464 D2A9       240       setb ET0  ; Enable timer 0 interrupt
0466 D28C       241       setb TR0  ; Start timer 0
0468 22         242       ret
0469            243   ; ISR for timer 0.  Set to execute every 1/4096Hz 
0469            244   ; to generate a 2048 Hz square wave at pin P1.5 
0469            245   Timer0_ISR:
0469            246       ;clr TF0  ; According to the data sheet this is done for us already.
0469 758CFD     247       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
046C 758A5A     248       mov TL0, #low(TIMER0_RELOAD)
046F            249       ;cpl SOUND_OUT ; Connect speaker to P1.5
046F 32         250       reti
0470            251   ; -----------------------------------------------------------------------------------------------;
0470            252   
0470            253   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0470            254   Initialize_Serial_Port:
0470            255       ; Configure serial port and baud rate
0470 C28E       256       clr TR1 ; Disable timer 1
0472 53890F     257       anl TMOD, #0x0f ; Mask the bits for timer 1
0475 438920     258       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
0478 438780     259       orl PCON, #80H ; Set SMOD to 1
047B 758DFD     260       mov TH1, #low(TIMER_1_RELOAD)
047E 758BFD     261       mov TL1, #low(TIMER_1_RELOAD) 
0481 D28E       262       setb TR1 ; Enable timer 1
0483 759852     263       mov SCON, #52H
0486 22         264       ret
0487            265   
0487            266   ; uart sending functions
0487            267   putchar:
0487 109902     268       jbc TI, putchar_L1
048A 80FB       269       sjmp putchar
048C            270   putchar_L1:
048C F599       271       mov SBUF,a
048E 22         272       ret
048F            273   
048F            274   SendString:
048F E4         275       clr a
0490 93         276       movc a, @a+dptr
0491 6006       277       jz SendString_L1
0493 120487     278       lcall putchar
0496 A3         279       inc dptr
0497 80F6       280       sjmp SendString  
0499            281   SendString_L1:
0499 22         282       ret
049A            283   
049A            284   ;-------------------------------------------------------------------------------
049A            285   ; serial debugging
049A            286   ; send a four byte number via serial to laptop
049A            287   ; need to be used with python script
049A            288   ; content needed to be sent should be stored in the varaible x
049A            289   ;-------------------------------------------------------------------------------
049A            290   Send32:
049A            291       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
049A 74AA       292       mov A, #0AAH
049C 120487     293       lcall putchar
049F 7455       294       mov A, #055H
04A1 120487     295       lcall putchar
04A4            296   
04A4 E53D       297       mov A, x+3
04A6 120487     298       lcall putchar
04A9 E53C       299       mov A, x+2
04AB 120487     300       lcall putchar
04AE E53B       301       mov A, x+1
04B0 120487     302       lcall putchar
04B3 E53A       303       mov A, x+0
04B5 120487     304       lcall putchar
04B8            305   
04B8 740A       306       mov A, #0AH
04BA 120487     307       lcall putchar
04BD 22         308       ret
04BE            309   ; -----------------------------------------------------------------------------------------------;
04BE            310   
04BE            311   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
04BE              1   ;-------------------------------------------------------------------------------
04BE              2   ; Timer2_ISR.inc
04BE              3   ; Contains Initialization and ISR for the 1ms System Timer
04BE              4   ;-------------------------------------------------------------------------------
04BE              5   
04BE              6   ;-------------------------------------------------------------------------------
04BE              7   ; Routine to initialize the ISR for timer 2
04BE              8   ;-------------------------------------------------------------------------------
04BE              9   Timer2_Init:
04BE 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
04C1 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
04C4 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
04C7             13       ; Set the reload value
04C7 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
04CA 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
04CD             16       
04CD C2CF        17       clr TF2       ; Clear flag just in case
04CF             18       ; Enable the timer and interrupts
04CF D2AD        19       setb ET2      ; Enable timer 2 interrupt
04D1 D2CA        20       setb TR2      ; Enable timer 2
04D3 22          21       ret
04D4             22   
04D4             23   ;-------------------------------------------------------------------------------
04D4             24   ; ISR for timer 2.  Runs every 1 ms
04D4             25   ;-------------------------------------------------------------------------------
04D4             26   Timer2_ISR:
04D4 C0E0        27       push acc
04D6 C0D0        28       push psw
04D8             29       
04D8 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
04DA             31   
04DA             32       ; --- 1. Existing Non-Blocking Seconds Increment and Periphals Debounce Timers ---
04DA 0567        33       inc SEC_FSM_timer
04DC D202        34       setb one_ms_pwm_flag 
04DE D203        35            setb one_ms_buzz_flag
04E0             36   
04E0 0569        37       inc PB0_DEB_timer
04E2 056B        38       inc PB2_DEB_timer
04E4             39   
04E4             40       ; --- 2. NEW: Non-Blocking Delay Counters ---
04E4             41       ; A. BUTTON DELAY
04E4 30190B      42       jnb wait25_btn_active, T2_Check_Keypad
04E7 0553        43       inc wait25_btn_cnt
04E9 E553        44       mov a, wait25_btn_cnt
04EB B41904      45       cjne a, #25, T2_Check_Keypad
04EE D21A        46       setb wait25_btn_done
04F0 C219        47       clr wait25_btn_active
04F2             48       
04F2             49       ; B. KEYPAD DELAY
04F2             50   T2_Check_Keypad:
04F2 301B0B      51       jnb wait25_keypad_active, T2_Check_ADC
04F5 0554        52       inc wait25_keypad_cnt
04F7 E554        53       mov a, wait25_keypad_cnt
04F9 B41904      54       cjne a, #25, T2_Check_ADC
04FC D21C        55       setb wait25_keypad_done
04FE C21B        56       clr wait25_keypad_active
0500             57   
0500             58       ; C. ADC DELAY (Thermocouple)
0500             59   T2_Check_ADC:
0500 301D0B      60       jnb wait25_adc_active, T2_Check_LCD
0503 0555        61       inc wait25_adc_cnt
0505 E555        62       mov a, wait25_adc_cnt
0507 B41904      63       cjne a, #25, T2_Check_LCD
050A D21E        64       setb wait25_adc_done
050C C21D        65       clr wait25_adc_active
050E             66   
050E             67       ; D. LCD DELAY
050E             68   T2_Check_LCD:
050E 301F0B      69       jnb wait25_lcd_active, T2_Check_Generic
0511 0556        70       inc wait25_lcd_cnt
0513 E556        71       mov a, wait25_lcd_cnt
0515 B41904      72       cjne a, #25, T2_Check_Generic
0518 D220        73       setb wait25_lcd_done
051A C21F        74       clr wait25_lcd_active
051C             75   
051C             76       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
051C             77   T2_Check_Generic:
051C 30170B      78       jnb wait25_active, Timer2_ISR_done
051F 0557        79       inc wait25_count
0521 E557        80       mov a, wait25_count
0523 B41904      81       cjne a, #25, Timer2_ISR_done
0526 D218        82       setb wait25_done      ; Tells Wait_25ms that we are finished
0528 C217        83       clr wait25_active     ; Stop counting
052A             84   
052A             85   Timer2_ISR_done:
052A D0D0        86       pop psw
052C D0E0        87       pop acc
052E 32          88       reti
052F             89            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
052F              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
052F              2   cseg
052F              3   
052F              4   ; When using a 33.333333MHz crystal clock
052F              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
052F              6   
052F              7   ;---------------------------------;
052F              8   ; Wait 40 microseconds            ;
052F              9   ;---------------------------------;
052F             10   Wait40uSec:
052F C000        11            push AR0
0531 78BE        12            mov R0, #190
0533             13   L0: 
0533 00          14            nop
0534 00          15            nop
0535 00          16            nop
0536 00          17            nop
0537 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0539 D000        19            pop AR0
053B 22          20       ret
053C             21   
053C             22   ;---------------------------------;
053C             23   ; Wait 'R2' milliseconds          ;
053C             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
053C             31   
053C             32   ?Wait_Milli_Seconds:
053C C000        33            push AR0
053E C001        34            push AR1
0540 7932        35   L3: mov R1, #50
0542 78DF        36   L2: mov R0, #223
0544 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
0546 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
0548 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
054A D001        40       pop AR1
054C D000        41       pop AR0
054E 22          42       ret
054F             43            
054F             44   ;---------------------------------;
054F             45   ; Toggles the 'E' pin in the LCD  ;
054F             46   ;---------------------------------;
054F             47   ELCD_pulse:
054F D291        48            setb ELCD_E
0551 12052F      49            lcall Wait40uSec
0554 C291        50            clr ELCD_E
0556 12052F      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
0559 22          52       ret
055A             53   
055A             54   ;---------------------------------;
055A             55   ; Writes acc to LCD in 4-bit mode ;
055A             56   ;---------------------------------;
055A             57   ELCD_byte:
055A             58            ; Write high 4 bits first
055A A2E7        59            mov c, ACC.7
055C 9281        60            mov ELCD_D7, c
055E A2E6        61            mov c, ACC.6
0560 9283        62            mov ELCD_D6, c
0562 A2E5        63            mov c, ACC.5
0564 9285        64            mov ELCD_D5, c
0566 A2E4        65            mov c, ACC.4
0568 9287        66            mov ELCD_D4, c
056A 12054F      67       lcall ELCD_pulse
056D             68            ; Write low 4 bits next
056D A2E3        69            mov c, ACC.3
056F 9281        70            mov ELCD_D7, c
0571 A2E2        71            mov c, ACC.2
0573 9283        72            mov ELCD_D6, c
0575 A2E1        73            mov c, ACC.1
0577 9285        74            mov ELCD_D5, c
0579 A2E0        75            mov c, ACC.0
057B 9287        76            mov ELCD_D4, c
057D 12054F      77       lcall ELCD_pulse
0580 22          78            ret
0581             79   
0581             80   ;---------------------------------;
0581             81   ; Write data to LCD               ;
0581             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
0581             87            
0581             88   ?WriteData:
0581 D297        89            setb ELCD_RS
0583 02055A      90            ljmp ELCD_byte
0586             91   
0586             92   ;---------------------------------;
0586             93   ; Write command to LCD            ;
0586             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
0586             99   
0586            100   ?WriteCommand:
0586 C297       101            clr ELCD_RS
0588 02055A     102            ljmp ELCD_byte
058B            103   
058B            104   ;---------------------------------;
058B            105   ; Configure LCD in 4-bit mode     ;
058B            106   ;---------------------------------;
058B            107   ELCD_4BIT:
058B C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
058D            109            ;clr ELCD_RW  ; RW forced to zero
058D            110            
058D            111            ; After power on, let the LCD start up before initializing
058D C002       112            push AR2
058F 7A28       112            mov R2, #40
0591 12053C     112            lcall ?Wait_Milli_Seconds
0594 D002       112            pop AR2
0596            112   
0596            113            
0596            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
0596 7433       115            mov a, #0x33
0598 120586     115            lcall ?WriteCommand
059B 7433       116            mov a, #0x33
059D 120586     116            lcall ?WriteCommand
05A0 7432       117            mov a, #0x32
05A2 120586     117            lcall ?WriteCommand ; change to 4-bit mode
05A5            118   
05A5            119            ; Configure the LCD
05A5 7428       120            mov a, #0x28
05A7 120586     120            lcall ?WriteCommand
05AA 740C       121            mov a, #0x0c
05AC 120586     121            lcall ?WriteCommand
05AF 7401       122            mov a, #0x01
05B1 120586     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
05B4            123   
05B4            124       ;Wait for the clear screen command to finish.
05B4 C002       125            push AR2
05B6 7A02       125            mov R2, #2
05B8 12053C     125            lcall ?Wait_Milli_Seconds
05BB D002       125            pop AR2
05BD            125   
05BD 22         126       ret
05BE            127   
05BE            128   ;---------------------------------;
05BE            129   ; Send a constant string to LCD   ;
05BE            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
05BE            141   
05BE            142   ?Send_Constant_String:
05BE E4         143       clr a
05BF 93         144       movc a, @a+dptr
05C0 6006       145       jz ?Send_Constant_String_Done
05C2 120581     146       lcall ?WriteData
05C5 A3         147       inc dptr
05C6 80F6       148       sjmp ?Send_Constant_String
05C8            149   ?Send_Constant_String_Done:
05C8 22         150       ret  
05C9            151   
05C9            152   ;---------------------------------;
05C9            153   ; Set LCD cursor at row, column   ;
05C9            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
05C9            162   
05C9            163   ?Set_Cursor_2:
05C9 4440       164            orl a, #01000000B
05CB            165   ?Set_Cursor_1:
05CB 4480       166            orl a, #10000000B
05CD 020586     167            ljmp ?WriteCommand ; Select column and row
05D0            168   
05D0            169   ;---------------------------------;
05D0            170   ; Display a BCD number in the LCD ;
05D0            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
05D0            178   
05D0            179   ?Display_BCD:
05D0 C0E0       180            push acc
05D2            181            ; Write most significant digit
05D2 E8         182            mov a, r0
05D3 C4         183            swap a
05D4 540F       184            anl a, #0fh
05D6 4430       185            orl a, #30h
05D8 120581     186            lcall ?WriteData
05DB            187            ; write least significant digit
05DB E8         188            mov a, r0
05DC 540F       189            anl a, #0fh
05DE 4430       190            orl a, #30h
05E0 120581     191            lcall ?WriteData
05E3 D0E0       192            pop acc
05E5 22         193            ret
05E6            194   
05E6            195   ;------------------------------------;
05E6            196   ; Display a char in the LCD          ;
05E6            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
05E6            204   
05E6            314            ;-----------------------------------------------------------------------------------------------;
05E6            315   
05E6            316   ;-------------------------------------------------------------------------------
05E6            317   ; Display Function for 7-segment displays       
05E6            318   ;-------------------------------------------------------------------------------
05E6            319   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
05E6            320   T_7seg:
05E6 C0F9A4B0   321       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
05EB 9282F880   322       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
05F0 8883C6A1   323       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
05F6            324   
05F6            325   ; Displays a BCD number pased in R0 in HEX5-HEX0
05F6            326   Display_BCD_7_Seg_HEX10:
05F6 9005E6     327       mov dptr, #T_7seg
05F9 E8         328       mov a, R0
05FA C4         329       swap a
05FB 540F       330       anl a, #0FH
05FD 93         331       movc a, @a+dptr
05FE F592       332       mov HEX1, a
0600 E8         333       mov a, R0
0601 540F       334       anl a, #0FH
0603 93         335       movc a, @a+dptr
0604 F591       336       mov HEX0, a
0606 22         337       ret
0607            338   
0607            339   Display_BCD_7_Seg_HEX32:
0607 9005E6     340       mov dptr, #T_7seg
060A E8         341       mov a, R0
060B C4         342       swap a
060C 540F       343       anl a, #0FH
060E 93         344       movc a, @a+dptr
060F F594       345       mov HEX3, a
0611 E8         346       mov a, R0
0612 540F       347       anl a, #0FH
0614 93         348       movc a, @a+dptr
0615 F593       349       mov HEX2, a
0617 22         350       ret
0618            351   
0618            352   Display_BCD_7_Seg_HEX54:
0618 9005E6     353       mov dptr, #T_7seg
061B E8         354       mov a, R0
061C C4         355       swap a
061D 540F       356       anl a, #0FH
061F 93         357       movc a, @a+dptr
0620 F58F       358       mov HEX5, a
0622 E8         359       mov a, R0
0623 540F       360       anl a, #0FH
0625 93         361       movc a, @a+dptr
0626 F58E       362       mov HEX4, a
0628 22         363       ret
0629            364   
0629            365   ; The 8-bit hex number passed in the accumulator is converted to
0629            366   ; BCD and stored in [R1, R0]
0629            367   Hex_to_bcd_8bit:
0629 75F064     368       mov b, #100
062C 84         369       div ab
062D F9         370       mov R1, a   ; After dividing, a has the 100s
062E E5F0       371       mov a, b    ; Remainder is in register b
0630 75F00A     372       mov b, #10
0633 84         373       div ab ; The tens are stored in a, the units are stored in b 
0634 C4         374       swap a
0635 54F0       375       anl a, #0xf0
0637 45F0       376       orl a, b
0639 F8         377       mov R0, a
063A 22         378       ret
063B            379   ;-------------------------------------------------------------------------------
063B            380   ; Display Function for LCD                      
063B            381   ;-------------------------------------------------------------------------------
063B            382   LCD_Display_Update_func:
063B C0E0       383       push acc
063D            384       
063D            385       ; ==========================================
063D            386       ; PART 1: STATIC TEXT (Title)
063D            387       ; Runs ONLY when the state changes
063D            388       ; ==========================================
063D            389       
063D            390       ; [FIX] "Trampoline" logic for long distance jump
063D            391       ; If signal is SET (1), we stay here and update.
063D            392       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
063D 300F04     393       jnb state_change_signal, Do_Dynamic_Update
0640 C20F       394            clr state_change_signal
0642 8003       395            sjmp Do_Static_Update
0644            396   Do_Dynamic_Update:
0644 02077B     397            ljmp Check_Live_Update
0647            398   
0647            399   Do_Static_Update:
0647            400       ; State Changed: Clear Screen and Write Title
0647 12091A     401       lcall Clear_Screen_Func
064A E560       402       mov a, Control_FSM_state
064C            403       
064C            404       ; State 0: Welcome
064C B4003B     405       cjne a, #0, LCD_Check_1
064F C0E0       406            push acc
0651 7401       406            mov a, #1
0653 14         406            dec a
0654 1205CB     406            lcall ?Set_Cursor_1 ; Select column and row
0657 D0E0       406            pop acc
0659 C083       407            push dph
065B C082       407            push dpl
065D C0E0       407            push acc
065F 900330     407            mov dptr, #String_state0_1
0662 1205BE     407            lcall ?Send_Constant_String
0665 D0E0       407            pop acc
0667 D082       407            pop dpl
0669 D083       407            pop dph
066B C0E0       408            push acc
066D 7401       408            mov a, #1
066F 14         408            dec a
0670 1205C9     408            lcall ?Set_Cursor_2 ; Select column and row
0673 D0E0       408            pop acc
0675 C083       409            push dph
0677 C082       409            push dpl
0679 C0E0       409            push acc
067B 900340     409            mov dptr, #String_state0_2
067E 1205BE     409            lcall ?Send_Constant_String
0681 D0E0       409            pop acc
0683 D082       409            pop dpl
0685 D083       409            pop dph
0687 020778     410       ljmp LCD_Done_Bridge ; Exit
068A            411   
068A            412   LCD_Check_1: ; Setup
068A B4011F     413       cjne a, #1, LCD_Check_2
068D C0E0       414            push acc
068F 7401       414            mov a, #1
0691 14         414            dec a
0692 1205CB     414            lcall ?Set_Cursor_1 ; Select column and row
0695 D0E0       414            pop acc
0697 C083       415            push dph
0699 C082       415            push dpl
069B C0E0       415            push acc
069D 9003A5     415            mov dptr, #String_state1
06A0 1205BE     415            lcall ?Send_Constant_String
06A3 D0E0       415            pop acc
06A5 D082       415            pop dpl
06A7 D083       415            pop dph
06A9 020778     416       ljmp LCD_Done_Bridge
06AC            417   
06AC            418   LCD_Check_2: ; Ramp to Soak
06AC B4021F     419       cjne a, #2, LCD_Check_3
06AF C0E0       420            push acc
06B1 7401       420            mov a, #1
06B3 14         420            dec a
06B4 1205CB     420            lcall ?Set_Cursor_1 ; Select column and row
06B7 D0E0       420            pop acc
06B9 C083       421            push dph
06BB C082       421            push dpl
06BD C0E0       421            push acc
06BF 9003E5     421            mov dptr, #String_state2
06C2 1205BE     421            lcall ?Send_Constant_String
06C5 D0E0       421            pop acc
06C7 D082       421            pop dpl
06C9 D083       421            pop dph
06CB 020799     422       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
06CE            423   
06CE            424   LCD_Check_3: ; Soak
06CE B4031F     425       cjne a, #3, LCD_Check_4
06D1 C0E0       426            push acc
06D3 7401       426            mov a, #1
06D5 14         426            dec a
06D6 1205CB     426            lcall ?Set_Cursor_1 ; Select column and row
06D9 D0E0       426            pop acc
06DB C083       427            push dph
06DD C082       427            push dpl
06DF C0E0       427            push acc
06E1 9003F5     427            mov dptr, #String_state3
06E4 1205BE     427            lcall ?Send_Constant_String
06E7 D0E0       427            pop acc
06E9 D082       427            pop dpl
06EB D083       427            pop dph
06ED 020799     428       ljmp LCD_Update_Temp_Value
06F0            429   
06F0            430   LCD_Check_4: ; Ramp to Peak
06F0 B4041F     431       cjne a, #4, LCD_Check_5
06F3 C0E0       432            push acc
06F5 7401       432            mov a, #1
06F7 14         432            dec a
06F8 1205CB     432            lcall ?Set_Cursor_1 ; Select column and row
06FB D0E0       432            pop acc
06FD C083       433            push dph
06FF C082       433            push dpl
0701 C0E0       433            push acc
0703 900405     433            mov dptr, #String_state4
0706 1205BE     433            lcall ?Send_Constant_String
0709 D0E0       433            pop acc
070B D082       433            pop dpl
070D D083       433            pop dph
070F 020799     434       ljmp LCD_Update_Temp_Value
0712            435   
0712            436   LCD_Check_5: ; Reflow
0712 B4051F     437       cjne a, #5, LCD_Check_6
0715 C0E0       438            push acc
0717 7401       438            mov a, #1
0719 14         438            dec a
071A 1205CB     438            lcall ?Set_Cursor_1 ; Select column and row
071D D0E0       438            pop acc
071F C083       439            push dph
0721 C082       439            push dpl
0723 C0E0       439            push acc
0725 900415     439            mov dptr, #String_state5
0728 1205BE     439            lcall ?Send_Constant_String
072B D0E0       439            pop acc
072D D082       439            pop dpl
072F D083       439            pop dph
0731 020799     440       ljmp LCD_Update_Temp_Value
0734            441   
0734            442   LCD_Check_6: ; Cooling
0734 B4061F     443       cjne a, #6, LCD_Check_7
0737 C0E0       444            push acc
0739 7401       444            mov a, #1
073B 14         444            dec a
073C 1205CB     444            lcall ?Set_Cursor_1 ; Select column and row
073F D0E0       444            pop acc
0741 C083       445            push dph
0743 C082       445            push dpl
0745 C0E0       445            push acc
0747 900425     445            mov dptr, #String_state6
074A 1205BE     445            lcall ?Send_Constant_String
074D D0E0       445            pop acc
074F D082       445            pop dpl
0751 D083       445            pop dph
0753 020799     446       ljmp LCD_Update_Temp_Value
0756            447   
0756            448   LCD_Check_7: ; Done
0756            449       ; [FIX] Check distance safe logic for State 7
0756 B4071F     450       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
0759 C0E0       451            push acc
075B 7401       451            mov a, #1
075D 14         451            dec a
075E 1205CB     451            lcall ?Set_Cursor_1 ; Select column and row
0761 D0E0       451            pop acc
0763 C083       452            push dph
0765 C082       452            push dpl
0767 C0E0       452            push acc
0769 900435     452            mov dptr, #String_state7
076C 1205BE     452            lcall ?Send_Constant_String
076F D0E0       452            pop acc
0771 D082       452            pop dpl
0773 D083       452            pop dph
0775 020778     453       ljmp LCD_Done_Bridge
0778            454   
0778            455   ; Local bridge to reach the far-away LCD_Done
0778            456   LCD_Done_Bridge:
0778 0207DB     457       ljmp LCD_Done
077B            458   
077B            459   ; ==========================================
077B            460   ; PART 2: DYNAMIC VALUES (Temperature)
077B            461   ; Runs every time 'one_second_flag' is set
077B            462   ; ==========================================
077B            463   Check_Live_Update:
077B 3001FA     464       jnb one_second_flag, LCD_Done_Bridge
077E            465       
077E            466       ; Only update temp for States 2, 3, 4, 5, 6
077E E560       467       mov a, Control_FSM_state
0780 B40202     468       cjne a, #2, Check_St3
0783 8014       469       sjmp LCD_Update_Temp_Value
0785            470   Check_St3:
0785 B40302     471       cjne a, #3, Check_St4
0788 800F       472       sjmp LCD_Update_Temp_Value
078A            473   Check_St4:
078A B40402     474       cjne a, #4, Check_St5
078D 800A       475       sjmp LCD_Update_Temp_Value
078F            476   Check_St5:
078F B40502     477       cjne a, #5, Check_St6
0792 8005       478       sjmp LCD_Update_Temp_Value
0794            479   Check_St6:
0794 B40644     480       cjne a, #6, LCD_Done
0797 8000       481       sjmp LCD_Update_Temp_Value
0799            482   
0799            483   ; --- HELPER: Prints "XXX C" on Line 2 ---
0799            484   LCD_Update_Temp_Value:
0799 C0E0       485            push acc
079B 7401       485            mov a, #1
079D 14         485            dec a
079E 1205C9     485            lcall ?Set_Cursor_2 ; Select column and row
07A1 D0E0       485            pop acc
07A3            486       
07A3            487       ; Convert current_temp to BCD
07A3 85473A     488       mov x, current_temp
07A6 85483B     489       mov x+1, current_temp+1
07A9 85493C     490       mov x+2, current_temp+2
07AC 854A3D     491       mov x+3, current_temp+3
07AF 12002E     492       lcall hex2bcd
07B2            493       
07B2            494       ; Print Hundreds
07B2 E543       495       mov a, bcd+1
07B4 540F       496       anl a, #0x0F
07B6 2430       497       add a, #0x30
07B8 120581     498       lcall ?WriteData
07BB            499       
07BB            500       ; Print Tens
07BB E542       501       mov a, bcd+0
07BD C4         502       swap a
07BE 540F       503       anl a, #0x0F
07C0 2430       504       add a, #0x30
07C2 120581     505       lcall ?WriteData
07C5            506       
07C5            507       ; Print Ones
07C5 E542       508       mov a, bcd+0
07C7 540F       509       anl a, #0x0F
07C9 2430       510       add a, #0x30
07CB 120581     511       lcall ?WriteData
07CE            512       
07CE            513       ; Print 'C'
07CE 7443       514       mov a, #'C'
07D0 120581     515       lcall ?WriteData
07D3            516       
07D3            517       ; Clear remaining line space (prevents garbage)
07D3 7420       518       mov a, #' '
07D5 120581     519       lcall ?WriteData
07D8 120581     520       lcall ?WriteData
07DB            521   
07DB            522   LCD_Done:
07DB D0E0       523       pop acc
07DD 22         524       ret
07DE            525   
07DE            526   ; ==========================================
07DE            527   ; PART 3: DYNAMIC VALUES (Time)
07DE            528   ; Runs every time 'one_second_flag' is set
07DE            529   ; ==========================================
07DE            530   LCD_Display_Update_Time:
07DE 300D2B     531            jnb time_count_doing_signal, LCD_Display_Update_Time_done
07E1 100402     532            jbc one_second_lcd_flag, LCD_Display_Update_Time_do
07E4 8026       533            sjmp LCD_Display_Update_Time_done
07E6            534   
07E6            535   LCD_Display_Update_Time_do:
07E6 C0E0       536            push acc
07E8 740E       536            mov a, #14
07EA 14         536            dec a
07EB 1205C9     536            lcall ?Set_Cursor_2 ; Select column and row
07EE D0E0       536            pop acc
07F0 C000       537            push ar0
07F2 A830       537            mov r0, current_time_sec
07F4 1205D0     537            lcall ?Display_BCD
07F7 D000       537            pop ar0
07F9 C0E0       538            push acc
07FB 740B       538            mov a, #11
07FD 14         538            dec a
07FE 1205C9     538            lcall ?Set_Cursor_2 ; Select column and row
0801 D0E0       538            pop acc
0803 C000       539            push ar0
0805 A831       539            mov r0, current_time_minute
0807 1205D0     539            lcall ?Display_BCD
080A D000       539            pop ar0
080C            540   
080C            541   LCD_Display_Update_Time_done:
080C 22         542            ret
080D            543   
080D            544   ; ----------------------------------------------------------------
080D            545   ; MODULE: SCREEN UPDATE (Visual Logic)
080D            546   ; ----------------------------------------------------------------
080D            547   Update_Screen_Full:
080D E560       548            mov a, Control_FSM_state
080F B40102     549            cjne a, #1, Update_Screen_Full_ret
0812 8001       550            sjmp Update_Screen_Full_do
0814            551   Update_Screen_Full_ret:
0814 22         552            ret
0815            553   Update_Screen_Full_do:
0815 3021FC     554       jnb fullscreen_update_signal, Update_Screen_Full_ret
0818 C221       555       clr fullscreen_update_signal
081A            556   
081A C0E0       557            push acc
081C 7401       557            mov a, #1
081E 14         557            dec a
081F 1205CB     557            lcall ?Set_Cursor_1 ; Select column and row
0822 D0E0       557            pop acc
0824            558       ; --- Draw Line 1 (Titles) ---
0824 E561       559       mov A, Current_State
0826 B40013     560       cjne A, #0, Update_State_1
0829 C083       561            push dph
082B C082       561            push dpl
082D C0E0       561            push acc
082F 900350     561            mov dptr, #Txt_Home
0832 1205BE     561            lcall ?Send_Constant_String
0835 D0E0       561            pop acc
0837 D082       561            pop dpl
0839 D083       561            pop dph
083B 22         562       ret 
083C            563   Update_State_1:
083C B40114     564       cjne A, #1, Update_State_2
083F C083       565            push dph
0841 C082       565            push dpl
0843 C0E0       565            push acc
0845 900361     565            mov dptr, #Txt_SoakT
0848 1205BE     565            lcall ?Send_Constant_String
084B D0E0       565            pop acc
084D D082       565            pop dpl
084F D083       565            pop dph
0851 8042       566       sjmp Draw_Temp_Format
0853            567   Update_State_2:
0853 B40214     568       cjne A, #2, Update_State_3
0856 C083       569            push dph
0858 C082       569            push dpl
085A C0E0       569            push acc
085C 900372     569            mov dptr, #Txt_SoakTime
085F 1205BE     569            lcall ?Send_Constant_String
0862 D0E0       569            pop acc
0864 D082       569            pop dpl
0866 D083       569            pop dph
0868 8046       570       sjmp Draw_Time_Format
086A            571   Update_State_3:
086A B40314     572       cjne A, #3, Update_State_4
086D C083       573            push dph
086F C082       573            push dpl
0871 C0E0       573            push acc
0873 900383     573            mov dptr, #Txt_ReflT
0876 1205BE     573            lcall ?Send_Constant_String
0879 D0E0       573            pop acc
087B D082       573            pop dpl
087D D083       573            pop dph
087F 8014       574       sjmp Draw_Temp_Format
0881            575   Update_State_4:
0881 C083       576            push dph
0883 C082       576            push dpl
0885 C0E0       576            push acc
0887 900394     576            mov dptr, #Txt_ReflTime
088A 1205BE     576            lcall ?Send_Constant_String
088D D0E0       576            pop acc
088F D082       576            pop dpl
0891 D083       576            pop dph
0893 801B       577       sjmp Draw_Time_Format
0895            578   
0895            579   ; --- Draw Line 2 (Values) ---
0895            580   Draw_Temp_Format:
0895 C0E0       581            push acc
0897 7401       581            mov a, #1
0899 14         581            dec a
089A 1205C9     581            lcall ?Set_Cursor_2 ; Select column and row
089D D0E0       581            pop acc
089F 12092E     582       lcall Get_Current_Buffer_Addr
08A2 120910     583       lcall Print_String_RAM
08A5 C0E0       584            push acc
08A7 7443       584            mov a, #'C'
08A9 120581     584            lcall ?WriteData
08AC D0E0       584            pop acc
08AE 8034       585       sjmp Restore_Cursor
08B0            586   
08B0            587   Draw_Time_Format:
08B0 C0E0       588            push acc
08B2 7401       588            mov a, #1
08B4 14         588            dec a
08B5 1205C9     588            lcall ?Set_Cursor_2 ; Select column and row
08B8 D0E0       588            pop acc
08BA 12092E     589       lcall Get_Current_Buffer_Addr
08BD            590       ; MM
08BD E6         591       mov A, @R0
08BE 120581     592       lcall ?WriteData
08C1 08         593       inc R0
08C2 E6         594       mov A, @R0
08C3 120581     595       lcall ?WriteData
08C6 08         596       inc R0
08C7            597       ; Colon
08C7 C0E0       598            push acc
08C9 743A       598            mov a, #':'
08CB 120581     598            lcall ?WriteData
08CE D0E0       598            pop acc
08D0            599       ; SS
08D0 E6         600       mov A, @R0
08D1 120581     601       lcall ?WriteData
08D4 08         602       inc R0
08D5 E6         603       mov A, @R0
08D6 120581     604       lcall ?WriteData
08D9            605       ; Unit
08D9 C0E0       606            push acc
08DB 7473       606            mov a, #'s'
08DD 120581     606            lcall ?WriteData
08E0 D0E0       606            pop acc
08E2 8000       607       sjmp Restore_Cursor
08E4            608   
08E4            609   ; --- Restore Cursor Position ---
08E4            610   Restore_Cursor:
08E4 E561       611       mov A, Current_State
08E6 B40202     612       cjne A, #2, RC_Check_State_4  
08E9 800D       613       sjmp Adjust_Cursor_Time
08EB            614   RC_Check_State_4:             
08EB B40402     615       cjne A, #4, Normal_Cursor
08EE 8008       616       sjmp Adjust_Cursor_Time
08F0            617   
08F0            618   Normal_Cursor:
08F0 E562       619       mov A, Cursor_Idx
08F2 24C0       620       add A, #0xC0
08F4 120586     621       lcall ?WriteCommand
08F7 22         622       ret
08F8            623   
08F8            624   Adjust_Cursor_Time:
08F8            625       ; Skip the colon index (2)
08F8 E562       626       mov A, Cursor_Idx
08FA B40201     627       cjne A, #2, No_Skip
08FD 04         628       inc A 
08FE            629   No_Skip:
08FE            630       ; Add 1 if past the colon
08FE C3         631       clr C
08FF 9402       632       subb A, #2
0901 4005       633       jc No_Add
0903 E562       634       mov A, Cursor_Idx
0905 04         635       inc A
0906 8002       636       sjmp Final_Cursor_Set
0908            637   No_Add:
0908 E562       638       mov A, Cursor_Idx
090A            639   Final_Cursor_Set:
090A 24C0       640       add A, #0xC0
090C 120586     641       lcall ?WriteCommand
090F 22         642       ret
0910            643   
0910            644   Print_String_RAM:
0910 E6         645       mov A, @R0
0911 6006       646       jz Print_String_Done
0913 120581     647       lcall ?WriteData
0916 08         648       inc R0
0917 80F7       649       sjmp Print_String_RAM
0919            650   Print_String_Done:
0919 22         651       ret
091A            652   
091A            653   ; --- Clear Screen with hardware delay ---
091A            654   Clear_Screen_Func:
091A 7401       655            mov a, #0x01
091C 120586     655            lcall ?WriteCommand        ; Clear display command
091F C002       656            push AR2
0921 7A02       656            mov R2, #2
0923 12053C     656            lcall ?Wait_Milli_Seconds
0926 D002       656            pop AR2     ; LCD needs ~2ms to clear
0928 740C       657            mov a, #0x0C
092A 120586     657            lcall ?WriteCommand        ; Display ON, Cursor OFF
092D 22         658       ret
092E            659   
092E            660   Get_Current_Buffer_Addr:
092E E561       661       mov A, Current_State
0930 B40103     662       cjne A, #1, Get_Buf_2
0933 7880       663       mov R0, #Buf_Soak_Temp
0935 22         664       ret
0936            665   Get_Buf_2:
0936 B40203     666       cjne A, #2, Get_Buf_3
0939 7884       667       mov R0, #Buf_Soak_Time
093B 22         668       ret
093C            669   Get_Buf_3:
093C B40303     670       cjne A, #3, Get_Buf_4
093F 7889       671       mov R0, #Buf_Refl_Temp
0941 22         672       ret
0942            673   Get_Buf_4:
0942 788D       674       mov R0, #Buf_Refl_Time
0944 22         675       ret
0945            676       
0945            677   ;---------------------------------------------------------
0945            678   PB0_DEB:
0945            679   ;non-blocking state machine for PB0 debounce
0945 E56A       680       mov a, PB0_DEB_state
0947            681   PB0_DEB_state0:
0947 B4000A     682       cjne a, #0, PB0_DEB_state1
094A 20902F     683       jb PB0, PB0_DEB_done
094D 756900     684       mov PB0_DEB_timer, #0
0950 056A       685       inc PB0_DEB_state
0952 8028       686       sjmp PB0_DEB_done
0954            687   PB0_DEB_state1:
0954 B40109     688       cjne a, #1, PB0_DEB_state2
0957            689       ; this is the debounce state
0957 E569       690       mov a, PB0_DEB_timer
0959 B43220     691       cjne a, #50, PB0_DEB_done ; 50 ms passed?
095C 056A       692       inc PB0_DEB_state
095E 801C       693       sjmp PB0_DEB_done  
0960            694   PB0_DEB_state2:
0960 B4020C     695       cjne a, #2, PB0_DEB_state3
0963 209004     696       jb PB0, PB0_DEB_state2b
0966 056A       697       inc PB0_DEB_state
0968 8012       698       sjmp PB0_DEB_done  
096A            699   PB0_DEB_state2b:
096A 756A00     700       mov PB0_DEB_state, #0
096D 800D       701       sjmp PB0_DEB_done
096F            702   PB0_DEB_state3:
096F B4030A     703       cjne a, #3, PB0_DEB_done
0972 309007     704       jnb PB0, PB0_DEB_done
0975 D214       705       setb PB0_flag ; Suscesfully detected a valid PB0 press/release
0977 B2ED       706            cpl LEDRA.5
0979 756A00     707       mov PB0_DEB_state, #0  
097C            708   PB0_DEB_done:
097C 22         709       ret
097D            710   
097D            711   PB2_DEB:
097D            712   ;non-blocking state machine for PB2 debounce
097D E56C       713       mov a, PB2_DEB_state
097F            714   PB2_DEB_state0:
097F B4000A     715       cjne a, #0, PB2_DEB_state1
0982 20B72D     716       jb PB2, PB2_DEB_done
0985 756B00     717       mov PB2_DEB_timer, #0
0988 056C       718       inc PB2_DEB_state
098A 8026       719       sjmp PB2_DEB_done
098C            720   PB2_DEB_state1:
098C B40109     721       cjne a, #1, PB2_DEB_state2
098F            722       ; this is the debounce state
098F E56B       723       mov a, PB2_DEB_timer
0991 B4321E     724       cjne a, #50, PB2_DEB_done ; 50 ms passed?
0994 056C       725       inc PB2_DEB_state
0996 801A       726       sjmp PB2_DEB_done  
0998            727   PB2_DEB_state2:
0998 B4020C     728       cjne a, #2, PB2_DEB_state3
099B 20B704     729       jb PB2, PB2_DEB_state2b
099E 056C       730       inc PB2_DEB_state
09A0 8010       731       sjmp PB2_DEB_done  
09A2            732   PB2_DEB_state2b:
09A2 756C00     733       mov PB2_DEB_state, #0
09A5 800B       734       sjmp PB2_DEB_done
09A7            735   PB2_DEB_state3:
09A7 B40308     736       cjne a, #3, PB2_DEB_done
09AA 30B705     737       jnb PB2, PB2_DEB_done
09AD D216       738       setb PB2_flag ; Suscesfully detected a valid PB2 press/release
09AF 756C00     739       mov PB2_DEB_state, #0  
09B2            740   PB2_DEB_done:
09B2 22         741       ret
09B3            742   
09B3            743   ; ------------------------------------------------------------------------------
09B3            744   ; Non-blocking FSM for the one second counter
09B3            745   ;-------------------------------------------------------------------------------
09B3            746   SEC_FSM:
09B3 E568       747       mov a, SEC_FSM_state
09B5            748   SEC_FSM_state0:
09B5 B4000C     749       cjne a, #0, SEC_FSM_state1
09B8 E567       750       mov a, SEC_FSM_timer
09BA B4FA51     751       cjne a, #250, SEC_FSM_done
09BD 756700     752       mov SEC_FSM_timer, #0
09C0 0568       753       inc SEC_FSM_state
09C2 804A       754       sjmp SEC_FSM_done
09C4            755   SEC_FSM_state1:  
09C4 B4010E     756       cjne a, #1, SEC_FSM_state2
09C7 D2E9       757       setb LEDRA.1
09C9 E567       758       mov a, SEC_FSM_timer
09CB B4FA40     759       cjne a, #250, SEC_FSM_done
09CE 756700     760       mov SEC_FSM_timer, #0
09D1 0568       761       inc SEC_FSM_state
09D3 8039       762       sjmp SEC_FSM_done
09D5            763   SEC_FSM_state2:  
09D5 B4020E     764       cjne a, #2, SEC_FSM_state3
09D8 D2EA       765       setb LEDRA.2
09DA E567       766       mov a, SEC_FSM_timer
09DC B4FA2F     767       cjne a, #250, SEC_FSM_done
09DF 756700     768       mov SEC_FSM_timer, #0
09E2 0568       769       inc SEC_FSM_state
09E4 8028       770       sjmp SEC_FSM_done
09E6            771   SEC_FSM_state3:  
09E6 B40325     772       cjne a, #3, SEC_FSM_done
09E9 D2EB       773       setb LEDRA.3
09EB E567       774       mov a, SEC_FSM_timer
09ED B4FA1E     775       cjne a, #250, SEC_FSM_done
09F0 756700     776       mov SEC_FSM_timer, #0
09F3 756800     777       mov SEC_FSM_state, #0
09F6            778       
09F6            779       ; These flags are always set (global use)
09F6 D204       780       setb one_second_lcd_flag
09F8 D201       781       setb one_second_flag
09FA            782       
09FA            783       ; Heartbeat LED always toggles
09FA B2E8       784       cpl LEDRA.0
09FC            785       
09FC            786       ; Only update time if counting is enabled
09FC 300D0F     787       jnb time_count_doing_signal, SEC_FSM_done
09FF            788       
09FF            789       ; Update current time (only when counting)
09FF E530       790       mov a, current_time_sec
0A01 04         791       inc a
0A02 B43C07     792       cjne a, #60, SEC_NoMinuteCarry
0A05 753000     793       mov current_time_sec, #0
0A08 0531       794       inc current_time_minute
0A0A 8002       795       sjmp SEC_FSM_done
0A0C            796   SEC_NoMinuteCarry:
0A0C F530       797       mov current_time_sec, a
0A0E            798   SEC_FSM_done:
0A0E 22         799       ret
0A0F            800   
0A0F            801   ; ------------------------------------------------------------------------------
0A0F            802   ; Counting the processing time 
0A0F            803   ;-------------------------------------------------------------------------------
0A0F            804   Time_Counter:
0A0F C0E0       805       push ACC
0A11 C0D0       806       push psw
0A13 E560       807       mov a, Control_FSM_state
0A15            808       
0A15            809       ; State 2: Start counting
0A15 B4020F     810       cjne a, #2, Time_Counter_Nstate2
0A18 101102     811       jbc state_change_signal_Count, Time_Counter_Start
0A1B 800F       812       sjmp Time_Counter_Done
0A1D            813   
0A1D            814   Time_Counter_Start:
0A1D 753000     815       mov current_time_sec, #0
0A20 753100     816       mov current_time_minute, #0
0A23 D20D       817       setb time_count_doing_signal
0A25 8005       818       sjmp Time_Counter_Done
0A27            819   
0A27            820   Time_Counter_Nstate2:
0A27            821       ; State 6: Stop counting
0A27 B40602     822       cjne a, #6, Time_Counter_Done
0A2A C20D       823       clr time_count_doing_signal
0A2C            824   
0A2C            825   Time_Counter_Done:
0A2C D0D0       826       pop psw
0A2E D0E0       827       pop ACC
0A30 22         828       ret
0A31            829   
0A31            830   
0A31            831   ;-------------------------------------------------------------------------------
0A31            832   ; Time_Compare_MMSS
0A31            833   ;
0A31            834   ; PURPOSE:
0A31            835   ;   Compare elapsed time (current_time_minute:current_time_sec)
0A31            836   ;   against soak and reflow setpoints (soak_time_*, reflow_time_*).
0A31            837   ;
0A31            838   ; BEHAVIOR:
0A31            839   ;   - If current_time >= soak_time   if soak_time_reached    = 1
0A31            840   ;   - If current_time >= reflow_time if reflow_time_reached = 1
0A31            841   ;
0A31            842   ; NOTES:
0A31            843   ;   Compare minutes first, then seconds.
0A31            844   ;-------------------------------------------------------------------------------
0A31            845   Time_Compare_MMSS:
0A31 C0E0       846       push acc
0A33 C0D0       847       push psw
0A35            848   
0A35 E560       849            mov a, Control_FSM_state
0A37 B4032E     850            cjne a, #3, TC_Not_Soak
0A3A            851   ; soak state time comparison
0A3A 101002     852            jbc state_change_signal_TC, TC_Soak_Start_Record
0A3D 8015       853            sjmp TC_Soak_Comparing
0A3F            854   
0A3F            855   TC_Soak_Start_Record:
0A3F E531       856            mov a, current_time_minute
0A41 2533       857            add a, soak_time_minute
0A43 F537       858            mov soak_end_time_minute, a
0A45            859   
0A45 E530       860            mov a, current_time_sec
0A47 2532       861            add a, soak_time_sec
0A49 F536       862            mov soak_end_time_sec, a
0A4B            863   
0A4B C3         864            clr c
0A4C 943C       865            subb a, #60
0A4E 4004       866            jc TC_Soak_Comparing
0A50            867   
0A50 F536       868            mov soak_end_time_sec, a
0A52 0537       869            inc soak_end_time_minute
0A54            870   
0A54            871   TC_Soak_Comparing:
0A54 E531       872       mov  a, current_time_minute
0A56 C3         873       clr  c
0A57 9537       874       subb a, soak_end_time_minute
0A59 403C       875            jc   TC_Done                   ; current_min < end_min
0A5B 7007       876       jnz  TC_Soak_Reached           ; current_min > end_min
0A5D            877   
0A5D            878       ; minutes equal -> compare seconds
0A5D E530       879       mov  a, current_time_sec
0A5F C3         880       clr  c
0A60 9536       881       subb a, soak_end_time_sec
0A62 7033       882       jnz   TC_Done
0A64            883   
0A64            884   TC_Soak_Reached:
0A64 D208       885       setb soak_time_reached
0A66 802F       886            sjmp TC_Done
0A68            887   
0A68            888   TC_Not_Soak:
0A68 E560       889            mov a, Control_FSM_state
0A6A B4052A     890            cjne a, #5, TC_Done
0A6D            891   ; soak state time comparison
0A6D 101002     892            jbc state_change_signal_TC, TC_Reflow_Start_Record
0A70 8013       893            sjmp TC_Reflow_Comparing
0A72            894   
0A72            895   TC_Reflow_Start_Record:
0A72 E531       896            mov a, current_time_minute
0A74 2535       897            add a, reflow_time_minute
0A76 F539       898            mov reflow_end_time_minute, a
0A78            899   
0A78 E530       900            mov a, current_time_sec
0A7A 2534       901            add a, reflow_time_sec
0A7C F538       902            mov reflow_end_time_sec, a
0A7E C3         903            clr c
0A7F 943C       904            subb a, #60
0A81            905   
0A81 F538       906            mov reflow_end_time_sec, a
0A83 0539       907            inc reflow_end_time_minute
0A85            908   
0A85            909   TC_Reflow_Comparing:
0A85 E531       910       mov  a, current_time_minute
0A87 C3         911       clr  c
0A88 9539       912       subb a, reflow_end_time_minute
0A8A 400B       913       jc   TC_Done
0A8C 7007       914       jnz  TC_Reflow_Reached
0A8E            915   
0A8E E530       916       mov  a, current_time_sec
0A90 C3         917       clr  c
0A91 9538       918       subb a, reflow_end_time_sec
0A93 4002       919            jc   TC_Done
0A95            920   
0A95            921   TC_Reflow_Reached:
0A95 D209       922       setb reflow_time_reached
0A97            923   
0A97            924   TC_Done:
0A97 D0D0       925       pop  psw
0A99 D0E0       926       pop  acc
0A9B 22         927       ret
0A9C            928   
0A9C            929   ;-------------------------------------------------------------------------------;
0A9C            930   ; Temp_Compare
0A9C            931   ; Checks if we have reached the user's target temperatures.
0A9C            932   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
0A9C            933   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0A9C            934   ;-------------------------------------------------------------------------------;
0A9C            935   Temp_Compare:
0A9C            936       ; Reset flags initially
0A9C C205       937       clr soak_temp_reached
0A9E C206       938       clr reflow_temp_reached
0AA0 C207       939            clr cooling_temp_reached
0AA2            940   
0AA2 C0E0       941       push acc
0AA4 C0D0       942       push psw
0AA6 C000       943       push AR0
0AA8 C001       944       push AR1
0AAA C002       945       push AR2
0AAC            946       
0AAC            947       ; --- 1. CHECK SOAK TEMP ---
0AAC            948       ; Copy current_temp to X
0AAC 7847       949       mov R0, #current_temp
0AAE 793A       950       mov R1, #x
0AB0 120AFE     951       lcall Copy4_Bytes_R0_to_R1
0AB3            952   
0AB3            953       ; Copy soak_temp to Y
0AB3 784B       954       mov R0, #soak_temp
0AB5 793E       955       mov R1, #y
0AB7 120AFE     956       lcall Copy4_Bytes_R0_to_R1
0ABA            957   
0ABA            958       ; Compare: Is X (Current) < Y (Target)?
0ABA 12011A     959       lcall x_lt_y
0ABD 200002     960       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
0AC0            961       
0AC0            962       ; If we are here, Current >= Target
0AC0 D205       963       setb soak_temp_reached
0AC2            964   
0AC2            965   Check_Reflow_Threshold:
0AC2            966       ; --- 2. CHECK REFLOW TEMP ---
0AC2            967       ; Copy current_temp to X (Need to reload X because math32 destroys it)
0AC2 7847       968       mov R0, #current_temp
0AC4 793A       969       mov R1, #x
0AC6 120AFE     970       lcall Copy4_Bytes_R0_to_R1
0AC9            971   
0AC9            972       ; Copy reflow_temp to Y
0AC9 784F       973       mov R0, #reflow_temp
0ACB 793E       974       mov R1, #y
0ACD 120AFE     975       lcall Copy4_Bytes_R0_to_R1
0AD0            976   
0AD0            977       ; Compare
0AD0 12011A     978       lcall x_lt_y
0AD3 20001D     979       jb mf, Temp_Compare_Done
0AD6            980       
0AD6            981       ; If Current >= Target
0AD6 D206       982       setb reflow_temp_reached
0AD8            983   
0AD8            984   Check_Cooling_Threshold:
0AD8            985       ; --- 3. CHECK COOLING TEMP (< 100C) ---
0AD8 7847       986       mov R0, #current_temp
0ADA 793A       987       mov R1, #x
0ADC 120AFE     988       lcall Copy4_Bytes_R0_to_R1
0ADF            989       
0ADF 753E64     990            mov y+0, #low (100 % 0x10000) 
0AE2 753F00     990            mov y+1, #high(100 % 0x10000) 
0AE5 754000     990            mov y+2, #low (100 / 0x10000) 
0AE8 754100     990            mov y+3, #high(100 / 0x10000)                         ; Cooling target = 100C
0AEB 12011A     991       lcall x_lt_y
0AEE 300002     992       jnb mf, Temp_Compare_Done         ; If temp >= 100, not cooled yet
0AF1            993       
0AF1            994       ; If Current < 100C
0AF1 D207       995       setb cooling_temp_reached
0AF3            996   
0AF3            997   Temp_Compare_Done:
0AF3 D002       998       pop AR2
0AF5 D001       999       pop AR1
0AF7 D000      1000       pop AR0
0AF9 D0D0      1001       pop psw
0AFB D0E0      1002       pop acc
0AFD 22        1003       ret
0AFE           1004   
0AFE           1005   ;-------------------------------------------------------------------------------;
0AFE           1006   ; Copy4_Bytes_R0_to_R1
0AFE           1007   ;
0AFE           1008   ; PURPOSE:
0AFE           1009   ;   Utility routine to copy a 32-bit value (4 bytes)
0AFE           1010   ;   from one memory location to another.
0AFE           1011   ;
0AFE           1012   ; INPUTS:
0AFE           1013   ;   R0 st source address
0AFE           1014   ;   R1 at destination address
0AFE           1015   ;
0AFE           1016   ; USES:
0AFE           1017   ;   R2 as loop counter
0AFE           1018   ;
0AFE           1019   ; EXAMPLE:
0AFE           1020   ;   mov R0, #current_temp
0AFE           1021   ;   mov R1, #x
0AFE           1022   ;   lcall Copy4_Bytes_R0_to_R1
0AFE           1023   ;-------------------------------------------------------------------------------;
0AFE           1024   Copy4_Bytes_R0_to_R1:
0AFE 7A04      1025       mov  R2, #4
0B00           1026   Copy4_Loop:
0B00 E6        1027       mov  a, @R0
0B01 F7        1028       mov  @R1, a
0B02 08        1029       inc  R0
0B03 09        1030       inc  R1
0B04 DAFA      1031       djnz R2, Copy4_Loop
0B06 22        1032       ret
0B07           1033   
0B07           1034   ;-------------------------------------------------------------------------------
0B07           1035   ; PWM
0B07           1036   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0B07           1037   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0B07           1038   ; ------------------------------------------------------------------------------
0B07           1039   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0B07 100202    1040       jbc one_ms_pwm_flag, pwm_wave_generator
0B0A 8071      1041       sjmp end_pwm_generator
0B0C           1042   
0B0C           1043   pwm_wave_generator:
0B0C C200      1044       clr mf
0B0E           1045       ; move pwm counter value into x for comparison purpose
0B0E 855C3A    1046       mov x, pwm_counter
0B11 855D3B    1047       mov x+1, pwm_counter+1
0B14 855E3C    1048       mov x+2, pwm_counter+2
0B17 855F3D    1049       mov x+3, pwm_counter+3
0B1A           1050   
0B1A 753EDB    1051            mov y+0, #low (PWM_PERIOD % 0x10000) 
0B1D 753F05    1051            mov y+1, #high(PWM_PERIOD % 0x10000) 
0B20 754000    1051            mov y+2, #low (PWM_PERIOD / 0x10000) 
0B23 754100    1051            mov y+3, #high(PWM_PERIOD / 0x10000) 
0B26           1052   
0B26           1053       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0B26           1054       ; increase x by 1
0B26 120152    1055       lcall x_eq_y 
0B29 20001D    1056       jb mf, wrap_pwm_counter
0B2C           1057       ; x not equal 1499, increment by 1
0B2C 753E01    1058            mov y+0, #low (1 % 0x10000) 
0B2F 753F00    1058            mov y+1, #high(1 % 0x10000) 
0B32 754000    1058            mov y+2, #low (1 / 0x10000) 
0B35 754100    1058            mov y+3, #high(1 / 0x10000) 
0B38 1200D3    1059       lcall add32
0B3B           1060       ; update pwm_counter
0B3B 853A5C    1061       mov pwm_counter, x
0B3E 853B5D    1062       mov pwm_counter+1, x+1
0B41 853C5E    1063       mov pwm_counter+2, x+2
0B44 853D5F    1064       mov pwm_counter+3, x+3
0B47 8018      1065       sjmp set_pwm
0B49           1066   
0B49           1067   wrap_pwm_counter:
0B49           1068       ; x equal 1499, wrap to 0
0B49 753A00    1069            mov x+0, #low (0 % 0x10000) 
0B4C 753B00    1069            mov x+1, #high(0 % 0x10000) 
0B4F 753C00    1069            mov x+2, #low (0 / 0x10000) 
0B52 753D00    1069            mov x+3, #high(0 / 0x10000) 
0B55 853A5C    1070       mov pwm_counter, x
0B58 853B5D    1071       mov pwm_counter+1, x+1
0B5B 853C5E    1072       mov pwm_counter+2, x+2
0B5E 853D5F    1073       mov pwm_counter+3, x+3
0B61           1074   
0B61           1075   set_pwm:
0B61           1076       ; compare with power_output, if pwm counter smaller than power_output, 
0B61           1077       ; set pwm pin high; else set pwm pin low load y with power output value
0B61 85583E    1078       mov y, power_output
0B64 85593F    1079       mov y+1, power_output+1
0B67 855A40    1080       mov y+2, power_output+2
0B6A 855B41    1081       mov y+3, power_output+3
0B6D           1082   
0B6D           1083       ; compare x(pwm counter) with y(power output)
0B6D 12011A    1084       lcall x_lt_y
0B70 200006    1085       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
0B73           1086       ;output set pwm pin low if pwm counter greater than power output
0B73 C293      1087       clr PWM_OUT
0B75 C2EC      1088       clr LEDRA.4
0B77 8004      1089       sjmp end_pwm_generator
0B79           1090   
0B79           1091   set_pwm_high:
0B79 D293      1092       setb PWM_OUT
0B7B D2EC      1093       setb LEDRA.4
0B7D           1094   
0B7D           1095   end_pwm_generator:
0B7D 22        1096       ret
0B7E           1097   
0B7E           1098   ;-------------------------------------------------------------------------------
0B7E           1099   
0B7E           1100   ;-------------------------------------------------------------------------------;
0B7E           1101   ; Abort condition safety check Temperature time
0B7E           1102   ;
0B7E           1103   ; PURPOSE:
0B7E           1104   ;   Automatic cycle termination on error:
0B7E           1105   ;   Abort if oven fails to reach at least 50C in first 60s.
0B7E           1106   ;
0B7E           1107   ; TRIP CONDITION:
0B7E           1108   ;   if (current_time >= 60s) AND (current_temp < 50C)
0B7E           1109   ;       -> set tc_missing_abort
0B7E           1110   ;       -> set stop_signal
0B7E           1111   ;
0B7E           1112   ; ASSUMPTIONS:
0B7E           1113   ;   - current_time is in SECONDS (32-bit, little-endian)
0B7E           1114   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0B7E           1115   ;
0B7E           1116   ;   the Load_Y constants accordingly.
0B7E           1117   ;-------------------------------------------------------------------------------;
0B7E           1118   Safety_Check_TC:
0B7E C0E0      1119       push acc
0B80 C0D0      1120       push psw
0B82 C000      1121       push AR0
0B84 C001      1122       push AR1
0B86 C002      1123       push AR2
0B88           1124   
0B88           1125       ; If already aborted or startup window closed, do nothing
0B88 20122F    1126       jb   tc_missing_abort, Safety_TC_Done
0B8B 30132C    1127       jnb  tc_startup_window, Safety_TC_Done
0B8E           1128   
0B8E           1129       ; Check: elapsed >= 60 seconds ?
0B8E E531      1130       mov  a, current_time_minute
0B90 7007      1131       jnz  Safety_TC_At60          ; if minute >= 1, definitely >=60s
0B92           1132   
0B92 E530      1133       mov  a, current_time_sec
0B94 C3        1134       clr  c
0B95 943C      1135       subb a, #60
0B97 4021      1136       jc   Safety_TC_Done          ; still < 60s
0B99           1137   
0B99           1138   Safety_TC_At60:
0B99           1139   
0B99           1140       ; We reached 60s: close the startup window so it won't re-check later
0B99 C213      1141       clr  tc_startup_window
0B9B           1142   
0B9B           1143       ; Now check: current_temp < 50 ?
0B9B 7847      1144       mov  R0, #current_temp
0B9D 793A      1145       mov  R1, #x
0B9F 120AFE    1146       lcall Copy4_Bytes_R0_to_R1
0BA2           1147   
0BA2 753E32    1148            mov y+0, #low (50 % 0x10000) 
0BA5 753F00    1148            mov y+1, #high(50 % 0x10000) 
0BA8 754000    1148            mov y+2, #low (50 / 0x10000) 
0BAB 754100    1148            mov y+3, #high(50 / 0x10000) 
0BAE 12011A    1149       lcall x_lt_y
0BB1 300006    1150       jnb  mf, Safety_TC_Done        ; temp >= 50  pass
0BB4           1151   
0BB4           1152       ; FAIL: at 60s, still below 50C  abort
0BB4 D212      1153       setb tc_missing_abort
0BB6 D20B      1154       setb stop_signal
0BB8 C293      1155       clr  PWM_OUT
0BBA           1156   
0BBA           1157   Safety_TC_Done:
0BBA D002      1158       pop  AR2
0BBC D001      1159       pop  AR1
0BBE D000      1160       pop  AR0
0BC0 D0D0      1161       pop  psw
0BC2 D0E0      1162       pop  acc
0BC4 22        1163       ret
0BC5           1164   
0BC5           1165   ;-------------------------------------------------------------------------------;
0BC5           1166   ; Main Control FSM for the entire process
0BC5           1167   ;-------------------------------------------------------------------------------;
0BC5           1168   ;-------------------------------------------------------------------------------;
0BC5           1169   ; FSM LOGIC (Button Logic Fixed)
0BC5           1170   ;-------------------------------------------------------------------------------;
0BC5           1171   Control_FSM:
0BC5 E560      1172       mov a, Control_FSM_state
0BC7 8008      1173       sjmp Control_FSM_state0
0BC9           1174   
0BC9           1175   Control_FSM_state0_a:
0BC9 756000    1176            mov Control_FSM_state, #0
0BCC D20F      1177            setb state_change_signal
0BCE D210      1178            setb state_change_signal_TC
0BD0 22        1179            ret
0BD1           1180   Control_FSM_state0:
0BD1 B40013    1181       cjne a, #0, Control_FSM_state1
0BD4 301404    1182       jnb PB0_flag, Control_FSM_state0_ret  ; Check flag
0BD7 C214      1183       clr PB0_flag                 
0BD9 8001      1184       sjmp Control_FSM_state1_a
0BDB           1185   Control_FSM_state0_ret:
0BDB 22        1186       ret
0BDC           1187   
0BDC           1188   Control_FSM_state1_a:
0BDC 756001    1189       mov Control_FSM_state, #1
0BDF 756100    1190       mov Current_State, #0
0BE2 D20F      1191       setb state_change_signal
0BE4 D210      1192            setb state_change_signal_TC
0BE6 22        1193            ret
0BE7           1194   Control_FSM_state1:
0BE7 B40112    1195       cjne a, #1, Control_FSM_state2
0BEA 301404    1196       jnb PB0_flag, Control_FSM_state1_ret  ; Check flag
0BED C214      1197       clr PB0_flag                    
0BEF 8001      1198       sjmp Control_FSM_state2_a
0BF1           1199   Control_FSM_state1_ret:
0BF1 22        1200       ret
0BF2           1201   
0BF2           1202   ; --- STATE 2: RAMP TO SOAK ---
0BF2           1203   Control_FSM_state2_a:
0BF2 756002    1204            mov Control_FSM_state, #2
0BF5 D20F      1205            setb state_change_signal
0BF7 D210      1206            setb state_change_signal_TC
0BF9 D211      1207            setb state_change_signal_Count
0BFB 22        1208            ret
0BFC           1209   Control_FSM_state2:
0BFC B4021D    1210       cjne a, #2, Control_FSM_state3
0BFF 301605    1211       jnb PB2_flag, State2_Check
0C02 C216      1212       clr PB2_flag
0C04 020C69    1213       ljmp Control_FSM_state6_a ; Pause
0C07           1214   State2_Check:
0C07 120A9C    1215            lcall Temp_Compare
0C0A 300506    1216       jnb soak_temp_reached, State2_Ret
0C0D C205      1217       clr soak_temp_reached
0C0F C208      1218       clr soak_time_reached
0C11 8001      1219            sjmp Control_FSM_state3_a
0C13           1220   State2_Ret:
0C13 22        1221       ret
0C14           1222   
0C14           1223   ; --- STATE 3: SOAK PHASE ---
0C14           1224   Control_FSM_state3_a:
0C14 756003    1225            mov Control_FSM_state, #3
0C17 D20F      1226            setb state_change_signal
0C19 D210      1227            setb state_change_signal_TC
0C1B 22        1228            ret
0C1C           1229   Control_FSM_state3:
0C1C B40318    1230       cjne a, #3, Control_FSM_state4
0C1F 301605    1231       jnb PB2_flag, State3_Check
0C22 C216      1232       clr PB2_flag
0C24 020C69    1233       ljmp Control_FSM_state6_a
0C27           1234   State3_Check:
0C27 300804    1235       jnb soak_time_reached, State3_Ret
0C2A C208      1236       clr soak_time_reached
0C2C 8001      1237       sjmp Control_FSM_state4_a
0C2E           1238   State3_Ret:
0C2E 22        1239       ret
0C2F           1240   
0C2F           1241   ; --- STATE 4: RAMP TO PEAK ---
0C2F           1242   Control_FSM_state4_a:
0C2F 756004    1243            mov Control_FSM_state, #4
0C32 D20F      1244            setb state_change_signal
0C34 D210      1245            setb state_change_signal_TC
0C36 22        1246            ret
0C37           1247   Control_FSM_state4:
0C37 B4041D    1248       cjne a, #4, Control_FSM_state5
0C3A 301605    1249       jnb PB2_flag, State4_Check
0C3D C216      1250       clr PB2_flag
0C3F 020C69    1251       ljmp Control_FSM_state6_a
0C42           1252   State4_Check:
0C42 120A9C    1253            lcall Temp_Compare
0C45 300606    1254       jnb reflow_temp_reached, State4_Ret
0C48 C206      1255       clr reflow_temp_reached
0C4A C209      1256       clr reflow_time_reached
0C4C 8001      1257            sjmp Control_FSM_state5_a
0C4E           1258   State4_Ret:
0C4E 22        1259       ret
0C4F           1260   
0C4F           1261   ; --- STATE 5: REFLOW PHASE ---
0C4F           1262   Control_FSM_state5_a:
0C4F 756005    1263            mov Control_FSM_state, #5
0C52 D20F      1264            setb state_change_signal
0C54 D210      1265            setb state_change_signal_TC
0C56 22        1266            ret
0C57           1267   Control_FSM_state5:
0C57 B40519    1268       cjne a, #5, Control_FSM_state6
0C5A 301604    1269       jnb PB2_flag, State5_Check
0C5D C216      1270       clr PB2_flag
0C5F 8008      1271       sjmp Control_FSM_state6_a
0C61           1272   State5_Check:
0C61 300904    1273       jnb reflow_time_reached, State5_Ret
0C64 C209      1274       clr reflow_time_reached
0C66 8001      1275       sjmp Control_FSM_state6_a
0C68           1276   State5_Ret:
0C68 22        1277       ret
0C69           1278   
0C69           1279   ; --- STATE 6: COOLING ---
0C69           1280   Control_FSM_state6_a:
0C69 756006    1281            mov Control_FSM_state, #6
0C6C D20F      1282            setb state_change_signal
0C6E D210      1283            setb state_change_signal_TC
0C70 D211      1284            setb state_change_signal_Count
0C72 22        1285            ret
0C73           1286   Control_FSM_state6:
0C73 B40613    1287       cjne a, #6, Control_FSM_state7
0C76           1288       ; Wait for Cooling Temp Reached
0C76 120A9C    1289            lcall Temp_Compare
0C79 300704    1290       jnb cooling_temp_reached, State6_Ret
0C7C C207      1291       clr cooling_temp_reached
0C7E 8001      1292       sjmp Control_FSM_state7_a
0C80           1293   State6_Ret:
0C80 22        1294       ret
0C81           1295   
0C81           1296   ; --- STATE 7: DONE ---
0C81           1297   Control_FSM_state7_a:
0C81 756007    1298            mov Control_FSM_state, #7
0C84 D20F      1299            setb state_change_signal
0C86 D210      1300            setb state_change_signal_TC
0C88 22        1301            ret
0C89           1302   Control_FSM_state7:
0C89 B40708    1303       cjne a, #7, Control_FSM_done
0C8C           1304       ; Let's assume you meant the physical button P1.0 like State 0
0C8C 101402    1305       jbc PB0_flag, Control_FSM_state7_pressed
0C8F 8003      1306            sjmp Control_FSM_done
0C91           1307   Control_FSM_state7_pressed:
0C91 020BC9    1308       ljmp Control_FSM_state0_a
0C94           1309   
0C94           1310   Control_FSM_done:
0C94 22        1311       ret
0C95           1312   
0C95           1313   ; ================================================================
0C95           1314   ; UI & HELPER SUBROUTINES
0C95           1315   ; ================================================================
0C95           1316   
0C95           1317   ; ----------------------------------------------------------------
0C95           1318   ; MODULE: BRIDGE (Text to Integer Conversion)
0C95           1319   ; ----------------------------------------------------------------
0C95           1320   
0C95           1321   ;--------------------------
0C95           1322   ;keep updating varaibles
0C95           1323   Update_FSM_Variables:
0C95 C0E0      1324            push ACC
0C97 C006      1325            push AR6
0C99 C007      1326            push AR7
0C9B E560      1327            mov a, Control_FSM_state
0C9D B40132    1328            cjne a, #1, Update_FSM_Variables_done
0CA0           1329   
0CA0           1330       ; --- 1. SOAK TEMP ---
0CA0 7880      1331       mov R0, #Buf_Soak_Temp
0CA2 120CD9    1332       lcall Parse_Temp_String
0CA5 8F4B      1333       mov soak_temp+0, R7
0CA7 754C00    1334       mov soak_temp+1, #0
0CAA 754D00    1335       mov soak_temp+2, #0
0CAD 754E00    1336       mov soak_temp+3, #0
0CB0           1337   
0CB0           1338       ; --- 2. REFLOW TEMP ---
0CB0 7889      1339       mov R0, #Buf_Refl_Temp
0CB2 120CD9    1340       lcall Parse_Temp_String
0CB5 8F4F      1341       mov reflow_temp+0, R7
0CB7 755000    1342       mov reflow_temp+1, #0
0CBA 755100    1343       mov reflow_temp+2, #0
0CBD 755200    1344       mov reflow_temp+3, #0
0CC0           1345   
0CC0           1346       ; --- 3. SOAK TIME ---
0CC0 7884      1347       mov R0, #Buf_Soak_Time
0CC2 120CED    1348       lcall Parse_Time_String
0CC5 8F33      1349       mov soak_time_minute, R7
0CC7 8E32      1350       mov soak_time_sec, R6
0CC9           1351   
0CC9           1352       ; --- 4. REFLOW TIME ---
0CC9 788D      1353       mov R0, #Buf_Refl_Time
0CCB 120CED    1354       lcall Parse_Time_String
0CCE 8F35      1355       mov reflow_time_minute, R7
0CD0 8E34      1356       mov reflow_time_sec, R6
0CD2           1357   
0CD2           1358   Update_FSM_Variables_done:
0CD2 D007      1359            pop AR7
0CD4 D006      1360            pop AR6
0CD6 D0E0      1361            pop ACC
0CD8 22        1362       ret
0CD9           1363   ;--------------------------
0CD9           1364   
0CD9           1365   ; --- Helper: Parse "123" to Integer ---
0CD9           1366   Parse_Temp_String:
0CD9 7F00      1367       mov R7, #0              ; Clear Result
0CDB           1368   Parse_Temp_Loop:
0CDB E6        1369       mov A, @R0
0CDC 600E      1370       jz Parse_Temp_Done      ; If Null, we are done
0CDE           1371       
0CDE           1372       ; Convert ASCII to Digit
0CDE C3        1373       clr C
0CDF 9430      1374       subb A, #0x30
0CE1 FD        1375       mov R5, A               ; R5 = New Digit
0CE2           1376       
0CE2           1377       ; Result = (Result * 10) + New Digit
0CE2 EF        1378       mov A, R7
0CE3 75F00A    1379       mov B, #10
0CE6 A4        1380       mul AB
0CE7 2D        1381       add A, R5
0CE8 FF        1382       mov R7, A
0CE9           1383       
0CE9 08        1384       inc R0
0CEA 80EF      1385       sjmp Parse_Temp_Loop
0CEC           1386   Parse_Temp_Done:
0CEC 22        1387       ret
0CED           1388   
0CED           1389   ; --- Helper: Parse "MMSS" to Seconds ---
0CED           1390   Parse_Time_String:
0CED           1391       ; Minutes tens
0CED E6        1392       mov A, @R0
0CEE C3        1393       clr C
0CEF 9430      1394       subb A, #0x30
0CF1 75F00A    1395       mov B, #10
0CF4 A4        1396       mul AB
0CF5 FD        1397       mov R5, A
0CF6 08        1398       inc R0
0CF7           1399   
0CF7           1400       ; Minutes ones
0CF7 E6        1401       mov A, @R0
0CF8 C3        1402       clr C
0CF9 9430      1403       subb A, #0x30
0CFB 2D        1404       add A, R5
0CFC FD        1405       mov R5, A
0CFD 08        1406       inc R0
0CFE           1407   
0CFE           1408       ; Seconds tens
0CFE E6        1409       mov A, @R0
0CFF C3        1410       clr C
0D00 9430      1411       subb A, #0x30
0D02 75F00A    1412       mov B, #10
0D05 A4        1413       mul AB
0D06 FC        1414       mov R4, A
0D07 08        1415       inc R0
0D08           1416   
0D08           1417       ; Seconds ones
0D08 E6        1418       mov A, @R0
0D09 C3        1419       clr C
0D0A 9430      1420       subb A, #0x30
0D0C 2C        1421       add A, R4
0D0D FC        1422       mov R4, A
0D0E           1423   
0D0E           1424       ; Return minutes/seconds
0D0E ED        1425            mov a, R5
0D0F FF        1426       mov R7, a     ; minutes
0D10 EC        1427            mov a, R4
0D11 FE        1428       mov R6, a     ; seconds
0D12 22        1429       ret
0D13           1430   
0D13           1431   ; ----------------------------------------------------------------
0D13           1432   ; MODULE: BUTTON HANDLER (Mode Selection)
0D13           1433   ; ----------------------------------------------------------------
0D13           1434   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0D13           1435   Wait_25ms_BLOCKING:
0D13 120E88    1436       lcall Wait_25ms
0D16 50FB      1437       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0D18 22        1438       ret
0D19           1439   
0D19           1440   Check_Buttons:
0D19 C0E0      1441            push ACC
0D1B E560      1442            mov a, Control_FSM_state
0D1D B4014C    1443            cjne a, #1, Check_Buttons_ret
0D20           1444   
0D20           1445       ; --- FORCE INPUT MODE ---
0D20           1446       ; This clears any '0' the LCD library might have written to our buttons
0D20 438055    1447       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0D23           1448       ; ------------------------
0D23           1449   
0D23 30800C    1450       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0D26 308214    1451       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0D29 30841C    1452       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0D2C 308624    1453       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0D2F           1454   
0D2F D0E0      1455            pop ACC
0D31 22        1456       ret
0D32           1457   
0D32           1458   Btn_Soak_Temp_Press:
0D32 120D13    1459       lcall Wait_25ms_BLOCKING
0D35 756101    1460       mov Current_State, #1
0D38 756200    1461       mov Cursor_Idx, #0
0D3B 8021      1462       sjmp Redraw_Screen
0D3D           1463   
0D3D           1464   Btn_Soak_Time_Press:
0D3D 120D13    1465       lcall Wait_25ms_BLOCKING
0D40 756102    1466       mov Current_State, #2
0D43 756200    1467       mov Cursor_Idx, #0
0D46 8016      1468       sjmp Redraw_Screen
0D48           1469   
0D48           1470   Btn_Refl_Temp_Press:
0D48 120D13    1471       lcall Wait_25ms_BLOCKING
0D4B 756103    1472       mov Current_State, #3
0D4E 756200    1473       mov Cursor_Idx, #0
0D51 800B      1474       sjmp Redraw_Screen
0D53           1475   
0D53           1476   Btn_Refl_Time_Press:
0D53 120D13    1477       lcall Wait_25ms_BLOCKING 
0D56 756104    1478       mov Current_State, #4
0D59 756200    1479       mov Cursor_Idx, #0
0D5C 8000      1480       sjmp Redraw_Screen
0D5E           1481   
0D5E           1482   Redraw_Screen:
0D5E           1483       ; Wait for button release
0D5E 3080FD    1484       jnb BTN_SOAK_TEMP, $
0D61 3082FD    1485       jnb BTN_SOAK_TIME, $
0D64 3084FD    1486       jnb BTN_REFL_TEMP, $
0D67 3086FD    1487       jnb BTN_REFL_TIME, $
0D6A           1488   
0D6A D221      1489       setb fullscreen_update_signal
0D6C           1490   Check_Buttons_ret:
0D6C D0E0      1491       pop ACC
0D6E 22        1492       ret
0D6F           1493   
0D6F           1494   ; ----------------------------------------------------------------
0D6F           1495   ; MODULE: KEYPAD HANDLER (Input Logic)
0D6F           1496   ; ----------------------------------------------------------------
0D6F           1497   Check_Keypad:
0D6F E560      1498       mov a, Control_FSM_state
0D71 B40152    1499       cjne a, #1, Keypad_Exit
0D74           1500   
0D74           1501       ; If State is 0 (Home), ignore keypad
0D74 E561      1502       mov A, Current_State
0D76 604E      1503       jz Keypad_Exit
0D78           1504       
0D78 120DC7    1505       lcall Keypad_Scan
0D7B 5049      1506       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0D7D           1507   
0D7D           1508       ; --- Check Special Keys ---
0D7D EF        1509       mov A, R7
0D7E B40E09    1510       cjne A, #14, Check_Hash ; 14 is Star (*)
0D81           1511       
0D81           1512       ; Star Key Pressed: Reset Buffer
0D81 120ECB    1513       lcall Reset_Current_Buffer
0D84 D221      1514       setb fullscreen_update_signal
0D86 756200    1515       mov Cursor_Idx, #0
0D89 22        1516       ret
0D8A           1517   
0D8A           1518   Check_Hash:
0D8A EF        1519       mov A, R7
0D8B B40C01    1520       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0D8E 22        1521       ret                     ; Ignore Hash key
0D8F           1522   
0D8F           1523   Check_Numeric:
0D8F           1524       ; Ensure key is 0-9
0D8F EF        1525       mov A, R7
0D90 C3        1526       clr C
0D91 940A      1527       subb A, #10
0D93 5030      1528       jnc Symbol_Key_Ignored
0D95           1529       
0D95           1530       ; Convert to ASCII
0D95 EF        1531       mov A, R7
0D96 2430      1532       add A, #0x30
0D98 FD        1533       mov R5, A
0D99           1534   
0D99           1535       ; Save to Buffer
0D99 12092E    1536       lcall Get_Current_Buffer_Addr
0D9C E562      1537       mov A, Cursor_Idx
0D9E 28        1538       add A, R0
0D9F F8        1539       mov R0, A
0DA0 ED        1540       mov A, R5
0DA1 F6        1541       mov @R0, A
0DA2 0562      1542       inc Cursor_Idx
0DA4           1543   
0DA4           1544       ; --- Check Cursor Limits ---
0DA4 E561      1545       mov A, Current_State
0DA6 B40102    1546       cjne A, #1, Check_Limit_Time_1
0DA9 8005      1547       sjmp Limit_Temp_3
0DAB           1548   
0DAB           1549   Check_Limit_Time_1:
0DAB B4030B    1550       cjne A, #3, Limit_Time_4
0DAE 8000      1551       sjmp Limit_Temp_3
0DB0           1552   
0DB0           1553   Limit_Temp_3:
0DB0 E562      1554       mov A, Cursor_Idx
0DB2 B4030D    1555       cjne A, #3, Do_Refresh
0DB5 1562      1556       dec Cursor_Idx          ; Stay at last digit
0DB7 8009      1557       sjmp Do_Refresh
0DB9           1558   
0DB9           1559   Limit_Time_4:
0DB9 E562      1560       mov A, Cursor_Idx
0DBB B40404    1561       cjne A, #4, Do_Refresh
0DBE 1562      1562       dec Cursor_Idx          ; Stay at last digit
0DC0 8000      1563       sjmp Do_Refresh
0DC2           1564   
0DC2           1565   Do_Refresh:
0DC2 D221      1566       setb fullscreen_update_signal
0DC4 22        1567       ret
0DC5           1568   
0DC5           1569   Symbol_Key_Ignored:
0DC5 22        1570       ret
0DC6           1571   Keypad_Exit:
0DC6 22        1572       ret
0DC7           1573   
0DC7           1574   ; ----------------------------------------------------------------
0DC7           1575   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0DC7           1576   ; ----------------------------------------------------------------
0DC7           1577   Keypad_Scan:
0DC7           1578       ; Step 1: Check if ANY key is pressed (All Rows Low)
0DC7 C292      1579       clr ROW1
0DC9 C294      1580       clr ROW2
0DCB C296      1581       clr ROW3
0DCD C2A0      1582       clr ROW4
0DCF A2A2      1583       mov C, COL1
0DD1 82A4      1584       anl C, COL2
0DD3 82A6      1585       anl C, COL3
0DD5 82B0      1586       anl C, COL4
0DD7 5002      1587       jnc Keypad_Debounce
0DD9 C3        1588       clr C
0DDA 22        1589       ret
0DDB           1590   
0DDB           1591   Keypad_Debounce:
0DDB 120D13    1592       lcall Wait_25ms_BLOCKING
0DDE A2A2      1593       mov C, COL1
0DE0 82A4      1594       anl C, COL2
0DE2 82A6      1595       anl C, COL3
0DE4 82B0      1596       anl C, COL4
0DE6 5002      1597       jnc Keypad_Find_Row
0DE8 C3        1598       clr C
0DE9 22        1599       ret
0DEA           1600   
0DEA           1601   Keypad_Find_Row:
0DEA D292      1602       setb ROW1
0DEC D294      1603       setb ROW2
0DEE D296      1604       setb ROW3
0DF0 D2A0      1605       setb ROW4
0DF2           1606   
0DF2           1607       ; Row 1
0DF2 C292      1608       clr ROW1
0DF4 30A23D    1609       jnb COL1, Keypad_Key_1
0DF7 30A43E    1610       jnb COL2, Keypad_Key_2
0DFA 30A63F    1611       jnb COL3, Keypad_Key_3
0DFD 30B040    1612       jnb COL4, Keypad_Key_A
0E00 D292      1613       setb ROW1
0E02           1614   
0E02           1615       ; Row 2
0E02 C294      1616       clr ROW2
0E04 30A23D    1617       jnb COL1, Keypad_Key_4
0E07 30A43E    1618       jnb COL2, Keypad_Key_5
0E0A 30A63F    1619       jnb COL3, Keypad_Key_6
0E0D 30B040    1620       jnb COL4, Keypad_Key_B
0E10 D294      1621       setb ROW2
0E12           1622   
0E12           1623       ; Row 3
0E12 C296      1624       clr ROW3
0E14 30A23D    1625       jnb COL1, Keypad_Key_7
0E17 30A43E    1626       jnb COL2, Keypad_Key_8
0E1A 30A63F    1627       jnb COL3, Keypad_Key_9
0E1D 30B040    1628       jnb COL4, Keypad_Key_C
0E20 D296      1629       setb ROW3
0E22           1630   
0E22           1631       ; Row 4
0E22 C2A0      1632       clr ROW4
0E24 30A23D    1633       jnb COL1, Keypad_Key_Star
0E27 30A43E    1634       jnb COL2, Keypad_Key_0
0E2A 30A63F    1635       jnb COL3, Keypad_Key_Hash
0E2D 30B040    1636       jnb COL4, Keypad_Key_D
0E30 D2A0      1637       setb ROW4
0E32 C3        1638       clr C
0E33 22        1639       ret
0E34           1640   
0E34           1641   ; Key Mapping (Renamed to avoid conflicts)
0E34 7F01      1642   Keypad_Key_1: mov R7, #1
0E36 803C      1643          sjmp Wait_Release
0E38 7F02      1644   Keypad_Key_2: mov R7, #2
0E3A 8038      1645          sjmp Wait_Release
0E3C 7F03      1646   Keypad_Key_3: mov R7, #3
0E3E 8034      1647          sjmp Wait_Release
0E40 7F0A      1648   Keypad_Key_A: mov R7, #10
0E42 8030      1649          sjmp Wait_Release
0E44 7F04      1650   Keypad_Key_4: mov R7, #4
0E46 802C      1651          sjmp Wait_Release
0E48 7F05      1652   Keypad_Key_5: mov R7, #5
0E4A 8028      1653          sjmp Wait_Release
0E4C 7F06      1654   Keypad_Key_6: mov R7, #6
0E4E 8024      1655          sjmp Wait_Release
0E50 7F0B      1656   Keypad_Key_B: mov R7, #11
0E52 8020      1657          sjmp Wait_Release
0E54 7F07      1658   Keypad_Key_7: mov R7, #7
0E56 801C      1659          sjmp Wait_Release
0E58 7F08      1660   Keypad_Key_8: mov R7, #8
0E5A 8018      1661          sjmp Wait_Release
0E5C 7F09      1662   Keypad_Key_9: mov R7, #9
0E5E 8014      1663          sjmp Wait_Release
0E60 7F0D      1664   Keypad_Key_C: mov R7, #13
0E62 8010      1665          sjmp Wait_Release
0E64 7F0E      1666   Keypad_Key_Star: mov R7, #14
0E66 800C      1667          sjmp Wait_Release
0E68 7F00      1668   Keypad_Key_0: mov R7, #0
0E6A 8008      1669          sjmp Wait_Release
0E6C 7F0C      1670   Keypad_Key_Hash: mov R7, #12
0E6E 8004      1671          sjmp Wait_Release
0E70 7F0F      1672   Keypad_Key_D: mov R7, #15
0E72 8000      1673          sjmp Wait_Release
0E74           1674   
0E74           1675   Wait_Release:
0E74 A2A2      1676       mov C, COL1
0E76 82A4      1677       anl C, COL2
0E78 82A6      1678       anl C, COL3
0E7A 82B0      1679       anl C, COL4
0E7C 50F6      1680       jnc Wait_Release
0E7E D3        1681       setb C
0E7F D292      1682       setb ROW1
0E81 D294      1683       setb ROW2
0E83 D296      1684       setb ROW3
0E85 D2A0      1685       setb ROW4
0E87 22        1686       ret
0E88           1687   
0E88           1688   Wait_25ms:
0E88           1689       ; 1. Check if we are already waiting
0E88 20170E    1690       jb wait25_active, Check_Timer_Status
0E8B           1691       
0E8B           1692       ; 2. Check if we just finished
0E8B 301804    1693       jnb wait25_done, Start_New_Timer
0E8E           1694       
0E8E           1695       ; 3. Timer is DONE! Reset flags and return True
0E8E C218      1696       clr wait25_done
0E90 D3        1697       setb C          ; Carry = 1 means "Done"
0E91 22        1698       ret
0E92           1699   
0E92           1700   Start_New_Timer:
0E92           1701       ; 4. Start a new 25ms wait
0E92 755700    1702       mov wait25_count, #0
0E95 D217      1703       setb wait25_active
0E97 C3        1704       clr C           ; Carry = 0 means "Not Done Yet"
0E98 22        1705       ret
0E99           1706   
0E99           1707   Check_Timer_Status:
0E99           1708       ; 5. Still waiting... return False immediately
0E99 C3        1709       clr C           ; Carry = 0 means "Not Done Yet"
0E9A 22        1710       ret
0E9B           1711   
0E9B           1712   ; ----------------------------------------------------------------
0E9B           1713   ; MODULE: BUFFER INIT (Reset Logic)
0E9B           1714   ; ----------------------------------------------------------------
0E9B           1715   Init_All_Buffers:
0E9B 7880      1716       mov R0, #Buf_Soak_Temp
0E9D 120EB0    1717       lcall Init_Temp_Template
0EA0 7889      1718       mov R0, #Buf_Refl_Temp
0EA2 120EB0    1719       lcall Init_Temp_Template
0EA5 7884      1720       mov R0, #Buf_Soak_Time
0EA7 120EBC    1721       lcall Init_Time_Template
0EAA 788D      1722       mov R0, #Buf_Refl_Time
0EAC 120EBC    1723       lcall Init_Time_Template
0EAF 22        1724       ret
0EB0           1725   
0EB0           1726   Init_Temp_Template:
0EB0 7630      1727       mov @R0, #'0'
0EB2 08        1728       inc R0
0EB3 7630      1729       mov @R0, #'0'
0EB5 08        1730       inc R0
0EB6 7630      1731       mov @R0, #'0'
0EB8 08        1732       inc R0
0EB9 7600      1733       mov @R0, #0
0EBB 22        1734       ret
0EBC           1735   
0EBC           1736   Init_Time_Template:
0EBC 7630      1737       mov @R0, #'0'
0EBE 08        1738       inc R0
0EBF 7630      1739       mov @R0, #'0'
0EC1 08        1740       inc R0
0EC2 7630      1741       mov @R0, #'0'
0EC4 08        1742       inc R0
0EC5 7630      1743       mov @R0, #'0'
0EC7 08        1744       inc R0
0EC8 7600      1745       mov @R0, #0
0ECA 22        1746       ret
0ECB           1747   
0ECB           1748   Reset_Current_Buffer:
0ECB E561      1749       mov A, Current_State
0ECD B40106    1750       cjne A, #1, Reset_Chk_2
0ED0 7880      1751       mov R0, #Buf_Soak_Temp
0ED2 120EB0    1752       lcall Init_Temp_Template
0ED5 22        1753       ret
0ED6           1754   Reset_Chk_2:
0ED6 B40206    1755       cjne A, #2, Reset_Chk_3
0ED9 7884      1756       mov R0, #Buf_Soak_Time
0EDB 120EBC    1757       lcall Init_Time_Template
0EDE 22        1758       ret
0EDF           1759   Reset_Chk_3:
0EDF B40306    1760       cjne A, #3, Reset_Chk_4
0EE2 7889      1761       mov R0, #Buf_Refl_Temp
0EE4 120EB0    1762       lcall Init_Temp_Template
0EE7 22        1763       ret
0EE8           1764   Reset_Chk_4:
0EE8 788D      1765       mov R0, #Buf_Refl_Time
0EEA 120EBC    1766       lcall Init_Time_Template
0EED 22        1767       ret 
0EEE           1768       
0EEE           1769   ; ================================================================
0EEE           1770   ; MODULE: THERMOCOUPLE ADC DRIVER
0EEE           1771   ; ================================================================
0EEE           1772   Read_Thermocouple:
0EEE           1773       ; 1. Check Non-Blocking Timer (Run once every 25ms)
0EEE 120E88    1774       lcall Wait_25ms
0EF1 5059      1775       jnc Read_TC_Exit ; If 25ms hasn't passed, exit immediately
0EF3           1776       
0EF3           1777       ; --- 25ms Passed! Time to Read ---
0EF3           1778       
0EF3           1779       ; 2. Initialize / Trigger ADC
0EF3           1780       ; Writing to ADC_C (0xA1) triggers the conversion
0EF3 75A180    1781       mov ADC_C, #0x80    ; Reset / Strobe
0EF6 00        1782       nop
0EF7 00        1783       nop
0EF8 75A100    1784       mov ADC_C, #0x00    ; Select Channel 0 (ADCINPUT 0) and Start
0EFB           1785       
0EFB           1786       ; 3. [FIX] Settle Delay
0EFB           1787       ; The DE10-Lite ADC bridge needs time to fetch data from the MAX10 chip.
0EFB           1788       ; We burn ~500 cycles to be absolutely safe.
0EFB 7DFA      1789       mov R5, #250
0EFD           1790   ADC_Settle_Loop:
0EFD 00        1791       nop
0EFE 00        1792       nop
0EFF DDFC      1793       djnz R5, ADC_Settle_Loop
0F01           1794       
0F01           1795       ; 4. Read Raw Data
0F01 85A23A    1796       mov x+0, ADC_L      ; Read Low Byte (0xA2)
0F04 85A33B    1797       mov x+1, ADC_H      ; Read High Byte (0xA3)
0F07 753C00    1798       mov x+2, #0
0F0A 753D00    1799       mov x+3, #0
0F0D           1800       
0F0D           1801       ; 5. [FIX] Mask the 12-bit Data
0F0D           1802       ; The ADC is 12-bit. We MUST zero out the upper 4 bits of the High Byte
0F0D           1803       ; or the math below will overflow and return 0.
0F0D E53B      1804       mov a, x+1
0F0F 540F      1805       anl a, #0x0F
0F11 F53B      1806       mov x+1, a
0F13           1807       
0F13           1808       ; 6. Convert to Voltage (Count * 5000 / 4095)
0F13 753E88    1809            mov y+0, #low (5000 % 0x10000) 
0F16 753F13    1809            mov y+1, #high(5000 % 0x10000) 
0F19 754000    1809            mov y+2, #low (5000 / 0x10000) 
0F1C 754100    1809            mov y+3, #high(5000 / 0x10000)         ; Vref = 5000mV
0F1F 12018C    1810       lcall mul32         
0F22           1811       
0F22 753EFF    1812            mov y+0, #low (4095 % 0x10000) 
0F25 753F0F    1812            mov y+1, #high(4095 % 0x10000) 
0F28 754000    1812            mov y+2, #low (4095 / 0x10000) 
0F2B 754100    1812            mov y+3, #high(4095 / 0x10000)         ; 12-bit resolution
0F2E 120280    1813       lcall div32         
0F31           1814       
0F31           1815       ; 7. Convert to Temp (Voltage / 10mV) -> e.g. 250mV / 10 = 25C
0F31           1816       ; Change this Load_y value if your amp gain is different!
0F31 753E0A    1817            mov y+0, #low (10 % 0x10000) 
0F34 753F00    1817            mov y+1, #high(10 % 0x10000) 
0F37 754000    1817            mov y+2, #low (10 / 0x10000) 
0F3A 754100    1817            mov y+3, #high(10 / 0x10000)           
0F3D 120280    1818       lcall div32         
0F40           1819       
0F40           1820       ; 8. Store Final Result
0F40 853A47    1821       mov current_temp+0, x+0
0F43 853B48    1822       mov current_temp+1, x+1
0F46 853C49    1823       mov current_temp+2, x+2
0F49 853D4A    1824       mov current_temp+3, x+3
0F4C           1825   
0F4C           1826   Read_TC_Exit:
0F4C 22        1827       ret
0F4D           1828       
0F4D           1829   ; ================================================================
0F4D           1830   ; MODULE: POWER CONTROLLER (The Brain)
0F4D           1831   ; ================================================================
0F4D           1832   Power_Control:
0F4D           1833       ; Default: Turn Heat OFF (Safety)
0F4D 755800    1834       mov power_output+0, #0
0F50 755900    1835       mov power_output+1, #0
0F53 755A00    1836       mov power_output+2, #0
0F56 755B00    1837       mov power_output+3, #0
0F59           1838   
0F59 E560      1839       mov a, Control_FSM_state
0F5B           1840   
0F5B           1841       ; --- State 2: RAMP TO SOAK ---
0F5B B40202    1842       cjne a, #2, PC_Check_Soak
0F5E           1843       ; Mode: Full Speed Ahead
0F5E 8016      1844       sjmp Set_Max_Power
0F60           1845   
0F60           1846   PC_Check_Soak:
0F60           1847       ; --- State 3: SOAK PHASE ---
0F60 B40305    1848       cjne a, #3, PC_Check_Ramp_Reflow
0F63           1849       ; Mode: Maintenance (Low Power)
0F63           1850       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
0F63 20050F    1851       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
0F66 801B      1852       sjmp Set_20_Percent_Power     ; If cold, use 20%
0F68           1853   
0F68           1854   PC_Check_Ramp_Reflow:
0F68           1855       ; --- State 4: RAMP TO REFLOW ---
0F68 B40402    1856       cjne a, #4, PC_Check_Reflow
0F6B           1857       ; Mode: Full Speed Ahead
0F6B 8009      1858       sjmp Set_Max_Power
0F6D           1859   
0F6D           1860   PC_Check_Reflow:
0F6D           1861       ; --- State 5: REFLOW PHASE ---
0F6D B40505    1862       cjne a, #5, PC_Done
0F70           1863       ; Mode: Maintenance (Low Power)
0F70 200602    1864       jb reflow_temp_reached, PC_Done
0F73 800E      1865       sjmp Set_20_Percent_Power
0F75           1866   
0F75           1867   PC_Done:
0F75 22        1868       ret
0F76           1869   
0F76           1870   ; --- Power Helpers ---
0F76           1871   
0F76           1872   Set_Max_Power:
0F76           1873       ; Load 1500 (0x05DC) = 100% Duty Cycle
0F76 7558DC    1874       mov power_output+0, #0xDC
0F79 755905    1875       mov power_output+1, #0x05
0F7C 755A00    1876       mov power_output+2, #0
0F7F 755B00    1877       mov power_output+3, #0
0F82 22        1878       ret
0F83           1879   
0F83           1880   Set_20_Percent_Power:
0F83           1881       ; Load 300 (0x012C) = 20% Duty Cycle
0F83 75582C    1882       mov power_output+0, #0x2C
0F86 755901    1883       mov power_output+1, #0x01
0F89 755A00    1884       mov power_output+2, #0
0F8C 755B00    1885       mov power_output+3, #0
0F8F 22        1886       ret
0F90           1887   
0F90           1888   ;-------------------------------------------------------------------------------;
0F90           1889   ;         Main program.          
0F90           1890   ;-------------------------------------------------------------------------------;
0F90           1891   main:
0F90           1892   
0F90           1893       ; --------------------------------------------------------
0F90           1894       ; 1. SAFETY SHUTDOWN
0F90           1895       ; --------------------------------------------------------
0F90 C2AF      1896       clr EA              ; FORCE Interrupts OFF immediately
0F92 7581C0    1897       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0F95           1898       
0F95           1899       ; --------------------------------------------------------
0F95           1900       ; 2. THE "DIRTY DELAY" (Fixes Reset Garbage)
0F95           1901       ; We burn ~100ms here using a raw loop. 
0F95           1902       ; We cannot use timers yet because they aren't initialized.
0F95           1903       ; --------------------------------------------------------
0F95 78FA      1904       mov R0, #250
0F97           1905   Reset_Delay_Outer:
0F97 79FF      1906       mov R1, #255
0F99           1907   Reset_Delay_Inner:
0F99 D9FE      1908       djnz R1, Reset_Delay_Inner
0F9B D8FA      1909       djnz R0, Reset_Delay_Outer
0F9D           1910       ; --------------------------------------------------------
0F9D           1911   
0F9D           1912       ; ... NOW continue with your normal Port Configuration ...
0F9D           1913       
0F9D           1914       ; --- PORT CONFIGURATION ---
0F9D 759AAA    1915       mov P0MOD, #0xAA
0FA0           1916   
0FA0           1917       ; P1: Mixed usage 
0FA0           1918       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0FA0           1919       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0FA0           1920       ; P1.0 (Unused/RX) -> Input
0FA0           1921       ; Binary: 11111110 -> Hex: 0xFE
0FA0 759BFE    1922       mov P1MOD, #0xFE
0FA3           1923   
0FA3           1924       ; P2: Row4(Out), Cols(In)
0FA3           1925       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0FA3           1926       ; Binary: 00000001 -> Hex: 0x01
0FA3 759C01    1927       mov P2MOD, #0x01
0FA6           1928   
0FA6           1929       ; P3: Col4(In)
0FA6           1930       ; P3.0 (Col4) is In (0).
0FA6 759D00    1931       mov P3MOD, #0x00
0FA9           1932       ; Turn off all the LEDs
0FA9 75E800    1933       mov LEDRA, #0 ; LEDRA is bit addressable
0FAC 759500    1934       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0FAF           1935   
0FAF           1936       ; Enable Global interrupts
0FAF D2AF      1937       setb EA  
0FB1           1938   
0FB1           1939            ; FSM initial states
0FB1 756800    1940            mov SEC_FSM_state, #0
0FB4 756000    1941            mov Control_FSM_state, #0
0FB7 756100    1942            mov Current_State, #0
0FBA           1943            ; FSM timers initialization
0FBA 756700    1944            mov SEC_FSM_timer, #0
0FBD           1945            ; time counters initialization
0FBD 753000    1946            mov current_time_sec, #0
0FC0 753100    1947            mov current_time_minute, #0
0FC3 753200    1948            mov soak_time_sec, #0
0FC6 753300    1949            mov soak_time_minute, #0
0FC9 753400    1950            mov reflow_time_sec, #0
0FCC 753500    1951            mov reflow_time_minute, #0
0FCF 753600    1952            mov soak_end_time_sec, #0
0FD2 753700    1953            mov soak_end_time_minute, #0
0FD5 753800    1954            mov reflow_end_time_sec, #0
0FD8 753900    1955            mov reflow_end_time_minute, #0
0FDB           1956       ; Initialize counter to zero
0FDB 755C00    1957       mov pwm_counter, #0
0FDE 755D00    1958       mov pwm_counter+1, #0
0FE1 755E00    1959       mov pwm_counter+2, #0
0FE4 755F00    1960       mov pwm_counter+3, #0
0FE7           1961       ; Initialize power output
0FE7 755B00    1962       mov power_output+3, #0
0FEA 755A00    1963       mov power_output+2, #0
0FED 755902    1964       mov power_output+1, #02H
0FF0 7558EE    1965       mov power_output, #0EEH ; (initilize to 750 for testing)
0FF3           1966            ; FSM Buttons push button init
0FF3 756A00    1967            mov     PB0_DEB_state, #0
0FF6 756C00    1968            mov     PB2_DEB_state, #0
0FF9 756900    1969            mov     PB0_DEB_timer, #0
0FFC 756B00    1970            mov     PB2_DEB_timer, #0
0FFF           1971   
0FFF           1972            ; Clear all the flags
0FFF C295      1973            clr SOUND_OUT
1001 C212      1974            clr tc_missing_abort
1003 C20B      1975            clr stop_signal
1005 C214      1976            clr PB0_flag
1007 C215      1977            clr PB1_flag
1009 C216      1978            clr PB2_flag
100B C201      1979            clr one_second_flag
100D C204      1980            clr one_second_lcd_flag
100F C20E      1981            clr config_finish_signal
1011 C205      1982            clr soak_temp_reached
1013 C208      1983            clr soak_time_reached
1015 C206      1984            clr reflow_temp_reached
1017 C209      1985            clr reflow_time_reached
1019 C207      1986            clr cooling_temp_reached
101B C210      1987            clr state_change_signal_TC
101D C211      1988            clr state_change_signal_Count
101F C20D      1989            clr time_count_doing_signal
1021           1990   
1021 C222      1991            clr one_second_flag_test
1023           1992            
1023           1993       ; Set bit
1023 D20F      1994            setb state_change_signal
1025 D213      1995       setb tc_startup_window
1027           1996   
1027 120456    1997       lcall Timer0_Init
102A 1204BE    1998       lcall Timer2_Init
102D 12058B    1999       lcall ELCD_4BIT
1030           2000       ;----- Two new lines I added to initialize the UI
1030 120E9B    2001       lcall Init_All_Buffers
1033           2002       ;-----
1033 120470    2003       lcall Initialize_Serial_Port
1036           2004   ;-------------------------------------------------------------------------------;
1036           2005   ; while(1) loop
1036           2006   ;-------------------------------------------------------------------------------;
1036           2007   loop:
1036 1209B3    2008            lcall SEC_FSM
1039           2009            ;lcall FSM_test
1039           2010   
1039           2011            ; Check the FSM for the overall control flow of the reflow process
1039 120BC5    2012       lcall Control_FSM
103C           2013   
103C           2014       ; Check the FSM for PB01 debounce
103C 120945    2015       lcall PB0_DEB
103F 12097D    2016            lcall PB2_DEB
1042           2017       
1042           2018       ; Added to take temp readings
1042 120EEE    2019       lcall Read_Thermocouple
1045           2020       
1045           2021       ; 1. Check if we reached temp (Observer)
1045           2022       ;lcall Temp_Compare
1045           2023       
1045           2024       ; 2. Decide heater power based on flags (Driver)
1045 120F4D    2025       lcall Power_Control
1048           2026       
1048           2027       ;lcall Safety_Check_TC
1048           2028   
1048 120A0F    2029            lcall Time_Counter
104B           2030   
104B           2031            ; Update Variables (times and temp)
104B 120C95    2032            lcall Update_FSM_Variables
104E           2033   
104E           2034            ; Update while at state 1
104E           2035            ; LCD
104E 12080D    2036            lcall Update_Screen_Full 
1051           2037            ; Buttons
1051 120D19    2038            lcall Check_Buttons 
1054           2039            ; PB0pad
1054 120D6F    2040       lcall Check_Keypad
1057           2041   
1057           2042       ; Update the LCD display based on the current state
1057 12063B    2043       lcall LCD_Display_Update_func
105A           2044   
105A 1207DE    2045            lcall LCD_Display_Update_Time
105D           2046   
105D 120A31    2047            lcall Time_Compare_MMSS
1060           2048   
1060           2049       ; Update the pwm output for the ssr
1060 120B07    2050       lcall PWM_Wave 
1063           2051   
1063           2052       ; After initialization the program stays in this 'forever' loop
1063 021036    2053       ljmp loop
1066           2054   ;-------------------------------------------------------------------------------;
1066           2055   EN
