0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 020A1B       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 020469      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 0204D6      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   current_time_sec:     ds 1
0031             38   current_time_minute:  ds 1
0032             39   ; math32 buffer variables
0032             40   x:      ds  4
0036             41   y:      ds  4
003A             42   bcd:    ds  5
003F             43   
003F             44   current_temp: ds 4 ;
0043             45   soak_temp:    ds 4 ;
0047             46   reflow_temp:  ds 4 ;
004B             47   
004B             48   wait25_btn_cnt:    ds 1
004C             49   wait25_keypad_cnt: ds 1
004D             50   wait25_adc_cnt:    ds 1
004E             51   wait25_lcd_cnt:    ds 1
004F             52   wait25_count: ds 1  
0050             53   
0050             54   current_time: ds 4 ;
0054             55   soak_time:    ds 4 ;
0058             56   reflow_time:  ds 4 ;
005C             57   
005C             58   power_output:  ds 4 ;
0060             59   pwm_counter: ds 4 ; counter for pwm (0-1500)
0064             60   
0064             61   KEY1_DEB_timer: ds 1
0065             62   SEC_FSM_timer:  ds 1
0066             63   KEY1_DEB_state:    ds 1
0067             64   SEC_FSM_state:     ds 1
0068             65   Control_FSM_state: ds 1 
0069             66   
0069             67   Current_State:     ds 1
006A             68   
006A             69   
006A             70   ;-- UI buffers I added (ayaan)
006A             71   Cursor_Idx: ds 1
006B             72   
006B             73   ; These hold the TEXT (ASCII) safely
006B             74   ; Digits Only + Null Terminator, got rid of C,:, and s 
006B             75   Buf_Soak_Temp: ds 4   
006F             76   Buf_Soak_Time: ds 5   
0074             77   Buf_Refl_Temp: ds 4   
0078             78   Buf_Refl_Time: ds 5
007D             79   
007D             80   ; 46d bytes used
007D             81   
007D             82   ;-------------------------------------------------------------------------------
007D             83   ; bit operation setb, clr, jb, and jnb
0000             84   bseg
0000             85   mf:     dbit 1 ; math32 sign
0001             86   one_second_flag: dbit 1
0002             87   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003             88   
0003             89   soak_temp_reached: dbit 1
0004             90   reflow_temp_reached: dbit 1
0005             91   cooling_temp_reached: dbit 1
0006             92   
0006             93   soak_time_reached: dbit 1
0007             94   reflow_time_reached: dbit 1
0008             95   
0008             96   reset_signal: dbit 1
0009             97   stop_signal: dbit 1
000A             98   start_signal: dbit 1
000B             99   config_finish_signal: dbit 1
000C            100   
000C            101   state_change_signal: dbit 1
000D            102   
000D            103   Key1_flag: dbit 1
000E            104   
000E            105   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
000F            106   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0010            107   PB0_flag: dbit 1 ; start entire program
0011            108   PB1_flag: dbit 1 ; start soak
0012            109   PB2_flag: dbit 1 ; pause process
0013            110   
0013            111   ; BSEG (Bit Segment)
0013            112   wait25_active: dbit 1 ; 1 = We are currently waiting
0014            113   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0015            114   wait25_btn_active:    dbit 1
0016            115   wait25_btn_done:      dbit 1
0017            116   wait25_keypad_active: dbit 1
0018            117   wait25_keypad_done:   dbit 1
0019            118   wait25_adc_active:    dbit 1
001A            119   wait25_adc_done:      dbit 1
001B            120   wait25_lcd_active:    dbit 1
001C            121   wait25_lcd_done:      dbit 1
001D            122   ; 11 bits used
001D            123   
001D            124   ;-------------------------------------------------------------------------------
0320            125   cseg
0320            126   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            127   BAUD           EQU 57600
0320            128   
0320            129   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            130   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            131   ; is always 12 unlike the N76E003 where is selectable.
0320            132   
0320            133   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            134   
0320            135   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            136   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            137   
0320            138   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            139   
0320            140   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            141   
0320            142   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            143   
0320            144   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            145   ; P0 is in connector JPIO.
0320            146   
0320            147   ;Added correct I/O definitions
0320            148   ;-- LCD Pins ---
0320            149   ELCD_RS equ P1.7
0320            150   ELCD_E  equ P1.1
0320            151   ELCD_D4 equ P0.7
0320            152   ELCD_D5 equ P0.5
0320            153   ELCD_D6 equ P0.3
0320            154   ELCD_D7 equ P0.1
0320            155   
0320            156   ; -- Buttons --
0320            157   BTN_SOAK_TEMP equ P0.0
0320            158   BTN_SOAK_TIME equ P0.2
0320            159   BTN_REFL_TEMP equ P0.4
0320            160   BTN_REFL_TIME equ P0.6
0320            161   
0320            162   ; --- KEYPAD ---
0320            163   ROW1 equ P1.2
0320            164   ROW2 equ P1.4
0320            165   ROW3 equ P1.6
0320            166   ROW4 equ P2.0
0320            167   COL1 equ P2.2
0320            168   COL2 equ P2.4
0320            169   COL3 equ P2.6
0320            170   COL4 equ P3.0
0320            171   
0320            172   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   173   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   174   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   175   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            176   
0350            177   ; --- UI STRINGS (REQUIRED FOR KEYPAD LOGIC), <- I can fix if duplicates
0350 53656C65   178   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   179   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   180   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   181   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   182   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            183   
03A5            184   ;                       1234567890123456
03A5 53657420   185   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   186   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   187   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   188   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   189   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            190   
03E5            191   ;                     1234567890123456
03E5 52616D70   192   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03F5 536F616B   193   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
0405 52616D70   194   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
0415 5265666C   195   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
0425 436F6F6C   196   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
0435 50726F63   197   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
0445            198   
0445 20202020   199   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
0456            200   
0456            201   ;-------------------------------------------------------------------------------
0456            202   ; Timers Setting:
0456            203   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
0456            204   ;   Timer 1: Serial port baud rate 57600 generator
0456            205   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
0456            206   ;-------------------------------------------------------------------------------
0456            207   ; Routine to initialize the ISR for Timer 0 ;
0456            208   Timer0_Init:
0456 E589       209       mov a, TMOD
0458 54F0       210       anl a, #0xf0 ; Clear the bits for timer 0
045A 4401       211       orl a, #0x01 ; Configure timer 0 as 16-timer
045C F589       212       mov TMOD, a
045E 758CFD     213       mov TH0, #high(TIMER0_RELOAD)
0461 758A5A     214       mov TL0, #low(TIMER0_RELOAD)
0464            215       ; Enable the timer and interrupts
0464 D2A9       216       setb ET0  ; Enable timer 0 interrupt
0466 D28C       217       setb TR0  ; Start timer 0
0468 22         218       ret
0469            219   ; ISR for timer 0.  Set to execute every 1/4096Hz 
0469            220   ; to generate a 2048 Hz square wave at pin P1.5 
0469            221   Timer0_ISR:
0469            222       ;clr TF0  ; According to the data sheet this is done for us already.
0469 758CFD     223       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
046C 758A5A     224       mov TL0, #low(TIMER0_RELOAD)
046F B295       225       cpl SOUND_OUT ; Connect speaker to P1.5
0471 32         226       reti
0472            227   ; -----------------------------------------------------------------------------------------------;
0472            228   
0472            229   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0472            230   Initialize_Serial_Port:
0472            231       ; Configure serial port and baud rate
0472 C28E       232       clr TR1 ; Disable timer 1
0474 53890F     233       anl TMOD, #0x0f ; Mask the bits for timer 1
0477 438920     234       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047A 438780     235       orl PCON, #80H ; Set SMOD to 1
047D 758DFD     236       mov TH1, #low(TIMER_1_RELOAD)
0480 758BFD     237       mov TL1, #low(TIMER_1_RELOAD) 
0483 D28E       238       setb TR1 ; Enable timer 1
0485 759852     239       mov SCON, #52H
0488 22         240       ret
0489            241   
0489            242   ; uart sending functions
0489            243   putchar:
0489 109902     244       jbc TI, putchar_L1
048C 80FB       245       sjmp putchar
048E            246   putchar_L1:
048E F599       247       mov SBUF,a
0490 22         248       ret
0491            249   
0491            250   SendString:
0491 E4         251       clr a
0492 93         252       movc a, @a+dptr
0493 6006       253       jz SendString_L1
0495 120489     254       lcall putchar
0498 A3         255       inc dptr
0499 80F6       256       sjmp SendString  
049B            257   SendString_L1:
049B 22         258       ret
049C            259   
049C            260   ;-------------------------------------------------------------------------------
049C            261   ; serial debugging
049C            262   ; send a four byte number via serial to laptop
049C            263   ; need to be used with python script
049C            264   ; content needed to be sent should be stored in the varaible x
049C            265   ;-------------------------------------------------------------------------------
049C            266   Send32:
049C            267       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
049C 74AA       268       mov A, #0AAH
049E 120489     269       lcall putchar
04A1 7455       270       mov A, #055H
04A3 120489     271       lcall putchar
04A6            272   
04A6 E535       273       mov A, x+3
04A8 120489     274       lcall putchar
04AB E534       275       mov A, x+2
04AD 120489     276       lcall putchar
04B0 E533       277       mov A, x+1
04B2 120489     278       lcall putchar
04B5 E532       279       mov A, x+0
04B7 120489     280       lcall putchar
04BA            281   
04BA 740A       282       mov A, #0AH
04BC 120489     283       lcall putchar
04BF 22         284       ret
04C0            285   ; -----------------------------------------------------------------------------------------------;
04C0            286   
04C0            287   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
04C0              1   ;-------------------------------------------------------------------------------
04C0              2   ; Timer2_ISR.inc
04C0              3   ; Contains Initialization and ISR for the 1ms System Timer
04C0              4   ;-------------------------------------------------------------------------------
04C0              5   
04C0              6   ;-------------------------------------------------------------------------------
04C0              7   ; Routine to initialize the ISR for timer 2
04C0              8   ;-------------------------------------------------------------------------------
04C0              9   Timer2_Init:
04C0 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
04C3 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
04C6 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
04C9             13       ; Set the reload value
04C9 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
04CC 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
04CF             16       
04CF C2CF        17       clr TF2       ; Clear flag just in case
04D1             18       ; Enable the timer and interrupts
04D1 D2AD        19       setb ET2      ; Enable timer 2 interrupt
04D3 D2CA        20       setb TR2      ; Enable timer 2
04D5 22          21       ret
04D6             22   
04D6             23   ;-------------------------------------------------------------------------------
04D6             24   ; ISR for timer 2.  Runs every 1 ms
04D6             25   ;-------------------------------------------------------------------------------
04D6             26   Timer2_ISR:
04D6 C0E0        27       push acc
04D8 C0D0        28       push psw
04DA             29       
04DA C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
04DC             31   
04DC             32       ; --- 1. Existing FSM Timers ---
04DC 0564        33       inc KEY1_DEB_timer
04DE 0565        34       inc SEC_FSM_timer
04E0 D202        35       setb one_ms_pwm_flag 
04E2             36   
04E2             37       ; --- 2. NEW: Non-Blocking Delay Counters ---
04E2             38       
04E2             39       ; A. BUTTON DELAY
04E2 30150B      40       jnb wait25_btn_active, T2_Check_Keypad
04E5 054B        41       inc wait25_btn_cnt
04E7 E54B        42       mov a, wait25_btn_cnt
04E9 B41904      43       cjne a, #25, T2_Check_Keypad
04EC D216        44       setb wait25_btn_done
04EE C215        45       clr wait25_btn_active
04F0             46       
04F0             47       ; B. KEYPAD DELAY
04F0             48   T2_Check_Keypad:
04F0 30170B      49       jnb wait25_keypad_active, T2_Check_ADC
04F3 054C        50       inc wait25_keypad_cnt
04F5 E54C        51       mov a, wait25_keypad_cnt
04F7 B41904      52       cjne a, #25, T2_Check_ADC
04FA D218        53       setb wait25_keypad_done
04FC C217        54       clr wait25_keypad_active
04FE             55   
04FE             56       ; C. ADC DELAY (Thermocouple)
04FE             57   T2_Check_ADC:
04FE 30190B      58       jnb wait25_adc_active, T2_Check_LCD
0501 054D        59       inc wait25_adc_cnt
0503 E54D        60       mov a, wait25_adc_cnt
0505 B41904      61       cjne a, #25, T2_Check_LCD
0508 D21A        62       setb wait25_adc_done
050A C219        63       clr wait25_adc_active
050C             64   
050C             65       ; D. LCD DELAY
050C             66   T2_Check_LCD:
050C 301B0B      67       jnb wait25_lcd_active, T2_Check_Generic
050F 054E        68       inc wait25_lcd_cnt
0511 E54E        69       mov a, wait25_lcd_cnt
0513 B41904      70       cjne a, #25, T2_Check_Generic
0516 D21C        71       setb wait25_lcd_done
0518 C21B        72       clr wait25_lcd_active
051A             73   
051A             74       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
051A             75   T2_Check_Generic:
051A 30130B      76       jnb wait25_active, Timer2_ISR_done
051D 054F        77       inc wait25_count
051F E54F        78       mov a, wait25_count
0521 B41904      79       cjne a, #25, Timer2_ISR_done
0524 D214        80       setb wait25_done      ; Tells Wait_25ms that we are finished
0526 C213        81       clr wait25_active     ; Stop counting
0528             82   
0528             83   Timer2_ISR_done:
0528 D0D0        84       pop psw
052A D0E0        85       pop acc
052C 32          86       reti
052D             87            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
052D              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
052D              2   cseg
052D              3   
052D              4   ; When using a 33.333333MHz crystal clock
052D              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
052D              6   
052D              7   ;---------------------------------;
052D              8   ; Wait 40 microseconds            ;
052D              9   ;---------------------------------;
052D             10   Wait40uSec:
052D C000        11            push AR0
052F 78BE        12            mov R0, #190
0531             13   L0: 
0531 00          14            nop
0532 00          15            nop
0533 00          16            nop
0534 00          17            nop
0535 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0537 D000        19            pop AR0
0539 22          20       ret
053A             21   
053A             22   ;---------------------------------;
053A             23   ; Wait 'R2' milliseconds          ;
053A             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
053A             31   
053A             32   ?Wait_Milli_Seconds:
053A C000        33            push AR0
053C C001        34            push AR1
053E 7932        35   L3: mov R1, #50
0540 78DF        36   L2: mov R0, #223
0542 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
0544 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
0546 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
0548 D001        40       pop AR1
054A D000        41       pop AR0
054C 22          42       ret
054D             43            
054D             44   ;---------------------------------;
054D             45   ; Toggles the 'E' pin in the LCD  ;
054D             46   ;---------------------------------;
054D             47   ELCD_pulse:
054D D291        48            setb ELCD_E
054F 12052D      49            lcall Wait40uSec
0552 C291        50            clr ELCD_E
0554 12052D      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
0557 22          52       ret
0558             53   
0558             54   ;---------------------------------;
0558             55   ; Writes acc to LCD in 4-bit mode ;
0558             56   ;---------------------------------;
0558             57   ELCD_byte:
0558             58            ; Write high 4 bits first
0558 A2E7        59            mov c, ACC.7
055A 9281        60            mov ELCD_D7, c
055C A2E6        61            mov c, ACC.6
055E 9283        62            mov ELCD_D6, c
0560 A2E5        63            mov c, ACC.5
0562 9285        64            mov ELCD_D5, c
0564 A2E4        65            mov c, ACC.4
0566 9287        66            mov ELCD_D4, c
0568 12054D      67       lcall ELCD_pulse
056B             68            ; Write low 4 bits next
056B A2E3        69            mov c, ACC.3
056D 9281        70            mov ELCD_D7, c
056F A2E2        71            mov c, ACC.2
0571 9283        72            mov ELCD_D6, c
0573 A2E1        73            mov c, ACC.1
0575 9285        74            mov ELCD_D5, c
0577 A2E0        75            mov c, ACC.0
0579 9287        76            mov ELCD_D4, c
057B 12054D      77       lcall ELCD_pulse
057E 22          78            ret
057F             79   
057F             80   ;---------------------------------;
057F             81   ; Write data to LCD               ;
057F             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
057F             87            
057F             88   ?WriteData:
057F D297        89            setb ELCD_RS
0581 020558      90            ljmp ELCD_byte
0584             91   
0584             92   ;---------------------------------;
0584             93   ; Write command to LCD            ;
0584             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
0584             99   
0584            100   ?WriteCommand:
0584 C297       101            clr ELCD_RS
0586 020558     102            ljmp ELCD_byte
0589            103   
0589            104   ;---------------------------------;
0589            105   ; Configure LCD in 4-bit mode     ;
0589            106   ;---------------------------------;
0589            107   ELCD_4BIT:
0589 C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
058B            109            ;clr ELCD_RW  ; RW forced to zero
058B            110            
058B            111            ; After power on, let the LCD start up before initializing
058B C002       112            push AR2
058D 7A28       112            mov R2, #40
058F 12053A     112            lcall ?Wait_Milli_Seconds
0592 D002       112            pop AR2
0594            112   
0594            113            
0594            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
0594 7433       115            mov a, #0x33
0596 120584     115            lcall ?WriteCommand
0599 7433       116            mov a, #0x33
059B 120584     116            lcall ?WriteCommand
059E 7432       117            mov a, #0x32
05A0 120584     117            lcall ?WriteCommand ; change to 4-bit mode
05A3            118   
05A3            119            ; Configure the LCD
05A3 7428       120            mov a, #0x28
05A5 120584     120            lcall ?WriteCommand
05A8 740C       121            mov a, #0x0c
05AA 120584     121            lcall ?WriteCommand
05AD 7401       122            mov a, #0x01
05AF 120584     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
05B2            123   
05B2            124       ;Wait for the clear screen command to finish.
05B2 C002       125            push AR2
05B4 7A02       125            mov R2, #2
05B6 12053A     125            lcall ?Wait_Milli_Seconds
05B9 D002       125            pop AR2
05BB            125   
05BB 22         126       ret
05BC            127   
05BC            128   ;---------------------------------;
05BC            129   ; Send a constant string to LCD   ;
05BC            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
05BC            141   
05BC            142   ?Send_Constant_String:
05BC E4         143       clr a
05BD 93         144       movc a, @a+dptr
05BE 6006       145       jz ?Send_Constant_String_Done
05C0 12057F     146       lcall ?WriteData
05C3 A3         147       inc dptr
05C4 80F6       148       sjmp ?Send_Constant_String
05C6            149   ?Send_Constant_String_Done:
05C6 22         150       ret  
05C7            151   
05C7            152   ;---------------------------------;
05C7            153   ; Set LCD cursor at row, column   ;
05C7            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
05C7            162   
05C7            163   ?Set_Cursor_2:
05C7 4440       164            orl a, #01000000B
05C9            165   ?Set_Cursor_1:
05C9 4480       166            orl a, #10000000B
05CB 020584     167            ljmp ?WriteCommand ; Select column and row
05CE            168   
05CE            169   ;---------------------------------;
05CE            170   ; Display a BCD number in the LCD ;
05CE            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
05CE            178   
05CE            179   ?Display_BCD:
05CE C0E0       180            push acc
05D0            181            ; Write most significant digit
05D0 E8         182            mov a, r0
05D1 C4         183            swap a
05D2 540F       184            anl a, #0fh
05D4 4430       185            orl a, #30h
05D6 12057F     186            lcall ?WriteData
05D9            187            ; write least significant digit
05D9 E8         188            mov a, r0
05DA 540F       189            anl a, #0fh
05DC 4430       190            orl a, #30h
05DE 12057F     191            lcall ?WriteData
05E1 D0E0       192            pop acc
05E3 22         193            ret
05E4            194   
05E4            195   ;------------------------------------;
05E4            196   ; Display a char in the LCD          ;
05E4            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
05E4            204   
05E4            290            ;-----------------------------------------------------------------------------------------------;
05E4            291   
05E4            292   ;-------------------------------------------------------------------------------
05E4            293   ; Display Function for 7-segment displays       
05E4            294   ;-------------------------------------------------------------------------------
05E4            295   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
05E4            296   T_7seg:
05E4 C0F9A4B0   297       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
05E9 9282F880   298       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
05EE 8883C6A1   299       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
05F4            300   
05F4            301   ; Displays a BCD number pased in R0 in HEX5-HEX0
05F4            302   Display_BCD_7_Seg_HEX10:
05F4 9005E4     303       mov dptr, #T_7seg
05F7 E8         304       mov a, R0
05F8 C4         305       swap a
05F9 540F       306       anl a, #0FH
05FB 93         307       movc a, @a+dptr
05FC F592       308       mov HEX1, a
05FE E8         309       mov a, R0
05FF 540F       310       anl a, #0FH
0601 93         311       movc a, @a+dptr
0602 F591       312       mov HEX0, a
0604 22         313       ret
0605            314   
0605            315   Display_BCD_7_Seg_HEX32:
0605 9005E4     316       mov dptr, #T_7seg
0608 E8         317       mov a, R0
0609 C4         318       swap a
060A 540F       319       anl a, #0FH
060C 93         320       movc a, @a+dptr
060D F594       321       mov HEX3, a
060F E8         322       mov a, R0
0610 540F       323       anl a, #0FH
0612 93         324       movc a, @a+dptr
0613 F593       325       mov HEX2, a
0615 22         326       ret
0616            327   
0616            328   Display_BCD_7_Seg_HEX54:
0616 9005E4     329       mov dptr, #T_7seg
0619 E8         330       mov a, R0
061A C4         331       swap a
061B 540F       332       anl a, #0FH
061D 93         333       movc a, @a+dptr
061E F58F       334       mov HEX5, a
0620 E8         335       mov a, R0
0621 540F       336       anl a, #0FH
0623 93         337       movc a, @a+dptr
0624 F58E       338       mov HEX4, a
0626 22         339       ret
0627            340   
0627            341   ; The 8-bit hex number passed in the accumulator is converted to
0627            342   ; BCD and stored in [R1, R0]
0627            343   Hex_to_bcd_8bit:
0627 75F064     344       mov b, #100
062A 84         345       div ab
062B F9         346       mov R1, a   ; After dividing, a has the 100s
062C E5F0       347       mov a, b    ; Remainder is in register b
062E 75F00A     348       mov b, #10
0631 84         349       div ab ; The tens are stored in a, the units are stored in b 
0632 C4         350       swap a
0633 54F0       351       anl a, #0xf0
0635 45F0       352       orl a, b
0637 F8         353       mov R0, a
0638 22         354       ret
0639            355   
0639            356   ;-------------------------------------------------------------------------------
0639            357   ; Display Function for LCD                      
0639            358   ;-------------------------------------------------------------------------------
0639            359   LCD_Display_Update_func:
0639 C0E0       360       push acc
063B            361       
063B            362       ; --- FIX: JUMP DISTANCE ERROR ---
063B            363       ; "LCD_Display_Update_Done" is too far away for a JNB instruction.
063B            364       ; We use a local label right here to exit quickly.
063B 300C0A     365       jnb state_change_signal, LCD_Local_Exit
063E            366       ; --------------------------------
063E            367   
063E C20C       368       clr state_change_signal
0640 E568       369       mov a, Control_FSM_state
0642            370   
0642            371       ; --- IMPORTANT ADD ----
0642            372       ; If we are in State 1 (Setup), DO NOT RUN THIS, let the keypad logic handle the screen
0642 B40106     373       cjne a, #1, LCD_Display_Update_0
0645 D0E0       374       pop acc
0647 22         375       ret 
0648            376   
0648            377   ; --- NEW LOCAL EXIT LABEL ---
0648            378   LCD_Local_Exit:
0648 D0E0       379       pop acc
064A 22         380       ret
064B            381   ; ----------------------------
064B            382   
064B            383   LCD_Display_Update_0:
064B B4003B     384       cjne a, #0, LCD_Display_Update_1
064E C0E0       385            push acc
0650 7401       385            mov a, #1
0652 14         385            dec a
0653 1205C9     385            lcall ?Set_Cursor_1 ; Select column and row
0656 D0E0       385            pop acc
0658 C083       386            push dph
065A C082       386            push dpl
065C C0E0       386            push acc
065E 900330     386            mov dptr, #String_state0_1
0661 1205BC     386            lcall ?Send_Constant_String
0664 D0E0       386            pop acc
0666 D082       386            pop dpl
0668 D083       386            pop dph
066A C0E0       387            push acc
066C 7401       387            mov a, #1
066E 14         387            dec a
066F 1205C7     387            lcall ?Set_Cursor_2 ; Select column and row
0672 D0E0       387            pop acc
0674 C083       388            push dph
0676 C082       388            push dpl
0678 C0E0       388            push acc
067A 900340     388            mov dptr, #String_state0_2
067D 1205BC     388            lcall ?Send_Constant_String
0680 D0E0       388            pop acc
0682 D082       388            pop dpl
0684 D083       388            pop dph
0686 020777     389       ljmp LCD_Display_Update_done
0689            390   
0689            391   LCD_Display_Update_1:
0689 B4011F     392       cjne a, #1, LCD_Display_Update_2
068C C0E0       393            push acc
068E 7401       393            mov a, #1
0690 14         393            dec a
0691 1205C9     393            lcall ?Set_Cursor_1 ; Select column and row
0694 D0E0       393            pop acc
0696 C083       394            push dph
0698 C082       394            push dpl
069A C0E0       394            push acc
069C 9003A5     394            mov dptr, #String_state1
069F 1205BC     394            lcall ?Send_Constant_String
06A2 D0E0       394            pop acc
06A4 D082       394            pop dpl
06A6 D083       394            pop dph
06A8 020777     395       ljmp LCD_Display_Update_done
06AB            396   
06AB            397   LCD_Display_Update_2:
06AB B4021F     398       cjne a, #2, LCD_Display_Update_3
06AE C0E0       399            push acc
06B0 7401       399            mov a, #1
06B2 14         399            dec a
06B3 1205C9     399            lcall ?Set_Cursor_1 ; Select column and row
06B6 D0E0       399            pop acc
06B8 C083       400            push dph
06BA C082       400            push dpl
06BC C0E0       400            push acc
06BE 9003E5     400            mov dptr, #String_state2
06C1 1205BC     400            lcall ?Send_Constant_String
06C4 D0E0       400            pop acc
06C6 D082       400            pop dpl
06C8 D083       400            pop dph
06CA 020777     401       ljmp LCD_Display_Update_done
06CD            402   
06CD            403   LCD_Display_Update_3:
06CD B4031F     404       cjne a, #3, LCD_Display_Update_4
06D0 C0E0       405            push acc
06D2 7401       405            mov a, #1
06D4 14         405            dec a
06D5 1205C9     405            lcall ?Set_Cursor_1 ; Select column and row
06D8 D0E0       405            pop acc
06DA C083       406            push dph
06DC C082       406            push dpl
06DE C0E0       406            push acc
06E0 9003F5     406            mov dptr, #String_state3
06E3 1205BC     406            lcall ?Send_Constant_String
06E6 D0E0       406            pop acc
06E8 D082       406            pop dpl
06EA D083       406            pop dph
06EC 020777     407       ljmp LCD_Display_Update_done
06EF            408   
06EF            409   LCD_Display_Update_4:
06EF B4041F     410       cjne a, #4, LCD_Display_Update_5
06F2 C0E0       411            push acc
06F4 7401       411            mov a, #1
06F6 14         411            dec a
06F7 1205C9     411            lcall ?Set_Cursor_1 ; Select column and row
06FA D0E0       411            pop acc
06FC C083       412            push dph
06FE C082       412            push dpl
0700 C0E0       412            push acc
0702 900405     412            mov dptr, #String_state4
0705 1205BC     412            lcall ?Send_Constant_String
0708 D0E0       412            pop acc
070A D082       412            pop dpl
070C D083       412            pop dph
070E 020777     413       ljmp LCD_Display_Update_done
0711            414   
0711            415   LCD_Display_Update_5:
0711 B4051F     416       cjne a, #5, LCD_Display_Update_6
0714 C0E0       417            push acc
0716 7401       417            mov a, #1
0718 14         417            dec a
0719 1205C9     417            lcall ?Set_Cursor_1 ; Select column and row
071C D0E0       417            pop acc
071E C083       418            push dph
0720 C082       418            push dpl
0722 C0E0       418            push acc
0724 900415     418            mov dptr, #String_state5
0727 1205BC     418            lcall ?Send_Constant_String
072A D0E0       418            pop acc
072C D082       418            pop dpl
072E D083       418            pop dph
0730 020777     419       ljmp LCD_Display_Update_done
0733            420   
0733            421   LCD_Display_Update_6:
0733 B4061F     422       cjne a, #6, LCD_Display_Update_7
0736 C0E0       423            push acc
0738 7401       423            mov a, #1
073A 14         423            dec a
073B 1205C9     423            lcall ?Set_Cursor_1 ; Select column and row
073E D0E0       423            pop acc
0740 C083       424            push dph
0742 C082       424            push dpl
0744 C0E0       424            push acc
0746 900425     424            mov dptr, #String_state6
0749 1205BC     424            lcall ?Send_Constant_String
074C D0E0       424            pop acc
074E D082       424            pop dpl
0750 D083       424            pop dph
0752 020777     425       ljmp LCD_Display_Update_done
0755            426   
0755            427   LCD_Display_Update_7:
0755 B4071F     428       cjne a, #7, LCD_Display_Update_done
0758 C0E0       429            push acc
075A 7401       429            mov a, #1
075C 14         429            dec a
075D 1205C9     429            lcall ?Set_Cursor_1 ; Select column and row
0760 D0E0       429            pop acc
0762 C083       430            push dph
0764 C082       430            push dpl
0766 C0E0       430            push acc
0768 900435     430            mov dptr, #String_state7
076B 1205BC     430            lcall ?Send_Constant_String
076E D0E0       430            pop acc
0770 D082       430            pop dpl
0772 D083       430            pop dph
0774 020777     431       ljmp LCD_Display_Update_done
0777            432   
0777            433   LCD_Display_Update_done:
0777 D0E0       434       pop acc
0779 22         435       ret
077A            436   
077A            437   LCD_Display_Update_Temp:
077A            438       
077A            439   ;---------------------------------------------------------
077A            440   
077A            441   KEY1_DEB:
077A            442   ;non-blocking state machine for KEY1 debounce
077A E566       443       mov a, KEY1_DEB_state
077C            444   KEY1_DEB_state0:
077C B4000A     445       cjne a, #0, KEY1_DEB_state1
077F 20F92D     446       jb KEY.1, KEY1_DEB_done
0782 756400     447       mov KEY1_DEB_timer, #0
0785 0566       448       inc KEY1_DEB_state
0787 8026       449       sjmp KEY1_DEB_done
0789            450   KEY1_DEB_state1:
0789 B40109     451       cjne a, #1, KEY1_DEB_state2
078C            452       ; this is the debounce state
078C E564       453       mov a, KEY1_DEB_timer
078E B4321E     454       cjne a, #50, KEY1_DEB_done ; 50 ms passed?
0791 0566       455       inc KEY1_DEB_state
0793 801A       456       sjmp KEY1_DEB_done  
0795            457   KEY1_DEB_state2:
0795 B4020C     458       cjne a, #2, KEY1_DEB_state3
0798 20F904     459       jb KEY.1, KEY1_DEB_state2b
079B 0566       460       inc KEY1_DEB_state
079D 8010       461       sjmp KEY1_DEB_done  
079F            462   KEY1_DEB_state2b:
079F 756600     463       mov KEY1_DEB_state, #0
07A2 800B       464       sjmp KEY1_DEB_done
07A4            465   KEY1_DEB_state3:
07A4 B40308     466       cjne a, #3, KEY1_DEB_done
07A7 30F905     467       jnb KEY.1, KEY1_DEB_done
07AA D20D       468       setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
07AC 756600     469       mov KEY1_DEB_state, #0  
07AF            470   KEY1_DEB_done:
07AF 22         471       ret
07B0            472   
07B0            473   ; ------------------------------------------------------------------------------
07B0            474   ; Non-blocking FSM for the one second counter
07B0            475   ;-------------------------------------------------------------------------------
07B0            476   SEC_FSM:
07B0 E567       477       mov a, SEC_FSM_state
07B2            478   SEC_FSM_state0:
07B2 B4000C     479       cjne a, #0, SEC_FSM_state1
07B5 E565       480       mov a, SEC_FSM_timer
07B7 B4FA47     481       cjne a, #250, SEC_FSM_done ; 250 ms passed?
07BA 756500     482       mov SEC_FSM_timer, #0
07BD 0567       483       inc SEC_FSM_state
07BF 8040       484       sjmp SEC_FSM_done
07C1            485   SEC_FSM_state1: 
07C1 B4010E     486       cjne a, #1, SEC_FSM_state2
07C4 D2E9       487       setb LEDRA.1
07C6 E565       488       mov a, SEC_FSM_timer
07C8 B4FA36     489       cjne a, #250, SEC_FSM_done ; 250 ms passed?
07CB 756500     490       mov SEC_FSM_timer, #0
07CE 0567       491       inc SEC_FSM_state
07D0 802F       492       sjmp SEC_FSM_done
07D2            493   SEC_FSM_state2: 
07D2 B4020E     494       cjne a, #2, SEC_FSM_state3
07D5 D2EA       495       setb LEDRA.2
07D7 E565       496       mov a, SEC_FSM_timer
07D9 B4FA25     497       cjne a, #250, SEC_FSM_done ; 250 ms passed?
07DC 756500     498       mov SEC_FSM_timer, #0
07DF 0567       499       inc SEC_FSM_state
07E1 801E       500       sjmp SEC_FSM_done
07E3            501   SEC_FSM_state3: 
07E3 B4031B     502       cjne a, #3, SEC_FSM_done
07E6 D2EB       503       setb LEDRA.3
07E8 E565       504       mov a, SEC_FSM_timer
07EA B4FA14     505       cjne a, #250, SEC_FSM_done ; 250 ms passed?
07ED 756500     506       mov SEC_FSM_timer, #0
07F0 756700     507       mov SEC_FSM_state, #0
07F3 E530       508       mov a, current_time_sec
07F5 B43B05     509       cjne a, #59, IncCurrentTimeSec ; Don't let the seconds counter pass 59
07F8 753000     510       mov current_time_sec, #0
07FB 8004       511       sjmp SEC_FSM_done
07FD            512   IncCurrentTimeSec:
07FD 0530       513       inc current_time_sec
07FF B2E8       514       cpl LEDRA.0 ; 1 Hz heartbeat LED
0801            515   SEC_FSM_done:
0801 22         516       ret
0802            517   
0802            518   ;-------------------------------------------------------------------------------
0802            519   ; PWM
0802            520   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0802            521   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0802            522   ; ------------------------------------------------------------------------------
0802            523   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0802 100202     524       jbc one_ms_pwm_flag, pwm_wave_generator
0805 8071       525       sjmp end_pwm_generator
0807            526   
0807            527   pwm_wave_generator:
0807 C200       528       clr mf
0809            529       ; move pwm counter value into x for comparison purpose
0809 856032     530       mov x, pwm_counter
080C 856133     531       mov x+1, pwm_counter+1
080F 856234     532       mov x+2, pwm_counter+2
0812 856335     533       mov x+3, pwm_counter+3
0815            534   
0815 7536DB     535            mov y+0, #low (PWM_PERIOD % 0x10000) 
0818 753705     535            mov y+1, #high(PWM_PERIOD % 0x10000) 
081B 753800     535            mov y+2, #low (PWM_PERIOD / 0x10000) 
081E 753900     535            mov y+3, #high(PWM_PERIOD / 0x10000) 
0821            536   
0821            537       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0821            538       ; increase x by 1
0821 120152     539       lcall x_eq_y 
0824 20001D     540       jb mf, wrap_pwm_counter
0827            541       ; x not equal 1499, increment by 1
0827 753601     542            mov y+0, #low (1 % 0x10000) 
082A 753700     542            mov y+1, #high(1 % 0x10000) 
082D 753800     542            mov y+2, #low (1 / 0x10000) 
0830 753900     542            mov y+3, #high(1 / 0x10000) 
0833 1200D3     543       lcall add32
0836            544       ; update pwm_counter
0836 853260     545       mov pwm_counter, x
0839 853361     546       mov pwm_counter+1, x+1
083C 853462     547       mov pwm_counter+2, x+2
083F 853563     548       mov pwm_counter+3, x+3
0842 8018       549       sjmp set_pwm
0844            550   
0844            551   wrap_pwm_counter:
0844            552       ; x equal 1499, wrap to 0
0844 753200     553            mov x+0, #low (0 % 0x10000) 
0847 753300     553            mov x+1, #high(0 % 0x10000) 
084A 753400     553            mov x+2, #low (0 / 0x10000) 
084D 753500     553            mov x+3, #high(0 / 0x10000) 
0850 853260     554       mov pwm_counter, x
0853 853361     555       mov pwm_counter+1, x+1
0856 853462     556       mov pwm_counter+2, x+2
0859 853563     557       mov pwm_counter+3, x+3
085C            558   
085C            559   set_pwm:
085C            560       ; compare with power_output, if pwm counter smaller than power_output, 
085C            561       ; set pwm pin high; else set pwm pin low load y with power output value
085C 855C36     562       mov y, power_output
085F 855D37     563       mov y+1, power_output+1
0862 855E38     564       mov y+2, power_output+2
0865 855F39     565       mov y+3, power_output+3
0868            566   
0868            567       ; compare x(pwm counter) with y(power output)
0868 12011A     568       lcall x_lt_y
086B 200006     569       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
086E            570       ;output set pwm pin low if pwm counter greater than power output
086E C293       571       clr PWM_OUT
0870 C2EC       572       clr LEDRA.4
0872 8004       573       sjmp end_pwm_generator
0874            574   
0874            575   set_pwm_high:
0874 D293       576       setb PWM_OUT
0876 D2EC       577       setb LEDRA.4
0878            578   
0878            579   end_pwm_generator:
0878 22         580       ret
0879            581   
0879            582   ;-------------------------------------------------------------------------------;
0879            583   ; Temp_Compare
0879            584   ; Checks if we have reached the user's target temperatures.
0879            585   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
0879            586   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0879            587   ;-------------------------------------------------------------------------------;
0879            588   Temp_Compare:
0879            589       ; Reset flags initially
0879 C203       590       clr soak_temp_reached
087B C204       591       clr reflow_temp_reached
087D            592   
087D C0E0       593       push acc
087F C0D0       594       push psw
0881 C000       595       push AR0
0883 C001       596       push AR1
0885 C002       597       push AR2
0887            598       
0887            599       ; --- 1. CHECK SOAK TEMP ---
0887            600       ; Copy current_temp to X
0887 783F       601       mov R0, #current_temp
0889 7932       602       mov R1, #x
088B 1208FF     603       lcall Copy4_Bytes_R0_to_R1
088E            604   
088E            605       ; Copy soak_temp to Y
088E 7843       606       mov R0, #soak_temp
0890 7936       607       mov R1, #y
0892 1208FF     608       lcall Copy4_Bytes_R0_to_R1
0895            609   
0895            610       ; Compare: Is X (Current) < Y (Target)?
0895 12011A     611       lcall x_lt_y
0898 200002     612       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
089B            613       
089B            614       ; If we are here, Current >= Target
089B D203       615       setb soak_temp_reached
089D            616   
089D            617   Check_Reflow_Threshold:
089D            618       ; --- 2. CHECK REFLOW TEMP ---
089D            619       ; Copy current_temp to X (Need to reload X because math32 destroys it)
089D 783F       620       mov R0, #current_temp
089F 7932       621       mov R1, #x
08A1 1208FF     622       lcall Copy4_Bytes_R0_to_R1
08A4            623   
08A4            624       ; Copy reflow_temp to Y
08A4 7847       625       mov R0, #reflow_temp
08A6 7936       626       mov R1, #y
08A8 1208FF     627       lcall Copy4_Bytes_R0_to_R1
08AB            628   
08AB            629       ; Compare
08AB 12011A     630       lcall x_lt_y
08AE 200002     631       jb mf, Temp_Compare_Done
08B1            632       
08B1            633       ; If Current >= Target
08B1 D204       634       setb reflow_temp_reached
08B3            635   
08B3            636   Temp_Compare_Done:
08B3 D002       637       pop AR2
08B5 D001       638       pop AR1
08B7 D000       639       pop AR0
08B9 D0D0       640       pop psw
08BB D0E0       641       pop acc
08BD 22         642       ret
08BE            643   ;-------------------------------------------------------------------------------;
08BE            644   ; Time_Compare
08BE            645   ;
08BE            646   ; PURPOSE:
08BE            647   ;   Compare the elapsed time against soak and reflow
08BE            648   ;   time limits.
08BE            649   ;
08BE            650   ; BEHAVIOR:
08BE            651   ;   - If current_time >= soak_time   if soak_time_reached    = 1
08BE            652   ;   - If current_time >= reflow_time if reflow_time_reached = 1
08BE            653   ;
08BE            654   ; NOTES:
08BE            655   ;   - Time values are treated as 32-bit UNSIGNED numbers
08BE            656   ;     (e.g., milliseconds or seconds).
08BE            657   ;   - Uses the SAME compare logic as Temp_Compare.
08BE            658   ;   - This routine ONLY SETS flags.
08BE            659   ;
08BE            660   ; EXPECTED VARIABLES:
08BE            661   ;   current_time[4], soak_time[4], reflow_time[4]
08BE            662   ;   x[4], y[4]
08BE            663   ;   mf, soak_time_reached, reflow_time_reached
08BE            664   ;-------------------------------------------------------------------------------;
08BE            665   Time_Compare:
08BE C0E0       666       push acc
08C0 C0D0       667       push psw
08C2 C000       668       push AR0
08C4 C001       669       push AR1
08C6 C002       670       push AR2
08C8            671   
08C8            672   ; Check: current_time >= soak_time ?
08C8            673       ; Copy current_time of x
08C8 7850       674       mov  R0, #current_time
08CA 7932       675       mov  R1, #x
08CC 1208FF     676       lcall Copy4_Bytes_R0_to_R1
08CF            677   
08CF            678       ; Copy soak_time of y
08CF 7854       679       mov  R0, #soak_time
08D1 7936       680       mov  R1, #y
08D3 1208FF     681       lcall Copy4_Bytes_R0_to_R1
08D6            682   
08D6            683       ; Compare elapsed time vs soak time
08D6 12011A     684       lcall x_lt_y
08D9 200002     685       jb   mf, Time_Soak_NotReached
08DC D206       686       setb soak_time_reached
08DE            687   
08DE            688   ; Check: current_time >= reflow_time ?
08DE            689   Time_Soak_NotReached:
08DE            690       ; Copy current_time of x
08DE 7850       691       mov  R0, #current_time
08E0 7932       692       mov  R1, #x
08E2 1208FF     693       lcall Copy4_Bytes_R0_to_R1
08E5            694   
08E5            695       ; Copy reflow_time of y
08E5 7858       696       mov  R0, #reflow_time
08E7 7936       697       mov  R1, #y
08E9 1208FF     698       lcall Copy4_Bytes_R0_to_R1
08EC            699   
08EC            700       ; Compare elapsed time vs reflow time
08EC 12011A     701       lcall x_lt_y
08EF 200002     702       jb   mf, Time_Reflow_NotReached
08F2 D207       703       setb reflow_time_reached
08F4            704   
08F4            705   Time_Reflow_NotReached:
08F4 D002       706       pop  AR2
08F6 D001       707       pop  AR1
08F8 D000       708       pop  AR0
08FA D0D0       709       pop  psw
08FC D0E0       710       pop  acc
08FE 22         711       ret
08FF            712   
08FF            713   ;-------------------------------------------------------------------------------;
08FF            714   ; Copy4_Bytes_R0_to_R1
08FF            715   ;
08FF            716   ; PURPOSE:
08FF            717   ;   Utility routine to copy a 32-bit value (4 bytes)
08FF            718   ;   from one memory location to another.
08FF            719   ;
08FF            720   ; INPUTS:
08FF            721   ;   R0 st source address
08FF            722   ;   R1 at destination address
08FF            723   ;
08FF            724   ; USES:
08FF            725   ;   R2 as loop counter
08FF            726   ;
08FF            727   ; EXAMPLE:
08FF            728   ;   mov R0, #current_temp
08FF            729   ;   mov R1, #x
08FF            730   ;   lcall Copy4_Bytes_R0_to_R1
08FF            731   ;-------------------------------------------------------------------------------;
08FF            732   Copy4_Bytes_R0_to_R1:
08FF 7A04       733       mov  R2, #4
0901            734   Copy4_Loop:
0901 E6         735       mov  a, @R0
0902 F7         736       mov  @R1, a
0903 08         737       inc  R0
0904 09         738       inc  R1
0905 DAFA       739       djnz R2, Copy4_Loop
0907 22         740       ret
0908            741   
0908            742   ;-------------------------------------------------------------------------------;
0908            743   ; Abort condition safety check Temperature time
0908            744   ;
0908            745   ; PURPOSE:
0908            746   ;   Automatic cycle termination on error:
0908            747   ;   Abort if oven fails to reach at least 50C in first 60s.
0908            748   ;
0908            749   ; TRIP CONDITION:
0908            750   ;   if (current_time >= 60s) AND (current_temp < 50C)
0908            751   ;       -> set tc_missing_abort
0908            752   ;       -> set stop_signal
0908            753   ;
0908            754   ; ASSUMPTIONS:
0908            755   ;   - current_time is in SECONDS (32-bit, little-endian)
0908            756   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0908            757   ;
0908            758   ;   the Load_Y constants accordingly.
0908            759   ;-------------------------------------------------------------------------------;
0908            760   Safety_Check_TC:
0908 C0E0       761       push acc
090A C0D0       762       push psw
090C C000       763       push AR0
090E C001       764       push AR1
0910 C002       765       push AR2
0912            766   
0912            767       ; If already aborted or startup window closed, do nothing
0912 200E3D     768       jb   tc_missing_abort, Safety_TC_Done
0915 300F3A     769       jnb  tc_startup_window, Safety_TC_Done
0918            770   
0918            771       ; Check: current_time >= 60 ?
0918 7850       772       mov  R0, #current_time
091A 7932       773       mov  R1, #x
091C 1208FF     774       lcall Copy4_Bytes_R0_to_R1
091F            775   
091F 75363C     776            mov y+0, #low (60 % 0x10000) 
0922 753700     776            mov y+1, #high(60 % 0x10000) 
0925 753800     776            mov y+2, #low (60 / 0x10000) 
0928 753900     776            mov y+3, #high(60 / 0x10000) 
092B 12011A     777       lcall x_lt_y
092E 200021     778       jb   mf, Safety_TC_Done        ; still < 60s  keep waiting
0931            779   
0931            780       ; We reached 60s: close the startup window so it won't re-check later
0931 C20F       781       clr  tc_startup_window
0933            782   
0933            783       ; Now check: current_temp < 50 ?
0933 783F       784       mov  R0, #current_temp
0935 7932       785       mov  R1, #x
0937 1208FF     786       lcall Copy4_Bytes_R0_to_R1
093A            787   
093A 753632     788            mov y+0, #low (50 % 0x10000) 
093D 753700     788            mov y+1, #high(50 % 0x10000) 
0940 753800     788            mov y+2, #low (50 / 0x10000) 
0943 753900     788            mov y+3, #high(50 / 0x10000) 
0946 12011A     789       lcall x_lt_y
0949 300006     790       jnb  mf, Safety_TC_Done        ; temp >= 50  pass
094C            791   
094C            792       ; FAIL: at 60s, still below 50C  abort
094C D20E       793       setb tc_missing_abort
094E D209       794       setb stop_signal
0950 C293       795       clr  PWM_OUT
0952            796   
0952            797   Safety_TC_Done:
0952 D002       798       pop  AR2
0954 D001       799       pop  AR1
0956 D000       800       pop  AR0
0958 D0D0       801       pop  psw
095A D0E0       802       pop  acc
095C 22         803       ret
095D            804   
095D            805   ;-------------------------------------------------------------------------------;
095D            806   ; Main Control FSM for the entire process
095D            807   ;-------------------------------------------------------------------------------;
095D            808   ;-------------------------------------------------------------------------------;
095D            809   ; FSM LOGIC (Button Logic Fixed)
095D            810   ;-------------------------------------------------------------------------------;
095D            811   Control_FSM:
095D E568       812       mov a, Control_FSM_state
095F 8005       813       sjmp Control_FSM_state0
0961            814   
0961            815   Control_FSM_state0_a:
0961 756800     816       mov Control_FSM_state, #0
0964 D20C       817       setb state_change_signal
0966            818       
0966            819   Control_FSM_state0:
0966 B40015     820       cjne a, #0, Control_FSM_state1
0969 209005     821       jb P1.0, Control_FSM_done_bridge ; If Button High (Not Pressed), Exit
096C 120E2F     822       lcall Wait_For_P1_0_Release      ; If Low (Pressed), Wait & Proceed
096F 8001       823       sjmp Control_FSM_state1_a  
0971            824       
0971            825   Control_FSM_done_bridge:
0971 22         826       ret
0972            827   
0972            828   Control_FSM_state1_a:
0972 0568       829       inc Control_FSM_state
0974 756900     830       mov Current_State, #0
0977 120D0D     831       lcall Update_Screen_Full 
097A D20C       832       setb state_change_signal
097C E568       833       mov a, Control_FSM_state
097E            834       
097E            835   Control_FSM_state1:
097E B40116     836       cjne a, #1, Control_FSM_state2
0981 120B45     837       lcall Check_Buttons 
0984 120B91     838       lcall Check_Keypad
0987            839       
0987            840       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0987 209008     841       jb P1.0, Control_FSM_state1_ret
098A            842       
098A            843       ; If we get here, Button is LOW (Pressed)
098A 120E2F     844       lcall Wait_For_P1_0_Release
098D 120AC9     845       lcall Update_FSM_Variables
0990 8001       846       sjmp Control_FSM_state2_a
0992            847   Control_FSM_state1_ret:
0992 22         848       ret
0993            849   
0993            850   ; --- STATE 2: RAMP TO SOAK ---
0993            851   Control_FSM_state2_a:
0993 0568       852       inc Control_FSM_state
0995 D20C       853       setb state_change_signal
0997            854   Control_FSM_state2:
0997 B40215     855       cjne a, #2, Control_FSM_state3
099A 301205     856       jnb PB2_flag, State2_Check
099D C212       857       clr PB2_flag
099F 0209F5     858       ljmp Control_FSM_state6_a ; Pause
09A2            859   State2_Check:
09A2 300309     860       jnb soak_temp_reached, State2_Ret
09A5 C203       861       clr soak_temp_reached
09A7 0568       862       inc Control_FSM_state
09A9 D20C       863       setb state_change_signal
09AB 753000     864       mov current_time_sec, #0
09AE            865   State2_Ret:
09AE 22         866       ret
09AF            867   
09AF            868   ; --- STATE 3: SOAK PHASE ---
09AF            869   Control_FSM_state3:
09AF B40312     870       cjne a, #3, Control_FSM_state4
09B2 301205     871       jnb PB2_flag, State3_Check
09B5 C212       872       clr PB2_flag
09B7 0209F5     873       ljmp Control_FSM_state6_a
09BA            874   State3_Check:
09BA 300606     875       jnb soak_time_reached, State3_Ret
09BD C206       876       clr soak_time_reached
09BF 0568       877       inc Control_FSM_state      
09C1 D20C       878       setb state_change_signal 
09C3            879   State3_Ret:
09C3 22         880       ret
09C4            881   
09C4            882   ; --- STATE 4: RAMP TO PEAK ---
09C4            883   Control_FSM_state4:
09C4 B40415     884       cjne a, #4, Control_FSM_state5
09C7 301205     885       jnb PB2_flag, State4_Check
09CA C212       886       clr PB2_flag
09CC 0209F5     887       ljmp Control_FSM_state6_a
09CF            888   State4_Check:
09CF 300409     889       jnb reflow_temp_reached, State4_Ret
09D2 C204       890       clr reflow_temp_reached
09D4 0568       891       inc Control_FSM_state
09D6 D20C       892       setb state_change_signal
09D8 753000     893       mov current_time_sec, #0
09DB            894   State4_Ret:
09DB 22         895       ret
09DC            896   
09DC            897   ; --- STATE 5: REFLOW PHASE ---
09DC            898   Control_FSM_state5:
09DC B40502     899       cjne a, #5, Control_FSM_state6_trampoline
09DF 8003       900       sjmp State5_Logic
09E1            901   Control_FSM_state6_trampoline:
09E1 0209F9     902       ljmp Control_FSM_state6
09E4            903   
09E4            904   State5_Logic:
09E4 301205     905       jnb PB2_flag, State5_Check
09E7 C212       906       clr PB2_flag
09E9 0209F5     907       ljmp Control_FSM_state6_a
09EC            908   State5_Check:
09EC 300705     909       jnb reflow_time_reached, State5_Ret
09EF C207       910       clr reflow_time_reached
09F1 0209F5     911       ljmp Control_FSM_state6_a
09F4            912   State5_Ret:
09F4 22         913       ret
09F5            914   
09F5            915   ; --- STATE 6: COOLING ---
09F5            916   Control_FSM_state6_a:
09F5 0568       917       inc Control_FSM_state
09F7 D20C       918       setb state_change_signal
09F9            919   Control_FSM_state6:
09F9 B4060A     920       cjne a, #6, Control_FSM_state7
09FC            921       ; Wait for Cooling Temp Reached
09FC 300506     922       jnb cooling_temp_reached, State6_Ret
09FF C205       923       clr cooling_temp_reached
0A01 0568       924       inc Control_FSM_state
0A03 D20C       925       setb state_change_signal
0A05            926   State6_Ret:
0A05 22         927       ret
0A06            928   
0A06            929   ; --- STATE 7: DONE ---
0A06            930   Control_FSM_state7:
0A06 B40711     931       cjne a, #7, Control_FSM_done
0A09            932       
0A09            933       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0A09 201009     934       jb PB0_flag, Control_FSM_Reset_Logic ; Wait, PB0_flag is software flag?
0A0C            935       
0A0C            936       ; Let's assume you meant the physical button P1.0 like State 0
0A0C 20900B     937       jb P1.0, Control_FSM_done
0A0F            938       
0A0F 120E2F     939       lcall Wait_For_P1_0_Release
0A12 020961     940       ljmp Control_FSM_state0_a
0A15            941   
0A15            942   Control_FSM_Reset_Logic:
0A15            943       ; If using PB0_flag from ISR, handle here
0A15 C210       944       clr PB0_flag
0A17 020961     945       ljmp Control_FSM_state0_a
0A1A            946   
0A1A            947   Control_FSM_done:
0A1A 22         948       ret
0A1B            949   ;-------------------------------------------------------------------------------;
0A1B            950   ;         Main program.          
0A1B            951   ;-------------------------------------------------------------------------------;
0A1B            952   main:
0A1B            953   
0A1B            954       ; --------------------------------------------------------
0A1B            955       ; 1. SAFETY SHUTDOWN
0A1B            956       ; --------------------------------------------------------
0A1B C2AF       957       clr EA              ; FORCE Interrupts OFF immediately
0A1D 7581C0     958       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0A20            959       
0A20            960       ; --------------------------------------------------------
0A20            961       ; 2. THE "DIRTY DELAY" (Fixes Reset Garbage)
0A20            962       ; We burn ~100ms here using a raw loop. 
0A20            963       ; We cannot use timers yet because they aren't initialized.
0A20            964       ; --------------------------------------------------------
0A20 78FA       965       mov R0, #250
0A22            966   Reset_Delay_Outer:
0A22 79FF       967       mov R1, #255
0A24            968   Reset_Delay_Inner:
0A24 D9FE       969       djnz R1, Reset_Delay_Inner
0A26 D8FA       970       djnz R0, Reset_Delay_Outer
0A28            971       ; --------------------------------------------------------
0A28            972   
0A28            973       ; ... NOW continue with your normal Port Configuration ...
0A28            974       
0A28            975       ; --- PORT CONFIGURATION ---
0A28 759AAA     976       mov P0MOD, #0xAA
0A2B            977   
0A2B            978       ; P1: Mixed usage 
0A2B            979       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0A2B            980       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0A2B            981       ; P1.0 (Unused/RX) -> Input
0A2B            982       ; Binary: 11111110 -> Hex: 0xFE
0A2B 759BFE     983       mov P1MOD, #0xFE
0A2E            984   
0A2E            985       ; P2: Row4(Out), Cols(In)
0A2E            986       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0A2E            987       ; Binary: 00000001 -> Hex: 0x01
0A2E 759C01     988       mov P2MOD, #0x01
0A31            989   
0A31            990       ; P3: Col4(In)
0A31            991       ; P3.0 (Col4) is In (0).
0A31 759D00     992       mov P3MOD, #0x00
0A34            993       ; Turn off all the LEDs
0A34 75E800     994       mov LEDRA, #0 ; LEDRA is bit addressable
0A37 759500     995       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0A3A            996   
0A3A            997       ; Enable Global interrupts
0A3A D2AF       998       setb EA  
0A3C            999   
0A3C           1000       ; FSM initial states
0A3C 756600    1001       mov KEY1_DEB_state, #0
0A3F 756700    1002       mov SEC_FSM_state, #0
0A42 756800    1003       mov Control_FSM_state, #0
0A45 756900    1004       mov Current_State, #0
0A48           1005       
0A48           1006       ; FSM timers initialization
0A48 756400    1007       mov KEY1_DEB_timer, #0
0A4B 756500    1008       mov SEC_FSM_timer, #0
0A4E           1009       ; time counters initialization
0A4E 753000    1010       mov current_time_sec, #0
0A51 753100    1011       mov current_time_minute, #0
0A54           1012       ; Initialize counter to zero
0A54 756000    1013       mov pwm_counter, #0
0A57 756100    1014       mov pwm_counter+1, #0
0A5A 756200    1015       mov pwm_counter+2, #0
0A5D 756300    1016       mov pwm_counter+3, #0
0A60           1017       ; Initialize power output
0A60 755F00    1018       mov power_output+3, #0
0A63 755E00    1019       mov power_output+2, #0
0A66 755D02    1020       mov power_output+1, #02H
0A69 755CEE    1021       mov power_output, #0EEH ; (initilize to 750 for testing)
0A6C           1022   
0A6C           1023       ; Clear all the flags
0A6C C20E      1024       clr  tc_missing_abort
0A6E C209      1025       clr  stop_signal
0A70 C210      1026       clr PB0_flag
0A72 C211      1027       clr PB1_flag
0A74 C212      1028       clr PB2_flag
0A76 C201      1029       clr one_second_flag
0A78 C20B      1030       clr config_finish_signal
0A7A C203      1031       clr soak_temp_reached
0A7C C206      1032       clr soak_time_reached
0A7E C204      1033       clr reflow_temp_reached
0A80 C207      1034       clr reflow_time_reached
0A82 C205      1035       clr cooling_temp_reached
0A84 C20C      1036       clr state_change_signal
0A86           1037       
0A86 D20C      1038       setb state_change_signal
0A88           1039   
0A88           1040       ; Set bit
0A88 D20F      1041       setb tc_startup_window
0A8A           1042   
0A8A 120456    1043       lcall Timer0_Init
0A8D 1204C0    1044       lcall Timer2_Init
0A90 120589    1045       lcall ELCD_4BIT
0A93           1046       ;----- Two new lines I added to initialize the UI
0A93 120CBA    1047       lcall Init_All_Buffers
0A96 120D0D    1048       lcall Update_Screen_Full
0A99           1049       ;-----
0A99 120472    1050       lcall Initialize_Serial_Port
0A9C           1051   ;-------------------------------------------------------------------------------;
0A9C           1052   ; while(1) loop
0A9C           1053   ;-------------------------------------------------------------------------------;
0A9C           1054   loop:
0A9C           1055       ; Check the FSM for KEY1 debounce
0A9C 12077A    1056       lcall KEY1_DEB
0A9F           1057       
0A9F           1058       ; Added to take temp readings
0A9F 120E33    1059       lcall Read_Thermocouple
0AA2           1060       
0AA2           1061       ; 1. Check if we reached temp (Observer)
0AA2 120879    1062       lcall Temp_Compare
0AA5           1063       
0AA5           1064       ; 2. Decide heater power based on flags (Driver)
0AA5 120E84    1065       lcall Power_Control
0AA8           1066       
0AA8           1067       ; 3. Update 32-bit Time Variable for Comparison
0AA8 853050    1068       mov current_time+0, current_time_sec
0AAB 755100    1069       mov current_time+1, #0
0AAE 755200    1070       mov current_time+2, #0
0AB1 755300    1071       mov current_time+3, #0
0AB4           1072       
0AB4 1208BE    1073       lcall Time_Compare
0AB7           1074       
0AB7 120908    1075       lcall Safety_Check_TC
0ABA           1076   
0ABA           1077   
0ABA           1078       ; Check the FSM for one second counter
0ABA 1207B0    1079       lcall SEC_FSM
0ABD           1080   
0ABD           1081       ; Check the FSM for the overall control flow of the reflow process
0ABD 12095D    1082       lcall Control_FSM
0AC0           1083   
0AC0           1084       ; Update the LCD display based on the current state
0AC0 120639    1085       lcall LCD_Display_Update_func
0AC3           1086   
0AC3           1087       ; Update the pwm output for the ssr
0AC3 120802    1088       lcall PWM_Wave 
0AC6           1089   
0AC6           1090       ; After initialization the program stays in this 'forever' loop
0AC6 020A9C    1091       ljmp loop
0AC9           1092   ;-------------------------------------------------------------------------------;
0AC9           1093   
0AC9           1094   ; ================================================================
0AC9           1095   ; UI & HELPER SUBROUTINES
0AC9           1096   ; ================================================================
0AC9           1097   
0AC9           1098   ; ----------------------------------------------------------------
0AC9           1099   ; MODULE: BRIDGE (Text to Integer Conversion)
0AC9           1100   ; ----------------------------------------------------------------
0AC9           1101   Update_FSM_Variables:
0AC9           1102       ; --- 1. SOAK TEMP ---
0AC9 786B      1103       mov R0, #Buf_Soak_Temp
0ACB 120B08    1104       lcall Parse_Temp_String
0ACE 8F43      1105       mov soak_temp+0, R7
0AD0 754400    1106       mov soak_temp+1, #0
0AD3 754500    1107       mov soak_temp+2, #0
0AD6 754600    1108       mov soak_temp+3, #0
0AD9           1109   
0AD9           1110       ; --- 2. REFLOW TEMP ---
0AD9 7874      1111       mov R0, #Buf_Refl_Temp
0ADB 120B08    1112       lcall Parse_Temp_String
0ADE 8F47      1113       mov reflow_temp+0, R7
0AE0 754800    1114       mov reflow_temp+1, #0
0AE3 754900    1115       mov reflow_temp+2, #0
0AE6 754A00    1116       mov reflow_temp+3, #0
0AE9           1117   
0AE9           1118       ; --- 3. SOAK TIME ---
0AE9 786F      1119       mov R0, #Buf_Soak_Time
0AEB 120B1C    1120       lcall Parse_Time_String
0AEE 8F54      1121       mov soak_time+0, R7
0AF0 8E55      1122       mov soak_time+1, R6
0AF2 755600    1123       mov soak_time+2, #0
0AF5 755700    1124       mov soak_time+3, #0
0AF8           1125   
0AF8           1126       ; --- 4. REFLOW TIME ---
0AF8 7878      1127       mov R0, #Buf_Refl_Time
0AFA 120B1C    1128       lcall Parse_Time_String
0AFD 8F58      1129       mov reflow_time+0, R7
0AFF 8E59      1130       mov reflow_time+1, R6
0B01 755A00    1131       mov reflow_time+2, #0
0B04 755B00    1132       mov reflow_time+3, #0
0B07 22        1133       ret
0B08           1134   
0B08           1135   ; --- Helper: Parse "123" to Integer ---
0B08           1136   Parse_Temp_String:
0B08 7F00      1137       mov R7, #0              ; Clear Result
0B0A           1138   Parse_Temp_Loop:
0B0A E6        1139       mov A, @R0
0B0B 600E      1140       jz Parse_Temp_Done      ; If Null, we are done
0B0D           1141       
0B0D           1142       ; Convert ASCII to Digit
0B0D C3        1143       clr C
0B0E 9430      1144       subb A, #0x30
0B10 FD        1145       mov R5, A               ; R5 = New Digit
0B11           1146       
0B11           1147       ; Result = (Result * 10) + New Digit
0B11 EF        1148       mov A, R7
0B12 75F00A    1149       mov B, #10
0B15 A4        1150       mul AB
0B16 2D        1151       add A, R5
0B17 FF        1152       mov R7, A
0B18           1153       
0B18 08        1154       inc R0
0B19 80EF      1155       sjmp Parse_Temp_Loop
0B1B           1156   Parse_Temp_Done:
0B1B 22        1157       ret
0B1C           1158   
0B1C           1159   ; --- Helper: Parse "MMSS" to Seconds ---
0B1C           1160   Parse_Time_String:
0B1C           1161       ; 1. Minutes Tens
0B1C E6        1162       mov A, @R0
0B1D 9430      1163       subb A, #0x30
0B1F 75F00A    1164       mov B, #10
0B22 A4        1165       mul AB
0B23 FD        1166       mov R5, A
0B24 08        1167       inc R0
0B25           1168       
0B25           1169       ; 2. Minutes Ones
0B25 E6        1170       mov A, @R0
0B26 9430      1171       subb A, #0x30
0B28 2D        1172       add A, R5
0B29 FD        1173       mov R5, A               ; R5 = Total Minutes
0B2A 08        1174       inc R0
0B2B           1175       
0B2B           1176       ; 3. Seconds Tens
0B2B E6        1177       mov A, @R0
0B2C 9430      1178       subb A, #0x30
0B2E 75F00A    1179       mov B, #10
0B31 A4        1180       mul AB
0B32 FC        1181       mov R4, A
0B33 08        1182       inc R0
0B34           1183       
0B34           1184       ; 4. Seconds Ones
0B34 E6        1185       mov A, @R0
0B35 9430      1186       subb A, #0x30
0B37 2C        1187       add A, R4               ; R4 = Total Seconds
0B38           1188       
0B38           1189       ; 5. Calculate Total Seconds = (Mins * 60) + Secs
0B38 ED        1190       mov A, R5
0B39 75F03C    1191       mov B, #60
0B3C A4        1192       mul AB
0B3D 2C        1193       add A, R4
0B3E FF        1194       mov R7, A               ; Low Byte
0B3F E5F0      1195       mov A, B
0B41 3400      1196       addc A, #0
0B43 FE        1197       mov R6, A               ; High Byte
0B44 22        1198       ret
0B45           1199   
0B45           1200   ; ----------------------------------------------------------------
0B45           1201   ; MODULE: BUTTON HANDLER (Mode Selection)
0B45           1202   ; ----------------------------------------------------------------
0B45           1203   Check_Buttons:
0B45           1204       ; --- FORCE INPUT MODE ---
0B45           1205       ; This clears any '0' the LCD library might have written to our buttons
0B45 438055    1206       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0B48           1207       ; ------------------------
0B48           1208   
0B48 30800A    1209       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0B4B 308212    1210       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0B4E 30841A    1211       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0B51 308622    1212       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0B54 22        1213       ret
0B55           1214   
0B55           1215   Btn_Soak_Temp_Press:
0B55 120E04    1216       lcall Wait_25ms_BLOCKING
0B58 756901    1217       mov Current_State, #1
0B5B 756A00    1218       mov Cursor_Idx, #0
0B5E 8021      1219       sjmp Redraw_Screen
0B60           1220   
0B60           1221   Btn_Soak_Time_Press:
0B60 120E04    1222       lcall Wait_25ms_BLOCKING
0B63 756902    1223       mov Current_State, #2
0B66 756A00    1224       mov Cursor_Idx, #0
0B69 8016      1225       sjmp Redraw_Screen
0B6B           1226   
0B6B           1227   Btn_Refl_Temp_Press:
0B6B 120E04    1228       lcall Wait_25ms_BLOCKING
0B6E 756903    1229       mov Current_State, #3
0B71 756A00    1230       mov Cursor_Idx, #0
0B74 800B      1231       sjmp Redraw_Screen
0B76           1232   
0B76           1233   Btn_Refl_Time_Press:
0B76 120E04    1234       lcall Wait_25ms_BLOCKING 
0B79 756904    1235       mov Current_State, #4
0B7C 756A00    1236       mov Cursor_Idx, #0
0B7F 8000      1237       sjmp Redraw_Screen
0B81           1238   
0B81           1239   Redraw_Screen:
0B81 120D0D    1240       lcall Update_Screen_Full
0B84           1241       ; Wait for button release
0B84 3080FD    1242       jnb BTN_SOAK_TEMP, $
0B87 3082FD    1243       jnb BTN_SOAK_TIME, $
0B8A 3084FD    1244       jnb BTN_REFL_TEMP, $
0B8D 3086FD    1245       jnb BTN_REFL_TIME, $
0B90 22        1246       ret
0B91           1247   
0B91           1248   ; ----------------------------------------------------------------
0B91           1249   ; MODULE: KEYPAD HANDLER (Input Logic)
0B91           1250   ; ----------------------------------------------------------------
0B91           1251   Check_Keypad:
0B91           1252       ; If State is 0 (Home), ignore keypad
0B91 E569      1253       mov A, Current_State
0B93 6050      1254       jz Keypad_Exit
0B95           1255       
0B95 120BE6    1256       lcall Keypad_Scan
0B98 504B      1257       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0B9A           1258   
0B9A           1259       ; --- Check Special Keys ---
0B9A EF        1260       mov A, R7
0B9B B40E0A    1261       cjne A, #14, Check_Hash ; 14 is Star (*)
0B9E           1262       
0B9E           1263       ; Star Key Pressed: Reset Buffer
0B9E 120CEA    1264       lcall Reset_Current_Buffer
0BA1 120D0D    1265       lcall Update_Screen_Full
0BA4 756A00    1266       mov Cursor_Idx, #0
0BA7 22        1267       ret
0BA8           1268   
0BA8           1269   Check_Hash:
0BA8 EF        1270       mov A, R7
0BA9 B40C01    1271       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0BAC 22        1272       ret                     ; Ignore Hash key
0BAD           1273   
0BAD           1274   Check_Numeric:
0BAD           1275       ; Ensure key is 0-9
0BAD EF        1276       mov A, R7
0BAE C3        1277       clr C
0BAF 940A      1278       subb A, #10
0BB1 5031      1279       jnc Symbol_Key_Ignored
0BB3           1280       
0BB3           1281       ; Convert to ASCII
0BB3 EF        1282       mov A, R7
0BB4 2430      1283       add A, #0x30
0BB6 FD        1284       mov R5, A
0BB7           1285   
0BB7           1286       ; Save to Buffer
0BB7 120E18    1287       lcall Get_Current_Buffer_Addr
0BBA E56A      1288       mov A, Cursor_Idx
0BBC 28        1289       add A, R0
0BBD F8        1290       mov R0, A
0BBE ED        1291       mov A, R5
0BBF F6        1292       mov @R0, A
0BC0 056A      1293       inc Cursor_Idx
0BC2           1294   
0BC2           1295       ; --- Check Cursor Limits ---
0BC2 E569      1296       mov A, Current_State
0BC4 B40102    1297       cjne A, #1, Check_Limit_Time_1
0BC7 8005      1298       sjmp Limit_Temp_3
0BC9           1299   
0BC9           1300   Check_Limit_Time_1:
0BC9 B4030B    1301       cjne A, #3, Limit_Time_4
0BCC 8000      1302       sjmp Limit_Temp_3
0BCE           1303   
0BCE           1304   Limit_Temp_3:
0BCE E56A      1305       mov A, Cursor_Idx
0BD0 B4030D    1306       cjne A, #3, Do_Refresh
0BD3 156A      1307       dec Cursor_Idx          ; Stay at last digit
0BD5 8009      1308       sjmp Do_Refresh
0BD7           1309   
0BD7           1310   Limit_Time_4:
0BD7 E56A      1311       mov A, Cursor_Idx
0BD9 B40404    1312       cjne A, #4, Do_Refresh
0BDC 156A      1313       dec Cursor_Idx          ; Stay at last digit
0BDE 8000      1314       sjmp Do_Refresh
0BE0           1315   
0BE0           1316   Do_Refresh:
0BE0 120D0D    1317       lcall Update_Screen_Full
0BE3 22        1318       ret
0BE4           1319   
0BE4           1320   Symbol_Key_Ignored:
0BE4 22        1321       ret
0BE5           1322   Keypad_Exit:
0BE5 22        1323       ret
0BE6           1324   
0BE6           1325   ; ----------------------------------------------------------------
0BE6           1326   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0BE6           1327   ; ----------------------------------------------------------------
0BE6           1328   Keypad_Scan:
0BE6           1329       ; Step 1: Check if ANY key is pressed (All Rows Low)
0BE6 C292      1330       clr ROW1
0BE8 C294      1331       clr ROW2
0BEA C296      1332       clr ROW3
0BEC C2A0      1333       clr ROW4
0BEE A2A2      1334       mov C, COL1
0BF0 82A4      1335       anl C, COL2
0BF2 82A6      1336       anl C, COL3
0BF4 82B0      1337       anl C, COL4
0BF6 5002      1338       jnc Keypad_Debounce
0BF8 C3        1339       clr C
0BF9 22        1340       ret
0BFA           1341   
0BFA           1342   Keypad_Debounce:
0BFA 120E04    1343       lcall Wait_25ms_BLOCKING
0BFD A2A2      1344       mov C, COL1
0BFF 82A4      1345       anl C, COL2
0C01 82A6      1346       anl C, COL3
0C03 82B0      1347       anl C, COL4
0C05 5002      1348       jnc Keypad_Find_Row
0C07 C3        1349       clr C
0C08 22        1350       ret
0C09           1351   
0C09           1352   Keypad_Find_Row:
0C09 D292      1353       setb ROW1
0C0B D294      1354       setb ROW2
0C0D D296      1355       setb ROW3
0C0F D2A0      1356       setb ROW4
0C11           1357   
0C11           1358       ; Row 1
0C11 C292      1359       clr ROW1
0C13 30A23D    1360       jnb COL1, Keypad_Key_1
0C16 30A43E    1361       jnb COL2, Keypad_Key_2
0C19 30A63F    1362       jnb COL3, Keypad_Key_3
0C1C 30B040    1363       jnb COL4, Keypad_Key_A
0C1F D292      1364       setb ROW1
0C21           1365   
0C21           1366       ; Row 2
0C21 C294      1367       clr ROW2
0C23 30A23D    1368       jnb COL1, Keypad_Key_4
0C26 30A43E    1369       jnb COL2, Keypad_Key_5
0C29 30A63F    1370       jnb COL3, Keypad_Key_6
0C2C 30B040    1371       jnb COL4, Keypad_Key_B
0C2F D294      1372       setb ROW2
0C31           1373   
0C31           1374       ; Row 3
0C31 C296      1375       clr ROW3
0C33 30A23D    1376       jnb COL1, Keypad_Key_7
0C36 30A43E    1377       jnb COL2, Keypad_Key_8
0C39 30A63F    1378       jnb COL3, Keypad_Key_9
0C3C 30B040    1379       jnb COL4, Keypad_Key_C
0C3F D296      1380       setb ROW3
0C41           1381   
0C41           1382       ; Row 4
0C41 C2A0      1383       clr ROW4
0C43 30A23D    1384       jnb COL1, Keypad_Key_Star
0C46 30A43E    1385       jnb COL2, Keypad_Key_0
0C49 30A63F    1386       jnb COL3, Keypad_Key_Hash
0C4C 30B040    1387       jnb COL4, Keypad_Key_D
0C4F D2A0      1388       setb ROW4
0C51 C3        1389       clr C
0C52 22        1390       ret
0C53           1391   
0C53           1392   ; Key Mapping (Renamed to avoid conflicts)
0C53 7F01      1393   Keypad_Key_1: mov R7, #1
0C55 803C      1394          sjmp Wait_Release
0C57 7F02      1395   Keypad_Key_2: mov R7, #2
0C59 8038      1396          sjmp Wait_Release
0C5B 7F03      1397   Keypad_Key_3: mov R7, #3
0C5D 8034      1398          sjmp Wait_Release
0C5F 7F0A      1399   Keypad_Key_A: mov R7, #10
0C61 8030      1400          sjmp Wait_Release
0C63 7F04      1401   Keypad_Key_4: mov R7, #4
0C65 802C      1402          sjmp Wait_Release
0C67 7F05      1403   Keypad_Key_5: mov R7, #5
0C69 8028      1404          sjmp Wait_Release
0C6B 7F06      1405   Keypad_Key_6: mov R7, #6
0C6D 8024      1406          sjmp Wait_Release
0C6F 7F0B      1407   Keypad_Key_B: mov R7, #11
0C71 8020      1408          sjmp Wait_Release
0C73 7F07      1409   Keypad_Key_7: mov R7, #7
0C75 801C      1410          sjmp Wait_Release
0C77 7F08      1411   Keypad_Key_8: mov R7, #8
0C79 8018      1412          sjmp Wait_Release
0C7B 7F09      1413   Keypad_Key_9: mov R7, #9
0C7D 8014      1414          sjmp Wait_Release
0C7F 7F0D      1415   Keypad_Key_C: mov R7, #13
0C81 8010      1416          sjmp Wait_Release
0C83 7F0E      1417   Keypad_Key_Star: mov R7, #14
0C85 800C      1418          sjmp Wait_Release
0C87 7F00      1419   Keypad_Key_0: mov R7, #0
0C89 8008      1420          sjmp Wait_Release
0C8B 7F0C      1421   Keypad_Key_Hash: mov R7, #12
0C8D 8004      1422          sjmp Wait_Release
0C8F 7F0F      1423   Keypad_Key_D: mov R7, #15
0C91 8000      1424          sjmp Wait_Release
0C93           1425   
0C93           1426   Wait_Release:
0C93 A2A2      1427       mov C, COL1
0C95 82A4      1428       anl C, COL2
0C97 82A6      1429       anl C, COL3
0C99 82B0      1430       anl C, COL4
0C9B 50F6      1431       jnc Wait_Release
0C9D D3        1432       setb C
0C9E D292      1433       setb ROW1
0CA0 D294      1434       setb ROW2
0CA2 D296      1435       setb ROW3
0CA4 D2A0      1436       setb ROW4
0CA6 22        1437       ret
0CA7           1438   
0CA7           1439   Wait_25ms:
0CA7           1440       ; 1. Check if we are already waiting
0CA7 20130E    1441       jb wait25_active, Check_Timer_Status
0CAA           1442       
0CAA           1443       ; 2. Check if we just finished
0CAA 301404    1444       jnb wait25_done, Start_New_Timer
0CAD           1445       
0CAD           1446       ; 3. Timer is DONE! Reset flags and return True
0CAD C214      1447       clr wait25_done
0CAF D3        1448       setb C          ; Carry = 1 means "Done"
0CB0 22        1449       ret
0CB1           1450   
0CB1           1451   Start_New_Timer:
0CB1           1452       ; 4. Start a new 25ms wait
0CB1 754F00    1453       mov wait25_count, #0
0CB4 D213      1454       setb wait25_active
0CB6 C3        1455       clr C           ; Carry = 0 means "Not Done Yet"
0CB7 22        1456       ret
0CB8           1457   
0CB8           1458   Check_Timer_Status:
0CB8           1459       ; 5. Still waiting... return False immediately
0CB8 C3        1460       clr C           ; Carry = 0 means "Not Done Yet"
0CB9 22        1461       ret
0CBA           1462   
0CBA           1463   ; ----------------------------------------------------------------
0CBA           1464   ; MODULE: BUFFER INIT (Reset Logic)
0CBA           1465   ; ----------------------------------------------------------------
0CBA           1466   Init_All_Buffers:
0CBA 786B      1467       mov R0, #Buf_Soak_Temp
0CBC 120CCF    1468       lcall Init_Temp_Template
0CBF 7874      1469       mov R0, #Buf_Refl_Temp
0CC1 120CCF    1470       lcall Init_Temp_Template
0CC4 786F      1471       mov R0, #Buf_Soak_Time
0CC6 120CDB    1472       lcall Init_Time_Template
0CC9 7878      1473       mov R0, #Buf_Refl_Time
0CCB 120CDB    1474       lcall Init_Time_Template
0CCE 22        1475       ret
0CCF           1476   
0CCF           1477   Init_Temp_Template:
0CCF 7630      1478       mov @R0, #'0'
0CD1 08        1479       inc R0
0CD2 7630      1480       mov @R0, #'0'
0CD4 08        1481       inc R0
0CD5 7630      1482       mov @R0, #'0'
0CD7 08        1483       inc R0
0CD8 7600      1484       mov @R0, #0
0CDA 22        1485       ret
0CDB           1486   
0CDB           1487   Init_Time_Template:
0CDB 7630      1488       mov @R0, #'0'
0CDD 08        1489       inc R0
0CDE 7630      1490       mov @R0, #'0'
0CE0 08        1491       inc R0
0CE1 7630      1492       mov @R0, #'0'
0CE3 08        1493       inc R0
0CE4 7630      1494       mov @R0, #'0'
0CE6 08        1495       inc R0
0CE7 7600      1496       mov @R0, #0
0CE9 22        1497       ret
0CEA           1498   
0CEA           1499   Reset_Current_Buffer:
0CEA E569      1500       mov A, Current_State
0CEC B40106    1501       cjne A, #1, Reset_Chk_2
0CEF 786B      1502       mov R0, #Buf_Soak_Temp
0CF1 120CCF    1503       lcall Init_Temp_Template
0CF4 22        1504       ret
0CF5           1505   Reset_Chk_2:
0CF5 B40206    1506       cjne A, #2, Reset_Chk_3
0CF8 786F      1507       mov R0, #Buf_Soak_Time
0CFA 120CDB    1508       lcall Init_Time_Template
0CFD 22        1509       ret
0CFE           1510   Reset_Chk_3:
0CFE B40306    1511       cjne A, #3, Reset_Chk_4
0D01 7874      1512       mov R0, #Buf_Refl_Temp
0D03 120CCF    1513       lcall Init_Temp_Template
0D06 22        1514       ret
0D07           1515   Reset_Chk_4:
0D07 7878      1516       mov R0, #Buf_Refl_Time
0D09 120CDB    1517       lcall Init_Time_Template
0D0C 22        1518       ret
0D0D           1519   
0D0D           1520   ; ----------------------------------------------------------------
0D0D           1521   ; MODULE: SCREEN UPDATE (Visual Logic)
0D0D           1522   ; ----------------------------------------------------------------
0D0D           1523   Update_Screen_Full:
0D0D 120E0A    1524       lcall Clear_Screen_Func
0D10 C0E0      1525            push acc
0D12 7401      1525            mov a, #1
0D14 14        1525            dec a
0D15 1205C9    1525            lcall ?Set_Cursor_1 ; Select column and row
0D18 D0E0      1525            pop acc
0D1A           1526   
0D1A           1527       ; --- Draw Line 1 (Titles) ---
0D1A E569      1528       mov A, Current_State
0D1C B40013    1529       cjne A, #0, Update_State_1
0D1F C083      1530            push dph
0D21 C082      1530            push dpl
0D23 C0E0      1530            push acc
0D25 900350    1530            mov dptr, #Txt_Home
0D28 1205BC    1530            lcall ?Send_Constant_String
0D2B D0E0      1530            pop acc
0D2D D082      1530            pop dpl
0D2F D083      1530            pop dph
0D31 22        1531       ret 
0D32           1532   Update_State_1:
0D32 B40114    1533       cjne A, #1, Update_State_2
0D35 C083      1534            push dph
0D37 C082      1534            push dpl
0D39 C0E0      1534            push acc
0D3B 900361    1534            mov dptr, #Txt_SoakT
0D3E 1205BC    1534            lcall ?Send_Constant_String
0D41 D0E0      1534            pop acc
0D43 D082      1534            pop dpl
0D45 D083      1534            pop dph
0D47 8042      1535       sjmp Draw_Temp_Format
0D49           1536   Update_State_2:
0D49 B40214    1537       cjne A, #2, Update_State_3
0D4C C083      1538            push dph
0D4E C082      1538            push dpl
0D50 C0E0      1538            push acc
0D52 900372    1538            mov dptr, #Txt_SoakTime
0D55 1205BC    1538            lcall ?Send_Constant_String
0D58 D0E0      1538            pop acc
0D5A D082      1538            pop dpl
0D5C D083      1538            pop dph
0D5E 8042      1539       sjmp Draw_Time_Format
0D60           1540   Update_State_3:
0D60 B40314    1541       cjne A, #3, Update_State_4
0D63 C083      1542            push dph
0D65 C082      1542            push dpl
0D67 C0E0      1542            push acc
0D69 900383    1542            mov dptr, #Txt_ReflT
0D6C 1205BC    1542            lcall ?Send_Constant_String
0D6F D0E0      1542            pop acc
0D71 D082      1542            pop dpl
0D73 D083      1542            pop dph
0D75 8014      1543       sjmp Draw_Temp_Format
0D77           1544   Update_State_4:
0D77 C083      1545            push dph
0D79 C082      1545            push dpl
0D7B C0E0      1545            push acc
0D7D 900394    1545            mov dptr, #Txt_ReflTime
0D80 1205BC    1545            lcall ?Send_Constant_String
0D83 D0E0      1545            pop acc
0D85 D082      1545            pop dpl
0D87 D083      1545            pop dph
0D89 8017      1546       sjmp Draw_Time_Format
0D8B           1547   
0D8B           1548   ; --- Draw Line 2 (Values) ---
0D8B           1549   Draw_Temp_Format:
0D8B C0E0      1550            push acc
0D8D 7401      1550            mov a, #1
0D8F 14        1550            dec a
0D90 1205C7    1550            lcall ?Set_Cursor_2 ; Select column and row
0D93 D0E0      1550            pop acc
0D95 120E18    1551       lcall Get_Current_Buffer_Addr
0D98 120DFA    1552       lcall Print_String_RAM
0D9B 7443      1553       mov A, #'C'
0D9D 12057F    1554       lcall ?WriteData
0DA0 802C      1555       sjmp Restore_Cursor
0DA2           1556   
0DA2           1557   Draw_Time_Format:
0DA2 C0E0      1558            push acc
0DA4 7401      1558            mov a, #1
0DA6 14        1558            dec a
0DA7 1205C7    1558            lcall ?Set_Cursor_2 ; Select column and row
0DAA D0E0      1558            pop acc
0DAC 120E18    1559       lcall Get_Current_Buffer_Addr
0DAF           1560       ; MM
0DAF E6        1561       mov A, @R0
0DB0 12057F    1562       lcall ?WriteData
0DB3 08        1563       inc R0
0DB4 E6        1564       mov A, @R0
0DB5 12057F    1565       lcall ?WriteData
0DB8 08        1566       inc R0
0DB9           1567       ; Colon
0DB9 743A      1568       mov A, #':'
0DBB 12057F    1569       lcall ?WriteData
0DBE           1570       ; SS
0DBE E6        1571       mov A, @R0
0DBF 12057F    1572       lcall ?WriteData
0DC2 08        1573       inc R0
0DC3 E6        1574       mov A, @R0
0DC4 12057F    1575       lcall ?WriteData
0DC7           1576       ; Unit
0DC7 7473      1577       mov A, #'s'
0DC9 12057F    1578       lcall ?WriteData
0DCC 8000      1579       sjmp Restore_Cursor
0DCE           1580   
0DCE           1581   ; --- Restore Cursor Position ---
0DCE           1582   Restore_Cursor:
0DCE E569      1583       mov A, Current_State
0DD0 B40202    1584       cjne A, #2, Check_State_4
0DD3 800D      1585       sjmp Adjust_Cursor_Time
0DD5           1586   Check_State_4:
0DD5 B40402    1587       cjne A, #4, Normal_Cursor
0DD8 8008      1588       sjmp Adjust_Cursor_Time
0DDA           1589   
0DDA           1590   Normal_Cursor:
0DDA E56A      1591       mov A, Cursor_Idx
0DDC 24C0      1592       add A, #0xC0
0DDE 120584    1593       lcall ?WriteCommand
0DE1 22        1594       ret
0DE2           1595   
0DE2           1596   Adjust_Cursor_Time:
0DE2           1597       ; Skip the colon index (2)
0DE2 E56A      1598       mov A, Cursor_Idx
0DE4 B40201    1599       cjne A, #2, No_Skip
0DE7 04        1600       inc A 
0DE8           1601   No_Skip:
0DE8           1602       ; Add 1 if past the colon
0DE8 C3        1603       clr C
0DE9 9402      1604       subb A, #2
0DEB 4005      1605       jc No_Add
0DED E56A      1606       mov A, Cursor_Idx
0DEF 04        1607       inc A
0DF0 8002      1608       sjmp Final_Cursor_Set
0DF2           1609   No_Add:
0DF2 E56A      1610       mov A, Cursor_Idx
0DF4           1611   Final_Cursor_Set:
0DF4 24C0      1612       add A, #0xC0
0DF6 120584    1613       lcall ?WriteCommand
0DF9 22        1614       ret
0DFA           1615   
0DFA           1616   Print_String_RAM:
0DFA E6        1617       mov A, @R0
0DFB 6006      1618       jz Print_String_Done
0DFD 12057F    1619       lcall ?WriteData
0E00 08        1620       inc R0
0E01 80F7      1621       sjmp Print_String_RAM
0E03           1622   Print_String_Done:
0E03 22        1623       ret
0E04           1624   
0E04           1625   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0E04           1626   Wait_25ms_BLOCKING:
0E04 120CA7    1627       lcall Wait_25ms
0E07 50FB      1628       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0E09 22        1629       ret
0E0A           1630   
0E0A           1631   Clear_Screen_Func:
0E0A 7401      1632       mov A, #0x01
0E0C 120584    1633       lcall ?WriteCommand
0E0F           1634       ; Use the blocking version here
0E0F 120E04    1635       lcall Wait_25ms_BLOCKING 
0E12 740F      1636       mov A, #0x0F
0E14 120584    1637       lcall ?WriteCommand
0E17 22        1638       ret
0E18           1639   
0E18           1640   Get_Current_Buffer_Addr:
0E18 E569      1641       mov A, Current_State
0E1A B40103    1642       cjne A, #1, Get_Buf_2
0E1D 786B      1643       mov R0, #Buf_Soak_Temp
0E1F 22        1644       ret
0E20           1645   Get_Buf_2:
0E20 B40203    1646       cjne A, #2, Get_Buf_3
0E23 786F      1647       mov R0, #Buf_Soak_Time
0E25 22        1648       ret
0E26           1649   Get_Buf_3:
0E26 B40303    1650       cjne A, #3, Get_Buf_4
0E29 7874      1651       mov R0, #Buf_Refl_Temp
0E2B 22        1652       ret
0E2C           1653   Get_Buf_4:
0E2C 7878      1654       mov R0, #Buf_Refl_Time
0E2E 22        1655       ret
0E2F           1656       
0E2F           1657   ; --- Helper to prevent "Machine Gun" button presses ---
0E2F           1658   Wait_For_P1_0_Release:
0E2F 3090FD    1659       jnb P1.0, $    ; Wait here while the button is still pressed (0)
0E32 22        1660       ret
0E33           1661       
0E33           1662       
0E33           1663   ; ================================================================
0E33           1664   ; MODULE: THERMOCOUPLE ADC DRIVER (Non-Blocking)
0E33           1665   ; ================================================================
0E33           1666   Read_Thermocouple:
0E33           1667       ; 1. Initialize ADC (Only once)
0E33           1668       ; We need a state variable to know if we are waiting or starting
0E33           1669       ; For simplicity in this loop, we will just use the Wait function's status.
0E33           1670       
0E33 120CA7    1671       lcall Wait_25ms
0E36 504B      1672       jnc Read_TC_Exit ; If Not Done (C=0), exit immediately!
0E38           1673   
0E38           1674       ; --- 25ms IS DONE! NOW READ ---
0E38           1675       
0E38           1676       ; Reset ADC (Start conversion logic)
0E38 75A180    1677       mov ADC_C, #0x80    ; Reset ADC
0E3B 75A100    1678       mov ADC_C, #0x00    ; Select Channel 0
0E3E           1679       
0E3E           1680       ; Get Raw Count (0 to 4095)
0E3E 85A232    1681       mov x+0, ADC_L
0E41 85A333    1682       mov x+1, ADC_H
0E44 753400    1683       mov x+2, #0
0E47 753500    1684       mov x+3, #0
0E4A           1685       
0E4A           1686       ; Convert Count to Voltage (mV)
0E4A 753688    1687            mov y+0, #low (5000 % 0x10000) 
0E4D 753713    1687            mov y+1, #high(5000 % 0x10000) 
0E50 753800    1687            mov y+2, #low (5000 / 0x10000) 
0E53 753900    1687            mov y+3, #high(5000 / 0x10000)         ; Load 5000 mV
0E56 12018C    1688       lcall mul32         ; x = Count * 5000
0E59           1689       
0E59 7536FF    1690            mov y+0, #low (4095 % 0x10000) 
0E5C 75370F    1690            mov y+1, #high(4095 % 0x10000) 
0E5F 753800    1690            mov y+2, #low (4095 / 0x10000) 
0E62 753900    1690            mov y+3, #high(4095 / 0x10000)         ; Load Max resolution
0E65 120280    1691       lcall div32         ; x = Voltage in mV
0E68           1692       
0E68           1693       ; Convert Voltage to Temperature (Gain = 10mV/C)
0E68 75360A    1694            mov y+0, #low (10 % 0x10000) 
0E6B 753700    1694            mov y+1, #high(10 % 0x10000) 
0E6E 753800    1694            mov y+2, #low (10 / 0x10000) 
0E71 753900    1694            mov y+3, #high(10 / 0x10000)           
0E74 120280    1695       lcall div32
0E77           1696       
0E77           1697       ; Store Result
0E77 85323F    1698       mov current_temp+0, x+0
0E7A 853340    1699       mov current_temp+1, x+1
0E7D 853441    1700       mov current_temp+2, x+2
0E80 853542    1701       mov current_temp+3, x+3
0E83           1702   
0E83           1703   Read_TC_Exit:
0E83 22        1704       ret
0E84           1705   
0E84           1706   ; ================================================================
0E84           1707   ; MODULE: POWER CONTROLLER (The Brain)
0E84           1708   ; ================================================================
0E84           1709   Power_Control:
0E84           1710       ; Default: Turn Heat OFF (Safety)
0E84 755C00    1711       mov power_output+0, #0
0E87 755D00    1712       mov power_output+1, #0
0E8A 755E00    1713       mov power_output+2, #0
0E8D 755F00    1714       mov power_output+3, #0
0E90           1715   
0E90 E568      1716       mov a, Control_FSM_state
0E92           1717   
0E92           1718       ; --- State 2: RAMP TO SOAK ---
0E92 B40202    1719       cjne a, #2, PC_Check_Soak
0E95           1720       ; Mode: Full Speed Ahead
0E95 8016      1721       sjmp Set_Max_Power
0E97           1722   
0E97           1723   PC_Check_Soak:
0E97           1724       ; --- State 3: SOAK PHASE ---
0E97 B40305    1725       cjne a, #3, PC_Check_Ramp_Reflow
0E9A           1726       ; Mode: Maintenance (Low Power)
0E9A           1727       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
0E9A 20030F    1728       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
0E9D 801B      1729       sjmp Set_20_Percent_Power     ; If cold, use 20%
0E9F           1730   
0E9F           1731   PC_Check_Ramp_Reflow:
0E9F           1732       ; --- State 4: RAMP TO REFLOW ---
0E9F B40402    1733       cjne a, #4, PC_Check_Reflow
0EA2           1734       ; Mode: Full Speed Ahead
0EA2 8009      1735       sjmp Set_Max_Power
0EA4           1736   
0EA4           1737   PC_Check_Reflow:
0EA4           1738       ; --- State 5: REFLOW PHASE ---
0EA4 B40505    1739       cjne a, #5, PC_Done
0EA7           1740       ; Mode: Maintenance (Low Power)
0EA7 200402    1741       jb reflow_temp_reached, PC_Done
0EAA 800E      1742       sjmp Set_20_Percent_Power
0EAC           1743   
0EAC           1744   PC_Done:
0EAC 22        1745       ret
0EAD           1746   
0EAD           1747   ; --- Power Helpers ---
0EAD           1748   
0EAD           1749   Set_Max_Power:
0EAD           1750       ; Load 1500 (0x05DC) = 100% Duty Cycle
0EAD 755CDC    1751       mov power_output+0, #0xDC
0EB0 755D05    1752       mov power_output+1, #0x05
0EB3 755E00    1753       mov power_output+2, #0
0EB6 755F00    1754       mov power_output+3, #0
0EB9 22        1755       ret
0EBA           1756   
0EBA           1757   Set_20_Percent_Power:
0EBA           1758       ; Load 300 (0x012C) = 20% Duty Cycle
0EBA 755C2C    1759       mov power_output+0, #0x2C
0EBD 755D01    1760       mov power_output+1, #0x01
0EC0 755E00    1761       mov power_output+2, #0
0EC3 755F00    1762       mov power_output+3, #0
0EC6 22        1763       ret
0EC7           1764   
0EC7           1765   EN
