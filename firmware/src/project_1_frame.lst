0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 02099A       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9            reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 020469      12            ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15            reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18            reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21            reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 0204D4      24            ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   current_time_sec:     ds 1
0031             38   current_time_minute:  ds 1
0032             39   ; math32 buffer variables
0032             40   x:               ds      4
0036             41   y:               ds      4
003A             42   bcd:     ds      5
003F             43   
003F             44   current_temp: ds 4 ;
0043             45   soak_temp:    ds 4 ;
0047             46   reflow_temp:  ds 4 ;
004B             47   
004B             48   current_time: ds 4 ;
004F             49   soak_time:    ds 4 ;
0053             50   reflow_time:  ds 4 ;
0057             51   
0057             52   power_output:  ds 4 ;
005B             53   pwm_counter: ds 4 ; counter for pwm (0-1500)
005F             54   
005F             55   KEY1_DEB_timer: ds 1
0060             56   SEC_FSM_timer:  ds 1
0061             57   KEY1_DEB_state:    ds 1
0062             58   SEC_FSM_state:      ds 1
0063             59   Control_FSM_state: ds 1 
0064             60   
0064             61   Current_State:     ds 1
0065             62   
0065             63   
0065             64   ;-- UI buffers I added (ayaan)
0065             65   Cursor_Idx: ds 1
0066             66   
0066             67   ; These hold the TEXT (ASCII) safely
0066             68   ; Digits Only + Null Terminator, got rid of C,:, and s 
0066             69   Buf_Soak_Temp: ds 4   
006A             70   Buf_Soak_Time: ds 5   
006F             71   Buf_Refl_Temp: ds 4   
0073             72   Buf_Refl_Time: ds 5
0078             73   
0078             74   ; 46d bytes used
0078             75   
0078             76   ;-------------------------------------------------------------------------------
0078             77   ; bit operation setb, clr, jb, and jnb
0000             78   bseg
0000             79   mf:              dbit 1 ; math32 sign
0001             80   one_second_flag: dbit 1
0002             81   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003             82   
0003             83   soak_temp_reached: dbit 1
0004             84   reflow_temp_reached: dbit 1
0005             85   cooling_temp_reached: dbit 1
0006             86   
0006             87   soak_time_reached: dbit 1
0007             88   reflow_time_reached: dbit 1
0008             89   
0008             90   reset_signal: dbit 1
0009             91   stop_signal: dbit 1
000A             92   start_signal: dbit 1
000B             93   config_finish_signal: dbit 1
000C             94   
000C             95   state_change_signal: dbit 1
000D             96   
000D             97   Key1_flag: dbit 1
000E             98   
000E             99   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
000F            100   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0010            101   PB0_flag: dbit 1 ; start entire program
0011            102   PB1_flag: dbit 1 ; start soak
0012            103   PB2_flag: dbit 1 ; pause process
0013            104   ; 11 bits used
0013            105   
0013            106   ;-------------------------------------------------------------------------------
0320            107   cseg
0320            108   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            109   BAUD                EQU 57600
0320            110   
0320            111   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            112   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            113   ; is always 12 unlike the N76E003 where is selectable.
0320            114   
0320            115   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            116   
0320            117   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            118   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            119   
0320            120   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            121   
0320            122   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            123   
0320            124   PWM_OUT             EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            125   
0320            126   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            127   ; P0 is in connector JPIO.
0320            128   
0320            129   ;Added correct I/O definitions
0320            130   ;-- LCD Pins ---
0320            131   ELCD_RS equ P1.7
0320            132   ELCD_E  equ P1.1
0320            133   ELCD_D4 equ P0.7
0320            134   ELCD_D5 equ P0.5
0320            135   ELCD_D6 equ P0.3
0320            136   ELCD_D7 equ P0.1
0320            137   
0320            138   ; -- Buttons --
0320            139   BTN_SOAK_TEMP equ P0.0
0320            140   BTN_SOAK_TIME equ P0.2
0320            141   BTN_REFL_TEMP equ P0.4
0320            142   BTN_REFL_TIME equ P0.6
0320            143   
0320            144   ; --- KEYPAD ---
0320            145   ROW1 equ P1.2
0320            146   ROW2 equ P1.4
0320            147   ROW3 equ P1.6
0320            148   ROW4 equ P2.0
0320            149   COL1 equ P2.2
0320            150   COL2 equ P2.4
0320            151   COL3 equ P2.6
0320            152   COL4 equ P3.0
0320            153   
0320            154   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   155   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   156   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   157   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            158   
0350            159   ; --- UI STRINGS (REQUIRED FOR KEYPAD LOGIC), <- I can fix if duplicates
0350 53656C65   160   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   161   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   162   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   163   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   164   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            165   
03A5            166   ;                       1234567890123456
03A5 53657420   167   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   168   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   169   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   170   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   171   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            172   
03E5            173   ;                     1234567890123456
03E5 52616D70   174   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03F5 536F616B   175   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
0405 52616D70   176   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
0415 5265666C   177   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
0425 436F6F6C   178   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
0435 50726F63   179   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
0445            180   
0445 20202020   181   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
0456            182   
0456            183   ;-------------------------------------------------------------------------------
0456            184   ; Timers Setting:
0456            185   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
0456            186   ;        Timer 1: Serial port baud rate 57600 generator
0456            187   ;        Timer 2: 1ms interrupt for BCD counter increment/decrement
0456            188   ;-------------------------------------------------------------------------------
0456            189   ; Routine to initialize the ISR for Timer 0 ;
0456            190   Timer0_Init:
0456 E589       191            mov a, TMOD
0458 54F0       192            anl a, #0xf0 ; Clear the bits for timer 0
045A 4401       193            orl a, #0x01 ; Configure timer 0 as 16-timer
045C F589       194            mov TMOD, a
045E 758CFD     195            mov TH0, #high(TIMER0_RELOAD)
0461 758A5A     196            mov TL0, #low(TIMER0_RELOAD)
0464            197            ; Enable the timer and interrupts
0464 D2A9       198       setb ET0  ; Enable timer 0 interrupt
0466 D28C       199       setb TR0  ; Start timer 0
0468 22         200            ret
0469            201   ; ISR for timer 0.  Set to execute every 1/4096Hz 
0469            202   ; to generate a 2048 Hz square wave at pin P1.5 
0469            203   Timer0_ISR:
0469            204            ;clr TF0  ; According to the data sheet this is done for us already.
0469 758CFD     205            mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
046C 758A5A     206            mov TL0, #low(TIMER0_RELOAD)
046F B295       207            cpl SOUND_OUT ; Connect speaker to P1.5
0471 32         208            reti
0472            209   ; -----------------------------------------------------------------------------------------------;
0472            210   
0472            211   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0472            212   Initialize_Serial_Port:
0472            213            ; Configure serial port and baud rate
0472 C28E       214            clr TR1 ; Disable timer 1
0474 53890F     215            anl TMOD, #0x0f ; Mask the bits for timer 1
0477 438920     216            orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047A 438780     217       orl PCON, #80H ; Set SMOD to 1
047D 758DFD     218            mov TH1, #low(TIMER_1_RELOAD)
0480 758BFD     219            mov TL1, #low(TIMER_1_RELOAD) 
0483 D28E       220            setb TR1 ; Enable timer 1
0485 759852     221            mov SCON, #52H
0488 22         222            ret
0489            223   
0489            224   ; uart sending functions
0489            225   putchar:
0489 109902     226            jbc     TI, putchar_L1
048C 80FB       227            sjmp putchar
048E            228   putchar_L1:
048E F599       229            mov     SBUF,a
0490 22         230            ret
0491            231   
0491            232   SendString:
0491 E4         233       clr a
0492 93         234       movc a, @a+dptr
0493 6006       235       jz SendString_L1
0495 120489     236       lcall putchar
0498 A3         237       inc dptr
0499 80F6       238       sjmp SendString  
049B            239   SendString_L1:
049B 22         240            ret
049C            241   
049C            242   ;-------------------------------------------------------------------------------
049C            243   ; serial debugging
049C            244   ; send a four byte number via serial to laptop
049C            245   ; need to be used with python script
049C            246   ; content needed to be sent should be stored in the varaible x
049C            247   ;-------------------------------------------------------------------------------
049C            248   Send32:
049C            249       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
049C 74AA       250       mov A, #0AAH
049E 120489     251       lcall putchar
04A1 7455       252       mov A, #055H
04A3 120489     253       lcall putchar
04A6            254   
04A6 E535       255       mov A, x+3
04A8 120489     256       lcall putchar
04AB E534       257       mov A, x+2
04AD 120489     258       lcall putchar
04B0 E533       259       mov A, x+1
04B2 120489     260       lcall putchar
04B5 E532       261       mov A, x+0
04B7 120489     262       lcall putchar
04BA            263   
04BA 740A       264       mov A, #0AH
04BC 120489     265       lcall putchar
04BF 22         266       ret
04C0            267   ; -----------------------------------------------------------------------------------------------;
04C0            268   
04C0            269   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
04C0              1   ;------------------------------------------------------------------------------------------------;
04C0              2   ; Routine to initialize the ISR for timer 2 
04C0              3   Timer2_Init:
04C0 75C800       4            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
04C3 75CDF5       5            mov TH2, #high(TIMER2_RELOAD)
04C6 75CC27       6            mov TL2, #low(TIMER2_RELOAD)
04C9              7            ; Set the reload value
04C9 75CBF5       8            mov RCAP2H, #high(TIMER2_RELOAD)
04CC 75CA27       9            mov RCAP2L, #low(TIMER2_RELOAD)
04CF             10            ; Enable the timer and interrupts
04CF D2AD        11       setb ET2  ; Enable timer 2 interrupt
04D1 D2CA        12       setb TR2  ; Enable timer 2
04D3 22          13            ret
04D4             14   
04D4             15   ; ISR for timer 2.  Runs every 1 ms ;
04D4             16   Timer2_ISR:
04D4 C0E0        17            push acc
04D6 C0D0        18            push psw
04D8 C2CF        19            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
04DA             20            ; cpl P1.1 ; Optional debug pin toggle for scope (ensure it's not used elsewhere)
04DA             21   
04DA             22   ; FSM states timers
04DA 055F        23            inc KEY1_DEB_timer
04DC 0560        24            inc SEC_FSM_timer
04DE             25   
04DE D202        26            setb one_ms_pwm_flag ; set the one millisecond flag for pwm signal generation
04E0             27   
04E0             28   Timer2_ISR_done:
04E0 D0D0        29            pop psw
04E2 D0E0        30            pop acc
04E4 32          31            reti
04E5             32   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
04E5              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
04E5              2   cseg
04E5              3   
04E5              4   ; When using a 33.333333MHz crystal clock
04E5              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
04E5              6   
04E5              7   ;---------------------------------;
04E5              8   ; Wait 40 microseconds            ;
04E5              9   ;---------------------------------;
04E5             10   Wait40uSec:
04E5 C000        11            push AR0
04E7 78BE        12            mov R0, #190
04E9             13   L0: 
04E9 00          14            nop
04EA 00          15            nop
04EB 00          16            nop
04EC 00          17            nop
04ED D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
04EF D000        19            pop AR0
04F1 22          20       ret
04F2             21   
04F2             22   ;---------------------------------;
04F2             23   ; Wait 'R2' milliseconds          ;
04F2             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
04F2             31   
04F2             32   ?Wait_Milli_Seconds:
04F2 C000        33            push AR0
04F4 C001        34            push AR1
04F6 7932        35   L3: mov R1, #50
04F8 78DF        36   L2: mov R0, #223
04FA D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
04FC D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
04FE DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
0500 D001        40       pop AR1
0502 D000        41       pop AR0
0504 22          42       ret
0505             43            
0505             44   ;---------------------------------;
0505             45   ; Toggles the 'E' pin in the LCD  ;
0505             46   ;---------------------------------;
0505             47   ELCD_pulse:
0505 D291        48            setb ELCD_E
0507 1204E5      49            lcall Wait40uSec
050A C291        50            clr ELCD_E
050C 1204E5      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
050F 22          52       ret
0510             53   
0510             54   ;---------------------------------;
0510             55   ; Writes acc to LCD in 4-bit mode ;
0510             56   ;---------------------------------;
0510             57   ELCD_byte:
0510             58            ; Write high 4 bits first
0510 A2E7        59            mov c, ACC.7
0512 9281        60            mov ELCD_D7, c
0514 A2E6        61            mov c, ACC.6
0516 9283        62            mov ELCD_D6, c
0518 A2E5        63            mov c, ACC.5
051A 9285        64            mov ELCD_D5, c
051C A2E4        65            mov c, ACC.4
051E 9287        66            mov ELCD_D4, c
0520 120505      67       lcall ELCD_pulse
0523             68            ; Write low 4 bits next
0523 A2E3        69            mov c, ACC.3
0525 9281        70            mov ELCD_D7, c
0527 A2E2        71            mov c, ACC.2
0529 9283        72            mov ELCD_D6, c
052B A2E1        73            mov c, ACC.1
052D 9285        74            mov ELCD_D5, c
052F A2E0        75            mov c, ACC.0
0531 9287        76            mov ELCD_D4, c
0533 120505      77       lcall ELCD_pulse
0536 22          78            ret
0537             79   
0537             80   ;---------------------------------;
0537             81   ; Write data to LCD               ;
0537             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
0537             87            
0537             88   ?WriteData:
0537 D297        89            setb ELCD_RS
0539 020510      90            ljmp ELCD_byte
053C             91   
053C             92   ;---------------------------------;
053C             93   ; Write command to LCD            ;
053C             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
053C             99   
053C            100   ?WriteCommand:
053C C297       101            clr ELCD_RS
053E 020510     102            ljmp ELCD_byte
0541            103   
0541            104   ;---------------------------------;
0541            105   ; Configure LCD in 4-bit mode     ;
0541            106   ;---------------------------------;
0541            107   ELCD_4BIT:
0541 C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
0543            109            ;clr ELCD_RW  ; RW forced to zero
0543            110            
0543            111            ; After power on, let the LCD start up before initializing
0543 C002       112            push AR2
0545 7A28       112            mov R2, #40
0547 1204F2     112            lcall ?Wait_Milli_Seconds
054A D002       112            pop AR2
054C            112   
054C            113            
054C            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
054C 7433       115            mov a, #0x33
054E 12053C     115            lcall ?WriteCommand
0551 7433       116            mov a, #0x33
0553 12053C     116            lcall ?WriteCommand
0556 7432       117            mov a, #0x32
0558 12053C     117            lcall ?WriteCommand ; change to 4-bit mode
055B            118   
055B            119            ; Configure the LCD
055B 7428       120            mov a, #0x28
055D 12053C     120            lcall ?WriteCommand
0560 740C       121            mov a, #0x0c
0562 12053C     121            lcall ?WriteCommand
0565 7401       122            mov a, #0x01
0567 12053C     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
056A            123   
056A            124       ;Wait for the clear screen command to finish.
056A C002       125            push AR2
056C 7A02       125            mov R2, #2
056E 1204F2     125            lcall ?Wait_Milli_Seconds
0571 D002       125            pop AR2
0573            125   
0573 22         126       ret
0574            127   
0574            128   ;---------------------------------;
0574            129   ; Send a constant string to LCD   ;
0574            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
0574            141   
0574            142   ?Send_Constant_String:
0574 E4         143       clr a
0575 93         144       movc a, @a+dptr
0576 6006       145       jz ?Send_Constant_String_Done
0578 120537     146       lcall ?WriteData
057B A3         147       inc dptr
057C 80F6       148       sjmp ?Send_Constant_String
057E            149   ?Send_Constant_String_Done:
057E 22         150       ret  
057F            151   
057F            152   ;---------------------------------;
057F            153   ; Set LCD cursor at row, column   ;
057F            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
057F            162   
057F            163   ?Set_Cursor_2:
057F 4440       164            orl a, #01000000B
0581            165   ?Set_Cursor_1:
0581 4480       166            orl a, #10000000B
0583 02053C     167            ljmp ?WriteCommand ; Select column and row
0586            168   
0586            169   ;---------------------------------;
0586            170   ; Display a BCD number in the LCD ;
0586            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
0586            178   
0586            179   ?Display_BCD:
0586 C0E0       180            push acc
0588            181            ; Write most significant digit
0588 E8         182            mov a, r0
0589 C4         183            swap a
058A 540F       184            anl a, #0fh
058C 4430       185            orl a, #30h
058E 120537     186            lcall ?WriteData
0591            187            ; write least significant digit
0591 E8         188            mov a, r0
0592 540F       189            anl a, #0fh
0594 4430       190            orl a, #30h
0596 120537     191            lcall ?WriteData
0599 D0E0       192            pop acc
059B 22         193            ret
059C            194   
059C            195   ;------------------------------------;
059C            196   ; Display a char in the LCD          ;
059C            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
059C            204   
059C            272            ;-----------------------------------------------------------------------------------------------;
059C            273   
059C            274   ;-------------------------------------------------------------------------------
059C            275   ; Display Function for 7-segment displays                
059C            276   ;-------------------------------------------------------------------------------
059C            277   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
059C            278   T_7seg:
059C C0F9A4B0   279       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
05A1 9282F880   280       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
05A6 8883C6A1   281       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
05AC            282   
05AC            283   ; Displays a BCD number pased in R0 in HEX5-HEX0
05AC            284   Display_BCD_7_Seg_HEX10:
05AC 90059C     285            mov dptr, #T_7seg
05AF E8         286            mov a, R0
05B0 C4         287            swap a
05B1 540F       288            anl a, #0FH
05B3 93         289            movc a, @a+dptr
05B4 F592       290            mov HEX1, a
05B6 E8         291            mov a, R0
05B7 540F       292            anl a, #0FH
05B9 93         293            movc a, @a+dptr
05BA F591       294            mov HEX0, a
05BC 22         295            ret
05BD            296   
05BD            297   Display_BCD_7_Seg_HEX32:
05BD 90059C     298            mov dptr, #T_7seg
05C0 E8         299            mov a, R0
05C1 C4         300            swap a
05C2 540F       301            anl a, #0FH
05C4 93         302            movc a, @a+dptr
05C5 F594       303            mov HEX3, a
05C7 E8         304            mov a, R0
05C8 540F       305            anl a, #0FH
05CA 93         306            movc a, @a+dptr
05CB F593       307            mov HEX2, a
05CD 22         308            ret
05CE            309   
05CE            310   Display_BCD_7_Seg_HEX54:
05CE 90059C     311            mov dptr, #T_7seg
05D1 E8         312            mov a, R0
05D2 C4         313            swap a
05D3 540F       314            anl a, #0FH
05D5 93         315            movc a, @a+dptr
05D6 F58F       316            mov HEX5, a
05D8 E8         317            mov a, R0
05D9 540F       318            anl a, #0FH
05DB 93         319            movc a, @a+dptr
05DC F58E       320            mov HEX4, a
05DE 22         321            ret
05DF            322   
05DF            323   ; The 8-bit hex number passed in the accumulator is converted to
05DF            324   ; BCD and stored in [R1, R0]
05DF            325   Hex_to_bcd_8bit:
05DF 75F064     326            mov b, #100
05E2 84         327            div ab
05E3 F9         328            mov R1, a   ; After dividing, a has the 100s
05E4 E5F0       329            mov a, b    ; Remainder is in register b
05E6 75F00A     330            mov b, #10
05E9 84         331            div ab ; The tens are stored in a, the units are stored in b 
05EA C4         332            swap a
05EB 54F0       333            anl a, #0xf0
05ED 45F0       334            orl a, b
05EF F8         335            mov R0, a
05F0 22         336            ret
05F1            337   
05F1            338   ;-------------------------------------------------------------------------------
05F1            339   ; Display Function for LCD                                               
05F1            340   ;-------------------------------------------------------------------------------
05F1            341   LCD_Display_Update_func:
05F1 C0E0       342            push acc
05F3            343            
05F3            344       ; --- FIX: JUMP DISTANCE ERROR ---
05F3            345       ; "LCD_Display_Update_Done" is too far away for a JNB instruction.
05F3            346       ; We use a local label right here to exit quickly.
05F3 300C0A     347            jnb state_change_signal, LCD_Local_Exit
05F6            348       ; --------------------------------
05F6            349   
05F6 C20C       350            clr state_change_signal
05F8 E563       351            mov a, Control_FSM_state
05FA            352   
05FA            353            ; --- IMPORTANT ADD ----
05FA            354       ; If we are in State 1 (Setup), DO NOT RUN THIS, let the keypad logic handle the screen
05FA B40106     355       cjne a, #1, LCD_Display_Update_0
05FD D0E0       356       pop acc
05FF 22         357       ret 
0600            358   
0600            359   ; --- NEW LOCAL EXIT LABEL ---
0600            360   LCD_Local_Exit:
0600 D0E0       361       pop acc
0602 22         362       ret
0603            363   ; ----------------------------
0603            364   
0603            365   LCD_Display_Update_0:
0603 B4003B     366            cjne a, #0, LCD_Display_Update_1
0606 C0E0       367            push acc
0608 7401       367            mov a, #1
060A 14         367            dec a
060B 120581     367            lcall ?Set_Cursor_1 ; Select column and row
060E D0E0       367            pop acc
0610 C083       368            push dph
0612 C082       368            push dpl
0614 C0E0       368            push acc
0616 900330     368            mov dptr, #String_state0_1
0619 120574     368            lcall ?Send_Constant_String
061C D0E0       368            pop acc
061E D082       368            pop dpl
0620 D083       368            pop dph
0622 C0E0       369            push acc
0624 7401       369            mov a, #1
0626 14         369            dec a
0627 12057F     369            lcall ?Set_Cursor_2 ; Select column and row
062A D0E0       369            pop acc
062C C083       370            push dph
062E C082       370            push dpl
0630 C0E0       370            push acc
0632 900340     370            mov dptr, #String_state0_2
0635 120574     370            lcall ?Send_Constant_String
0638 D0E0       370            pop acc
063A D082       370            pop dpl
063C D083       370            pop dph
063E 02072F     371            ljmp LCD_Display_Update_done
0641            372   
0641            373   LCD_Display_Update_1:
0641 B4011F     374            cjne a, #1, LCD_Display_Update_2
0644 C0E0       375            push acc
0646 7401       375            mov a, #1
0648 14         375            dec a
0649 120581     375            lcall ?Set_Cursor_1 ; Select column and row
064C D0E0       375            pop acc
064E C083       376            push dph
0650 C082       376            push dpl
0652 C0E0       376            push acc
0654 9003A5     376            mov dptr, #String_state1
0657 120574     376            lcall ?Send_Constant_String
065A D0E0       376            pop acc
065C D082       376            pop dpl
065E D083       376            pop dph
0660 02072F     377            ljmp LCD_Display_Update_done
0663            378   
0663            379   LCD_Display_Update_2:
0663 B4021F     380            cjne a, #2, LCD_Display_Update_3
0666 C0E0       381            push acc
0668 7401       381            mov a, #1
066A 14         381            dec a
066B 120581     381            lcall ?Set_Cursor_1 ; Select column and row
066E D0E0       381            pop acc
0670 C083       382            push dph
0672 C082       382            push dpl
0674 C0E0       382            push acc
0676 9003E5     382            mov dptr, #String_state2
0679 120574     382            lcall ?Send_Constant_String
067C D0E0       382            pop acc
067E D082       382            pop dpl
0680 D083       382            pop dph
0682 02072F     383            ljmp LCD_Display_Update_done
0685            384   
0685            385   LCD_Display_Update_3:
0685 B4031F     386            cjne a, #3, LCD_Display_Update_4
0688 C0E0       387            push acc
068A 7401       387            mov a, #1
068C 14         387            dec a
068D 120581     387            lcall ?Set_Cursor_1 ; Select column and row
0690 D0E0       387            pop acc
0692 C083       388            push dph
0694 C082       388            push dpl
0696 C0E0       388            push acc
0698 9003F5     388            mov dptr, #String_state3
069B 120574     388            lcall ?Send_Constant_String
069E D0E0       388            pop acc
06A0 D082       388            pop dpl
06A2 D083       388            pop dph
06A4 02072F     389            ljmp LCD_Display_Update_done
06A7            390   
06A7            391   LCD_Display_Update_4:
06A7 B4041F     392            cjne a, #4, LCD_Display_Update_5
06AA C0E0       393            push acc
06AC 7401       393            mov a, #1
06AE 14         393            dec a
06AF 120581     393            lcall ?Set_Cursor_1 ; Select column and row
06B2 D0E0       393            pop acc
06B4 C083       394            push dph
06B6 C082       394            push dpl
06B8 C0E0       394            push acc
06BA 900405     394            mov dptr, #String_state4
06BD 120574     394            lcall ?Send_Constant_String
06C0 D0E0       394            pop acc
06C2 D082       394            pop dpl
06C4 D083       394            pop dph
06C6 02072F     395            ljmp LCD_Display_Update_done
06C9            396   
06C9            397   LCD_Display_Update_5:
06C9 B4051F     398            cjne a, #5, LCD_Display_Update_6
06CC C0E0       399            push acc
06CE 7401       399            mov a, #1
06D0 14         399            dec a
06D1 120581     399            lcall ?Set_Cursor_1 ; Select column and row
06D4 D0E0       399            pop acc
06D6 C083       400            push dph
06D8 C082       400            push dpl
06DA C0E0       400            push acc
06DC 900415     400            mov dptr, #String_state5
06DF 120574     400            lcall ?Send_Constant_String
06E2 D0E0       400            pop acc
06E4 D082       400            pop dpl
06E6 D083       400            pop dph
06E8 02072F     401            ljmp LCD_Display_Update_done
06EB            402   
06EB            403   LCD_Display_Update_6:
06EB B4061F     404            cjne a, #6, LCD_Display_Update_7
06EE C0E0       405            push acc
06F0 7401       405            mov a, #1
06F2 14         405            dec a
06F3 120581     405            lcall ?Set_Cursor_1 ; Select column and row
06F6 D0E0       405            pop acc
06F8 C083       406            push dph
06FA C082       406            push dpl
06FC C0E0       406            push acc
06FE 900425     406            mov dptr, #String_state6
0701 120574     406            lcall ?Send_Constant_String
0704 D0E0       406            pop acc
0706 D082       406            pop dpl
0708 D083       406            pop dph
070A 02072F     407            ljmp LCD_Display_Update_done
070D            408   
070D            409   LCD_Display_Update_7:
070D B4071F     410            cjne a, #7, LCD_Display_Update_done
0710 C0E0       411            push acc
0712 7401       411            mov a, #1
0714 14         411            dec a
0715 120581     411            lcall ?Set_Cursor_1 ; Select column and row
0718 D0E0       411            pop acc
071A C083       412            push dph
071C C082       412            push dpl
071E C0E0       412            push acc
0720 900435     412            mov dptr, #String_state7
0723 120574     412            lcall ?Send_Constant_String
0726 D0E0       412            pop acc
0728 D082       412            pop dpl
072A D083       412            pop dph
072C 02072F     413            ljmp LCD_Display_Update_done
072F            414   
072F            415   LCD_Display_Update_done:
072F D0E0       416            pop acc
0731 22         417            ret
0732            418   
0732            419   LCD_Display_Update_Temp:
0732            420            
0732            421   ;---------------------------------------------------------
0732            422   
0732            423   KEY1_DEB:
0732            424   ;non-blocking state machine for KEY1 debounce
0732 E561       425            mov a, KEY1_DEB_state
0734            426   KEY1_DEB_state0:
0734 B4000A     427            cjne a, #0, KEY1_DEB_state1
0737 20F92D     428            jb KEY.1, KEY1_DEB_done
073A 755F00     429            mov KEY1_DEB_timer, #0
073D 0561       430            inc KEY1_DEB_state
073F 8026       431            sjmp KEY1_DEB_done
0741            432   KEY1_DEB_state1:
0741 B40109     433            cjne a, #1, KEY1_DEB_state2
0744            434            ; this is the debounce state
0744 E55F       435            mov a, KEY1_DEB_timer
0746 B4321E     436            cjne a, #50, KEY1_DEB_done ; 50 ms passed?
0749 0561       437            inc KEY1_DEB_state
074B 801A       438            sjmp KEY1_DEB_done      
074D            439   KEY1_DEB_state2:
074D B4020C     440            cjne a, #2, KEY1_DEB_state3
0750 20F904     441            jb KEY.1, KEY1_DEB_state2b
0753 0561       442            inc KEY1_DEB_state
0755 8010       443            sjmp KEY1_DEB_done      
0757            444   KEY1_DEB_state2b:
0757 756100     445            mov KEY1_DEB_state, #0
075A 800B       446            sjmp KEY1_DEB_done
075C            447   KEY1_DEB_state3:
075C B40308     448            cjne a, #3, KEY1_DEB_done
075F 30F905     449            jnb KEY.1, KEY1_DEB_done
0762 D20D       450            setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
0764 756100     451            mov KEY1_DEB_state, #0  
0767            452   KEY1_DEB_done:
0767 22         453            ret
0768            454   
0768            455   ; ------------------------------------------------------------------------------
0768            456   ; Non-blocking FSM for the one second counter
0768            457   ;-------------------------------------------------------------------------------
0768            458   SEC_FSM:
0768 E562       459            mov a, SEC_FSM_state
076A            460   SEC_FSM_state0:
076A B4000C     461            cjne a, #0, SEC_FSM_state1
076D E560       462            mov a, SEC_FSM_timer
076F B4FA47     463            cjne a, #250, SEC_FSM_done ; 250 ms passed?
0772 756000     464            mov SEC_FSM_timer, #0
0775 0562       465            inc SEC_FSM_state
0777 8040       466            sjmp SEC_FSM_done
0779            467   SEC_FSM_state1:  
0779 B4010E     468            cjne a, #1, SEC_FSM_state2
077C D2E9       469            setb LEDRA.1
077E E560       470            mov a, SEC_FSM_timer
0780 B4FA36     471            cjne a, #250, SEC_FSM_done ; 250 ms passed?
0783 756000     472            mov SEC_FSM_timer, #0
0786 0562       473            inc SEC_FSM_state
0788 802F       474            sjmp SEC_FSM_done
078A            475   SEC_FSM_state2:  
078A B4020E     476            cjne a, #2, SEC_FSM_state3
078D D2EA       477            setb LEDRA.2
078F E560       478            mov a, SEC_FSM_timer
0791 B4FA25     479            cjne a, #250, SEC_FSM_done ; 250 ms passed?
0794 756000     480            mov SEC_FSM_timer, #0
0797 0562       481            inc SEC_FSM_state
0799 801E       482            sjmp SEC_FSM_done
079B            483   SEC_FSM_state3:  
079B B4031B     484            cjne a, #3, SEC_FSM_done
079E D2EB       485            setb LEDRA.3
07A0 E560       486            mov a, SEC_FSM_timer
07A2 B4FA14     487            cjne a, #250, SEC_FSM_done ; 250 ms passed?
07A5 756000     488            mov SEC_FSM_timer, #0
07A8 756200     489            mov SEC_FSM_state, #0
07AB E530       490            mov a, current_time_sec
07AD B43B05     491            cjne a, #59, IncCurrentTimeSec ; Don't let the seconds counter pass 59
07B0 753000     492            mov current_time_sec, #0
07B3 8004       493            sjmp SEC_FSM_done
07B5            494   IncCurrentTimeSec:
07B5 0530       495            inc current_time_sec
07B7 B2E8       496            cpl LEDRA.0 ; 1 Hz heartbeat LED
07B9            497   SEC_FSM_done:
07B9 22         498            ret
07BA            499   
07BA            500   ;-------------------------------------------------------------------------------
07BA            501   ; PWM
07BA            502   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
07BA            503   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
07BA            504   ; ------------------------------------------------------------------------------
07BA            505   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
07BA 100202     506            jbc one_ms_pwm_flag, pwm_wave_generator
07BD 8071       507            sjmp end_pwm_generator
07BF            508   
07BF            509   pwm_wave_generator:
07BF C200       510            clr mf
07C1            511            ; move pwm counter value into x for comparison purpose
07C1 855B32     512            mov x, pwm_counter
07C4 855C33     513            mov x+1, pwm_counter+1
07C7 855D34     514            mov x+2, pwm_counter+2
07CA 855E35     515            mov x+3, pwm_counter+3
07CD            516   
07CD 7536DB     517            mov y+0, #low (PWM_PERIOD % 0x10000) 
07D0 753705     517            mov y+1, #high(PWM_PERIOD % 0x10000) 
07D3 753800     517            mov y+2, #low (PWM_PERIOD / 0x10000) 
07D6 753900     517            mov y+3, #high(PWM_PERIOD / 0x10000) 
07D9            518   
07D9            519            ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
07D9            520            ; increase x by 1
07D9 120152     521            lcall x_eq_y 
07DC 20001D     522            jb mf, wrap_pwm_counter
07DF            523            ; x not equal 1499, increment by 1
07DF 753601     524            mov y+0, #low (1 % 0x10000) 
07E2 753700     524            mov y+1, #high(1 % 0x10000) 
07E5 753800     524            mov y+2, #low (1 / 0x10000) 
07E8 753900     524            mov y+3, #high(1 / 0x10000) 
07EB 1200D3     525            lcall add32
07EE            526            ; update pwm_counter
07EE 85325B     527            mov pwm_counter, x
07F1 85335C     528            mov pwm_counter+1, x+1
07F4 85345D     529            mov pwm_counter+2, x+2
07F7 85355E     530            mov pwm_counter+3, x+3
07FA 8018       531            sjmp set_pwm
07FC            532   
07FC            533   wrap_pwm_counter:
07FC            534            ; x equal 1499, wrap to 0
07FC 753200     535            mov x+0, #low (0 % 0x10000) 
07FF 753300     535            mov x+1, #high(0 % 0x10000) 
0802 753400     535            mov x+2, #low (0 / 0x10000) 
0805 753500     535            mov x+3, #high(0 / 0x10000) 
0808 85325B     536            mov pwm_counter, x
080B 85335C     537            mov pwm_counter+1, x+1
080E 85345D     538            mov pwm_counter+2, x+2
0811 85355E     539            mov pwm_counter+3, x+3
0814            540   
0814            541   set_pwm:
0814            542            ; compare with power_output, if pwm counter smaller than power_output, 
0814            543            ; set pwm pin high; else set pwm pin low load y with power output value
0814 855736     544            mov y, power_output
0817 855837     545            mov y+1, power_output+1
081A 855938     546            mov y+2, power_output+2
081D 855A39     547            mov y+3, power_output+3
0820            548   
0820            549            ; compare x(pwm counter) with y(power output)
0820 12011A     550            lcall x_lt_y
0823 200006     551            jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
0826            552            ;output set pwm pin low if pwm counter greater than power output
0826 C293       553            clr PWM_OUT
0828 C2EC       554            clr LEDRA.4
082A 8004       555            sjmp end_pwm_generator
082C            556   
082C            557   set_pwm_high:
082C D293       558            setb PWM_OUT
082E D2EC       559            setb LEDRA.4
0830            560   
0830            561   end_pwm_generator:
0830 22         562            ret
0831            563   
0831            564   ;-------------------------------------------------------------------------------;
0831            565   ; Temp_Compare
0831            566   ;
0831            567   ; PURPOSE:
0831            568   ;   Compare the current measured temperature against
0831            569   ;   the soak and reflow temperature setpoints.
0831            570   ;
0831            571   ; BEHAVIOR:
0831            572   ;   - If current_temp >= soak_temp   if soak_temp_reached   = 1
0831            573   ;   - If current_temp >= reflow_temp if reflow_temp_reached = 1
0831            574   ;
0831            575   ; NOTES:
0831            576   ;   - Uses 32-bit UNSIGNED comparison from math32.asm
0831            577   ;   - Comparison is done by:
0831            578   ;       x < y ?   (mf = 1)  if NOT reached
0831            579   ;       x >= y ?  (mf = 0)  if reached
0831            580   ;   - This routine ONLY SETS flags.
0831            581   ;     Clearing flags must be handled by the FSM.
0831            582   ;
0831            583   ; EXPECTED VARIABLES (DSEG / BSEG):
0831            584   ;   current_temp[4], soak_temp[4], reflow_temp[4]
0831            585   ;   x[4], y[4]
0831            586   ;   mf (math32 compare flag)
0831            587   ;   soak_temp_reached, reflow_temp_reached
0831            588   ;-------------------------------------------------------------------------------;
0831            589   Temp_Compare:
0831            590   
0831            591       ; --- ADD THESE 2 LINES ---
0831 C203       592       clr soak_temp_reached
0833 C204       593       clr reflow_temp_reached
0835            594       ; -------------------------
0835            595   
0835 C0E0       596       push acc
0837 C0D0       597       push psw
0839 C000       598       push AR0
083B C001       599       push AR1
083D C002       600       push AR2
083F            601       
083F            602   ; Check: current_temp >= soak_temp ?
083F            603       ; Copy current_temp of x (math32 operand A)
083F 783F       604       mov  R0, #current_temp
0841 7932       605       mov  R1, #x
0843 1208B7     606       lcall Copy4_Bytes_R0_to_R1
0846            607   
0846            608       ; Copy soak_temp of y (math32 operand B)
0846 7843       609       mov  R0, #soak_temp
0848 7936       610       mov  R1, #y
084A 1208B7     611       lcall Copy4_Bytes_R0_to_R1
084D            612   
084D            613       ; Perform x < y comparison
084D            614       ; mf = 1 if current_temp < soak_temp  (NOT reached)
084D            615       ; mf = 0 if current_temp >= soak_temp (REACHED)
084D 12011A     616       lcall x_lt_y
0850 200002     617       jb   mf, Temp_Soak_NotReached
0853 D203       618       setb soak_temp_reached
0855            619   
0855            620   ; Check: current_temp >= reflow_temp ?
0855            621   Temp_Soak_NotReached:
0855            622       ; Copy current_temp of x
0855 783F       623       mov  R0, #current_temp
0857 7932       624       mov  R1, #x
0859 1208B7     625       lcall Copy4_Bytes_R0_to_R1
085C            626   
085C            627       ; Copy reflow_temp of y
085C 7847       628       mov  R0, #reflow_temp
085E 7936       629       mov  R1, #y
0860 1208B7     630       lcall Copy4_Bytes_R0_to_R1
0863            631   
0863            632       ; Compare x < y again
0863 12011A     633       lcall x_lt_y
0866 200002     634       jb   mf, Temp_Reflow_NotReached
0869 D204       635       setb reflow_temp_reached
086B            636   
086B            637   Temp_Reflow_NotReached:
086B D002       638       pop  AR2
086D D001       639       pop  AR1
086F D000       640       pop  AR0
0871 D0D0       641       pop  psw
0873 D0E0       642       pop  acc
0875 22         643       ret
0876            644   ;-------------------------------------------------------------------------------;
0876            645   ; Time_Compare
0876            646   ;
0876            647   ; PURPOSE:
0876            648   ;   Compare the elapsed time against soak and reflow
0876            649   ;   time limits.
0876            650   ;
0876            651   ; BEHAVIOR:
0876            652   ;   - If current_time >= soak_time   if soak_time_reached   = 1
0876            653   ;   - If current_time >= reflow_time if reflow_time_reached = 1
0876            654   ;
0876            655   ; NOTES:
0876            656   ;   - Time values are treated as 32-bit UNSIGNED numbers
0876            657   ;     (e.g., milliseconds or seconds).
0876            658   ;   - Uses the SAME compare logic as Temp_Compare.
0876            659   ;   - This routine ONLY SETS flags.
0876            660   ;
0876            661   ; EXPECTED VARIABLES:
0876            662   ;   current_time[4], soak_time[4], reflow_time[4]
0876            663   ;   x[4], y[4]
0876            664   ;   mf, soak_time_reached, reflow_time_reached
0876            665   ;-------------------------------------------------------------------------------;
0876            666   Time_Compare:
0876 C0E0       667       push acc
0878 C0D0       668       push psw
087A C000       669       push AR0
087C C001       670       push AR1
087E C002       671       push AR2
0880            672   
0880            673   ; Check: current_time >= soak_time ?
0880            674       ; Copy current_time of x
0880 784B       675       mov  R0, #current_time
0882 7932       676       mov  R1, #x
0884 1208B7     677       lcall Copy4_Bytes_R0_to_R1
0887            678   
0887            679       ; Copy soak_time of y
0887 784F       680       mov  R0, #soak_time
0889 7936       681       mov  R1, #y
088B 1208B7     682       lcall Copy4_Bytes_R0_to_R1
088E            683   
088E            684       ; Compare elapsed time vs soak time
088E 12011A     685       lcall x_lt_y
0891 200002     686       jb   mf, Time_Soak_NotReached
0894 D206       687       setb soak_time_reached
0896            688   
0896            689   ; Check: current_time >= reflow_time ?
0896            690   Time_Soak_NotReached:
0896            691       ; Copy current_time of x
0896 784B       692       mov  R0, #current_time
0898 7932       693       mov  R1, #x
089A 1208B7     694       lcall Copy4_Bytes_R0_to_R1
089D            695   
089D            696       ; Copy reflow_time of y
089D 7853       697       mov  R0, #reflow_time
089F 7936       698       mov  R1, #y
08A1 1208B7     699       lcall Copy4_Bytes_R0_to_R1
08A4            700   
08A4            701       ; Compare elapsed time vs reflow time
08A4 12011A     702       lcall x_lt_y
08A7 200002     703       jb   mf, Time_Reflow_NotReached
08AA D207       704       setb reflow_time_reached
08AC            705   
08AC            706   Time_Reflow_NotReached:
08AC D002       707       pop  AR2
08AE D001       708       pop  AR1
08B0 D000       709       pop  AR0
08B2 D0D0       710       pop  psw
08B4 D0E0       711       pop  acc
08B6 22         712       ret
08B7            713   
08B7            714   ;-------------------------------------------------------------------------------;
08B7            715   ; Copy4_Bytes_R0_to_R1
08B7            716   ;
08B7            717   ; PURPOSE:
08B7            718   ;   Utility routine to copy a 32-bit value (4 bytes)
08B7            719   ;   from one memory location to another.
08B7            720   ;
08B7            721   ; INPUTS:
08B7            722   ;   R0 st source address
08B7            723   ;   R1 at destination address
08B7            724   ;
08B7            725   ; USES:
08B7            726   ;   R2 as loop counter
08B7            727   ;
08B7            728   ; EXAMPLE:
08B7            729   ;   mov R0, #current_temp
08B7            730   ;   mov R1, #x
08B7            731   ;   lcall Copy4_Bytes_R0_to_R1
08B7            732   ;-------------------------------------------------------------------------------;
08B7            733   Copy4_Bytes_R0_to_R1:
08B7 7A04       734       mov  R2, #4
08B9            735   Copy4_Loop:
08B9 E6         736       mov  a, @R0
08BA F7         737       mov  @R1, a
08BB 08         738       inc  R0
08BC 09         739       inc  R1
08BD DAFA       740       djnz R2, Copy4_Loop
08BF 22         741       ret
08C0            742   
08C0            743   ;-------------------------------------------------------------------------------;
08C0            744   ; Abort condition safety check Temperature time
08C0            745   ;
08C0            746   ; PURPOSE:
08C0            747   ;   Automatic cycle termination on error:
08C0            748   ;   Abort if oven fails to reach at least 50C in first 60s.
08C0            749   ;
08C0            750   ; TRIP CONDITION:
08C0            751   ;   if (current_time >= 60s) AND (current_temp < 50C)
08C0            752   ;       -> set tc_missing_abort
08C0            753   ;       -> set stop_signal
08C0            754   ;
08C0            755   ; ASSUMPTIONS:
08C0            756   ;   - current_time is in SECONDS (32-bit, little-endian)
08C0            757   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
08C0            758   ;
08C0            759   ;   the Load_Y constants accordingly.
08C0            760   ;-------------------------------------------------------------------------------;
08C0            761   Safety_Check_TC:
08C0 C0E0       762       push acc
08C2 C0D0       763       push psw
08C4 C000       764       push AR0
08C6 C001       765       push AR1
08C8 C002       766       push AR2
08CA            767   
08CA            768       ; If already aborted or startup window closed, do nothing
08CA 200E3D     769       jb   tc_missing_abort, Safety_TC_Done
08CD 300F3A     770       jnb  tc_startup_window, Safety_TC_Done
08D0            771   
08D0            772       ; Check: current_time >= 60 ?
08D0 784B       773       mov  R0, #current_time
08D2 7932       774       mov  R1, #x
08D4 1208B7     775       lcall Copy4_Bytes_R0_to_R1
08D7            776   
08D7 75363C     777            mov y+0, #low (60 % 0x10000) 
08DA 753700     777            mov y+1, #high(60 % 0x10000) 
08DD 753800     777            mov y+2, #low (60 / 0x10000) 
08E0 753900     777            mov y+3, #high(60 / 0x10000) 
08E3 12011A     778       lcall x_lt_y
08E6 200021     779       jb   mf, Safety_TC_Done        ; still < 60s  keep waiting
08E9            780   
08E9            781       ; We reached 60s: close the startup window so it won't re-check later
08E9 C20F       782       clr  tc_startup_window
08EB            783   
08EB            784       ; Now check: current_temp < 50 ?
08EB 783F       785       mov  R0, #current_temp
08ED 7932       786       mov  R1, #x
08EF 1208B7     787       lcall Copy4_Bytes_R0_to_R1
08F2            788   
08F2 753632     789            mov y+0, #low (50 % 0x10000) 
08F5 753700     789            mov y+1, #high(50 % 0x10000) 
08F8 753800     789            mov y+2, #low (50 / 0x10000) 
08FB 753900     789            mov y+3, #high(50 / 0x10000) 
08FE 12011A     790       lcall x_lt_y
0901 300006     791       jnb  mf, Safety_TC_Done        ; temp >= 50  pass
0904            792   
0904            793       ; FAIL: at 60s, still below 50C  abort
0904 D20E       794       setb tc_missing_abort
0906 D209       795       setb stop_signal
0908 C293       796       clr  PWM_OUT
090A            797   
090A            798   Safety_TC_Done:
090A D002       799       pop  AR2
090C D001       800       pop  AR1
090E D000       801       pop  AR0
0910 D0D0       802       pop  psw
0912 D0E0       803       pop  acc
0914 22         804       ret
0915            805   
0915            806   ;-------------------------------------------------------------------------------;
0915            807   ; Main Control FSM for the entire process
0915            808   ;-------------------------------------------------------------------------------;
0915            809   Control_FSM:
0915 E563       810            mov a, Control_FSM_state
0917 8005       811            sjmp Control_FSM_state0
0919            812   
0919            813   Control_FSM_state0_a:
0919 756300     814            mov Control_FSM_state, #0
091C D20C       815            setb state_change_signal
091E            816            
091E            817   Control_FSM_state0:
091E B40015     818       cjne a, #0, Control_FSM_state1
0921 209005     819       jb P1.0, Control_FSM_done_bridge
0924 120D8E     820       lcall Wait_For_P1_0_Release
0927 8001       821       sjmp Control_FSM_state1_a  
0929            822       
0929            823      
0929            824   ; BRIDGE: Local exit to help shorter jumps reach the end
0929            825   Control_FSM_done_bridge:
0929 22         826       ret
092A            827   
092A            828   Control_FSM_state1_a:
092A 0563       829            inc Control_FSM_state
092C            830            
092C 756400     831            mov Current_State, #0
092F 120C70     832            lcall Update_Screen_Full 
0932            833            
0932 D20C       834            setb state_change_signal
0934            835            
0934 E563       836            mov a, Control_FSM_state
0936            837            
0936            838   Control_FSM_state1:
0936 B40116     839       cjne a, #1, Control_FSM_state2
0939            840       ; --- ENABLE USER INPUT ---
0939 120AAE     841       lcall Check_Buttons 
093C 120AFA     842       lcall Check_Keypad
093F            843       ; ----------------------------
093F            844       
093F            845       ; FIX: Check P1.0. If Low (0/Pressed), jump to 1_b
093F 309001     846       jnb P1.0, Control_FSM_state1_b
0942 22         847       ret ; Exit if button not pressed
0943            848   
0943            849   Control_FSM_state1_b:
0943 120D8E     850       lcall Wait_For_P1_0_Release  ; Wait for finger to leave
0946 120A32     851       lcall Update_FSM_Variables   ; Save the numbers
0949 8000       852       sjmp Control_FSM_state2_a    ; GO!
094B            853   
094B            854   Control_FSM_state2_a:
094B 0563       855            inc Control_FSM_state
094D D20C       856            setb state_change_signal
094F            857   Control_FSM_state2:
094F B4020B     858            cjne a, #2, Control_FSM_state3
0952 10122E     859            jbc PB2_flag, Control_FSM_state6_a
0955 100301     860            jbc soak_temp_reached, Control_FSM_state3_a
0958 22         861            ret
0959            862   
0959            863   Control_FSM_state3_a:
0959 0563       864            inc Control_FSM_state
095B D20C       865            setb state_change_signal
095D            866   Control_FSM_state3:
095D B4030B     867            cjne a, #3, Control_FSM_state4
0960 101220     868            jbc PB2_flag, Control_FSM_state6_a
0963 100601     869            jbc soak_time_reached, Control_FSM_state4_a
0966 22         870            ret
0967            871   
0967            872   Control_FSM_state4_a:
0967 0563       873            inc Control_FSM_state   
0969 D20C       874            setb state_change_signal
096B            875   Control_FSM_state4:
096B B4040B     876            cjne a, #4, Control_FSM_state5
096E 101212     877            jbc PB2_flag, Control_FSM_state6_a
0971 100401     878            jbc reflow_temp_reached, Control_FSM_state5_a
0974 22         879            ret
0975            880   
0975            881   Control_FSM_state5_a:
0975 0563       882            inc Control_FSM_state
0977 D20C       883            setb state_change_signal
0979            884   Control_FSM_state5:
0979 B4050B     885            cjne a, #5, Control_FSM_state6
097C 101204     886            jbc PB2_flag, Control_FSM_state6_a
097F 100701     887            jbc reflow_time_reached, Control_FSM_state6_a
0982 22         888            ret
0983            889   
0983            890   Control_FSM_state6_a:
0983 0563       891            inc Control_FSM_state
0985 D20C       892            setb state_change_signal
0987            893   Control_FSM_state6:
0987 B4060F     894            cjne a, #6, Control_FSM_done
098A 100501     895            jbc cooling_temp_reached, Control_FSM_state7_a
098D 22         896            ret
098E            897   
098E            898   Control_FSM_state7_a:
098E 0563       899            inc Control_FSM_state
0990 D20C       900            setb state_change_signal
0992            901   Control_FSM_state7:
0992 B40704     902            cjne a, #7, Control_FSM_done
0995 101081     903            jbc PB0_flag, Control_FSM_state0_a
0998 22         904            ret
0999            905   
0999            906   Control_FSM_done:
0999 22         907            ret
099A            908   ;-------------------------------------------------------------------------------;
099A            909   ;         Main program.          
099A            910   ;-------------------------------------------------------------------------------;
099A            911   main:
099A            912            ; Initialization
099A 7581C0     913       mov SP, #0xC0 
099D            914   
099D            915   ; --- PORT CONFIGURATION (Changed bc old config. didn't have correct button inputs) ---
099D            916       ; P0: Odd=LCD(Out), Even=Buttons(In) 
099D            917       ; Binary: 10101010 -> Hex: 0xAA
099D 759AAA     918       mov P0MOD, #0xAA 
09A0            919   
09A0            920       ; P1: Mixed usage 
09A0            921       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
09A0            922       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
09A0            923       ; P1.0 (Unused/RX) -> Input
09A0            924       ; Binary: 11111110 -> Hex: 0xFE
09A0 759BFE     925       mov P1MOD, #0xFE
09A3            926   
09A3            927       ; P2: Row4(Out), Cols(In)
09A3            928       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
09A3            929       ; Binary: 00000001 -> Hex: 0x01
09A3 759C01     930       mov P2MOD, #0x01
09A6            931   
09A6            932       ; P3: Col4(In)
09A6            933       ; P3.0 (Col4) is In (0).
09A6 759D00     934       mov P3MOD, #0x00
09A9            935       ; Turn off all the LEDs
09A9 75E800     936       mov LEDRA, #0 ; LEDRA is bit addressable
09AC 759500     937       mov LEDRB, #0 ; LEDRB is NOT bit addresable
09AF            938   
09AF            939            ; Enable Global interrupts
09AF D2AF       940       setb EA  
09B1            941   
09B1            942            ; FSM initial states
09B1 756100     943            mov KEY1_DEB_state, #0
09B4 756200     944            mov SEC_FSM_state, #0
09B7 756300     945            mov Control_FSM_state, #0
09BA 756400     946            mov Current_State, #0
09BD            947            
09BD            948            ; FSM timers initialization
09BD 755F00     949            mov KEY1_DEB_timer, #0
09C0 756000     950            mov SEC_FSM_timer, #0
09C3            951            ; time counters initialization
09C3 753000     952            mov current_time_sec, #0
09C6 753100     953            mov current_time_minute, #0
09C9            954            ; Initialize counter to zero
09C9 755B00     955       mov pwm_counter, #0
09CC 755C00     956            mov pwm_counter+1, #0
09CF 755D00     957            mov pwm_counter+2, #0
09D2 755E00     958            mov pwm_counter+3, #0
09D5            959            ; Initialize power output
09D5 755A00     960            mov power_output+3, #0
09D8 755900     961            mov power_output+2, #0
09DB 755802     962            mov power_output+1, #02H
09DE 7557EE     963            mov power_output, #0EEH ; (initilize to 750 for testing)
09E1            964   
09E1            965            ; Clear all the flags
09E1 C20E       966            clr  tc_missing_abort
09E3 C209       967            clr  stop_signal
09E5 C210       968            clr PB0_flag
09E7 C211       969            clr PB1_flag
09E9 C212       970            clr PB2_flag
09EB C201       971            clr one_second_flag
09ED C20B       972            clr config_finish_signal
09EF C203       973            clr soak_temp_reached
09F1 C206       974            clr soak_time_reached
09F3 C204       975            clr reflow_temp_reached
09F5 C207       976            clr reflow_time_reached
09F7 C205       977            clr cooling_temp_reached
09F9 C20C       978            clr state_change_signal
09FB            979            
09FB D20C       980            setb state_change_signal
09FD            981   
09FD            982            ; Set bit
09FD D20F       983            setb tc_startup_window
09FF            984   
09FF 120456     985            lcall Timer0_Init
0A02 1204C0     986       lcall Timer2_Init
0A05 120541     987            lcall ELCD_4BIT
0A08            988            ;----- Two new lines I added to initialize the UI
0A08 120C1D     989            lcall Init_All_Buffers
0A0B 120C70     990       lcall Update_Screen_Full
0A0E            991            ;-----
0A0E 120472     992            lcall Initialize_Serial_Port
0A11            993   ;-------------------------------------------------------------------------------;
0A11            994   ; while(1) loop
0A11            995   ;-------------------------------------------------------------------------------;
0A11            996   loop:
0A11            997            ; Check the FSM for KEY1 debounce
0A11 120732     998            lcall KEY1_DEB
0A14            999            
0A14           1000            ; Added to take temp readings
0A14 120D92    1001            lcall Read_Thermocouple
0A17           1002            
0A17           1003            ; 1. Check if we reached temp (Observer)
0A17 120831    1004            lcall Temp_Compare
0A1A           1005            
0A1A           1006            ; 2. Decide heater power based on flags (Driver)
0A1A 120DE1    1007            lcall Power_Control
0A1D           1008            
0A1D 120876    1009            lcall Time_Compare
0A20           1010       
0A20 1208C0    1011            lcall Safety_Check_TC
0A23           1012   
0A23           1013   
0A23           1014            ; Check the FSM for one second counter
0A23 120768    1015            lcall SEC_FSM
0A26           1016   
0A26           1017            ; Check the FSM for the overall control flow of the reflow process
0A26 120915    1018            lcall Control_FSM
0A29           1019   
0A29           1020            ; Update the LCD display based on the current state
0A29 1205F1    1021            lcall LCD_Display_Update_func
0A2C           1022   
0A2C           1023            ; Update the pwm output for the ssr
0A2C 1207BA    1024            lcall PWM_Wave 
0A2F           1025   
0A2F           1026            ; After initialization the program stays in this 'forever' loop
0A2F 020A11    1027            ljmp loop
0A32           1028   ;-------------------------------------------------------------------------------;
0A32           1029   
0A32           1030   ; ================================================================
0A32           1031   ; UI & HELPER SUBROUTINES
0A32           1032   ; ================================================================
0A32           1033   
0A32           1034   ; ----------------------------------------------------------------
0A32           1035   ; MODULE: BRIDGE (Text to Integer Conversion)
0A32           1036   ; ----------------------------------------------------------------
0A32           1037   Update_FSM_Variables:
0A32           1038       ; --- 1. SOAK TEMP ---
0A32 7866      1039       mov R0, #Buf_Soak_Temp
0A34 120A71    1040       lcall Parse_Temp_String
0A37 8F43      1041       mov soak_temp+0, R7
0A39 754400    1042       mov soak_temp+1, #0
0A3C 754500    1043       mov soak_temp+2, #0
0A3F 754600    1044       mov soak_temp+3, #0
0A42           1045   
0A42           1046       ; --- 2. REFLOW TEMP ---
0A42 786F      1047       mov R0, #Buf_Refl_Temp
0A44 120A71    1048       lcall Parse_Temp_String
0A47 8F47      1049       mov reflow_temp+0, R7
0A49 754800    1050       mov reflow_temp+1, #0
0A4C 754900    1051       mov reflow_temp+2, #0
0A4F 754A00    1052       mov reflow_temp+3, #0
0A52           1053   
0A52           1054       ; --- 3. SOAK TIME ---
0A52 786A      1055       mov R0, #Buf_Soak_Time
0A54 120A85    1056       lcall Parse_Time_String
0A57 8F4F      1057       mov soak_time+0, R7
0A59 8E50      1058       mov soak_time+1, R6
0A5B 755100    1059       mov soak_time+2, #0
0A5E 755200    1060       mov soak_time+3, #0
0A61           1061   
0A61           1062       ; --- 4. REFLOW TIME ---
0A61 7873      1063       mov R0, #Buf_Refl_Time
0A63 120A85    1064       lcall Parse_Time_String
0A66 8F53      1065       mov reflow_time+0, R7
0A68 8E54      1066       mov reflow_time+1, R6
0A6A 755500    1067       mov reflow_time+2, #0
0A6D 755600    1068       mov reflow_time+3, #0
0A70 22        1069       ret
0A71           1070   
0A71           1071   ; --- Helper: Parse "123" to Integer ---
0A71           1072   Parse_Temp_String:
0A71 7F00      1073       mov R7, #0              ; Clear Result
0A73           1074   Parse_Temp_Loop:
0A73 E6        1075       mov A, @R0
0A74 600E      1076       jz Parse_Temp_Done      ; If Null, we are done
0A76           1077       
0A76           1078       ; Convert ASCII to Digit
0A76 C3        1079       clr C
0A77 9430      1080       subb A, #0x30
0A79 FD        1081       mov R5, A               ; R5 = New Digit
0A7A           1082       
0A7A           1083       ; Result = (Result * 10) + New Digit
0A7A EF        1084       mov A, R7
0A7B 75F00A    1085       mov B, #10
0A7E A4        1086       mul AB
0A7F 2D        1087       add A, R5
0A80 FF        1088       mov R7, A
0A81           1089       
0A81 08        1090       inc R0
0A82 80EF      1091       sjmp Parse_Temp_Loop
0A84           1092   Parse_Temp_Done:
0A84 22        1093       ret
0A85           1094   
0A85           1095   ; --- Helper: Parse "MMSS" to Seconds ---
0A85           1096   Parse_Time_String:
0A85           1097       ; 1. Minutes Tens
0A85 E6        1098       mov A, @R0
0A86 9430      1099       subb A, #0x30
0A88 75F00A    1100       mov B, #10
0A8B A4        1101       mul AB
0A8C FD        1102       mov R5, A
0A8D 08        1103       inc R0
0A8E           1104       
0A8E           1105       ; 2. Minutes Ones
0A8E E6        1106       mov A, @R0
0A8F 9430      1107       subb A, #0x30
0A91 2D        1108       add A, R5
0A92 FD        1109       mov R5, A               ; R5 = Total Minutes
0A93 08        1110       inc R0
0A94           1111       
0A94           1112       ; 3. Seconds Tens
0A94 E6        1113       mov A, @R0
0A95 9430      1114       subb A, #0x30
0A97 75F00A    1115       mov B, #10
0A9A A4        1116       mul AB
0A9B FC        1117       mov R4, A
0A9C 08        1118       inc R0
0A9D           1119       
0A9D           1120       ; 4. Seconds Ones
0A9D E6        1121       mov A, @R0
0A9E 9430      1122       subb A, #0x30
0AA0 2C        1123       add A, R4               ; R4 = Total Seconds
0AA1           1124       
0AA1           1125       ; 5. Calculate Total Seconds = (Mins * 60) + Secs
0AA1 ED        1126       mov A, R5
0AA2 75F03C    1127       mov B, #60
0AA5 A4        1128       mul AB
0AA6 2C        1129       add A, R4
0AA7 FF        1130       mov R7, A               ; Low Byte
0AA8 E5F0      1131       mov A, B
0AAA 3400      1132       addc A, #0
0AAC FE        1133       mov R6, A               ; High Byte
0AAD 22        1134       ret
0AAE           1135   
0AAE           1136   ; ----------------------------------------------------------------
0AAE           1137   ; MODULE: BUTTON HANDLER (Mode Selection)
0AAE           1138   ; ----------------------------------------------------------------
0AAE           1139   Check_Buttons:
0AAE           1140       ; --- FORCE INPUT MODE ---
0AAE           1141       ; This clears any '0' the LCD library might have written to our buttons
0AAE 438055    1142       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0AB1           1143       ; ------------------------
0AB1           1144   
0AB1 30800A    1145       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0AB4 308212    1146       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0AB7 30841A    1147       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0ABA 308622    1148       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0ABD 22        1149       ret
0ABE           1150   
0ABE           1151   Btn_Soak_Temp_Press:
0ABE 120C10    1152       lcall Wait_25ms
0AC1 756401    1153       mov Current_State, #1
0AC4 756500    1154       mov Cursor_Idx, #0
0AC7 8021      1155       sjmp Redraw_Screen
0AC9           1156   
0AC9           1157   Btn_Soak_Time_Press:
0AC9 120C10    1158       lcall Wait_25ms
0ACC 756402    1159       mov Current_State, #2
0ACF 756500    1160       mov Cursor_Idx, #0
0AD2 8016      1161       sjmp Redraw_Screen
0AD4           1162   
0AD4           1163   Btn_Refl_Temp_Press:
0AD4 120C10    1164       lcall Wait_25ms
0AD7 756403    1165       mov Current_State, #3
0ADA 756500    1166       mov Cursor_Idx, #0
0ADD 800B      1167       sjmp Redraw_Screen
0ADF           1168   
0ADF           1169   Btn_Refl_Time_Press:
0ADF 120C10    1170       lcall Wait_25ms
0AE2 756404    1171       mov Current_State, #4
0AE5 756500    1172       mov Cursor_Idx, #0
0AE8 8000      1173       sjmp Redraw_Screen
0AEA           1174   
0AEA           1175   Redraw_Screen:
0AEA 120C70    1176       lcall Update_Screen_Full
0AED           1177       ; Wait for button release
0AED 3080FD    1178       jnb BTN_SOAK_TEMP, $
0AF0 3082FD    1179       jnb BTN_SOAK_TIME, $
0AF3 3084FD    1180       jnb BTN_REFL_TEMP, $
0AF6 3086FD    1181       jnb BTN_REFL_TIME, $
0AF9 22        1182       ret
0AFA           1183   
0AFA           1184   ; ----------------------------------------------------------------
0AFA           1185   ; MODULE: KEYPAD HANDLER (Input Logic)
0AFA           1186   ; ----------------------------------------------------------------
0AFA           1187   Check_Keypad:
0AFA           1188       ; If State is 0 (Home), ignore keypad
0AFA E564      1189       mov A, Current_State
0AFC 6050      1190       jz Keypad_Exit
0AFE           1191       
0AFE 120B4F    1192       lcall Keypad_Scan
0B01 504B      1193       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0B03           1194   
0B03           1195       ; --- Check Special Keys ---
0B03 EF        1196       mov A, R7
0B04 B40E0A    1197       cjne A, #14, Check_Hash ; 14 is Star (*)
0B07           1198       
0B07           1199       ; Star Key Pressed: Reset Buffer
0B07 120C4D    1200       lcall Reset_Current_Buffer
0B0A 120C70    1201       lcall Update_Screen_Full
0B0D 756500    1202       mov Cursor_Idx, #0
0B10 22        1203       ret
0B11           1204   
0B11           1205   Check_Hash:
0B11 EF        1206       mov A, R7
0B12 B40C01    1207       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0B15 22        1208       ret                     ; Ignore Hash key
0B16           1209   
0B16           1210   Check_Numeric:
0B16           1211       ; Ensure key is 0-9
0B16 EF        1212       mov A, R7
0B17 C3        1213       clr C
0B18 940A      1214       subb A, #10
0B1A 5031      1215       jnc Symbol_Key_Ignored
0B1C           1216       
0B1C           1217       ; Convert to ASCII
0B1C EF        1218       mov A, R7
0B1D 2430      1219       add A, #0x30
0B1F FD        1220       mov R5, A
0B20           1221   
0B20           1222       ; Save to Buffer
0B20 120D77    1223       lcall Get_Current_Buffer_Addr
0B23 E565      1224       mov A, Cursor_Idx
0B25 28        1225       add A, R0
0B26 F8        1226       mov R0, A
0B27 ED        1227       mov A, R5
0B28 F6        1228       mov @R0, A
0B29 0565      1229       inc Cursor_Idx
0B2B           1230   
0B2B           1231       ; --- Check Cursor Limits ---
0B2B E564      1232       mov A, Current_State
0B2D B40102    1233       cjne A, #1, Check_Limit_Time_1
0B30 8005      1234       sjmp Limit_Temp_3
0B32           1235   
0B32           1236   Check_Limit_Time_1:
0B32 B4030B    1237       cjne A, #3, Limit_Time_4
0B35 8000      1238       sjmp Limit_Temp_3
0B37           1239   
0B37           1240   Limit_Temp_3:
0B37 E565      1241       mov A, Cursor_Idx
0B39 B4030D    1242       cjne A, #3, Do_Refresh
0B3C 1565      1243       dec Cursor_Idx          ; Stay at last digit
0B3E 8009      1244       sjmp Do_Refresh
0B40           1245   
0B40           1246   Limit_Time_4:
0B40 E565      1247       mov A, Cursor_Idx
0B42 B40404    1248       cjne A, #4, Do_Refresh
0B45 1565      1249       dec Cursor_Idx          ; Stay at last digit
0B47 8000      1250       sjmp Do_Refresh
0B49           1251   
0B49           1252   Do_Refresh:
0B49 120C70    1253       lcall Update_Screen_Full
0B4C 22        1254       ret
0B4D           1255   
0B4D           1256   Symbol_Key_Ignored:
0B4D 22        1257       ret
0B4E           1258   Keypad_Exit:
0B4E 22        1259       ret
0B4F           1260   
0B4F           1261   ; ----------------------------------------------------------------
0B4F           1262   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0B4F           1263   ; ----------------------------------------------------------------
0B4F           1264   Keypad_Scan:
0B4F           1265       ; Step 1: Check if ANY key is pressed (All Rows Low)
0B4F C292      1266       clr ROW1
0B51 C294      1267       clr ROW2
0B53 C296      1268       clr ROW3
0B55 C2A0      1269       clr ROW4
0B57 A2A2      1270       mov C, COL1
0B59 82A4      1271       anl C, COL2
0B5B 82A6      1272       anl C, COL3
0B5D 82B0      1273       anl C, COL4
0B5F 5002      1274       jnc Keypad_Debounce
0B61 C3        1275       clr C
0B62 22        1276       ret
0B63           1277   
0B63           1278   Keypad_Debounce:
0B63 120C10    1279       lcall Wait_25ms
0B66 A2A2      1280       mov C, COL1
0B68 82A4      1281       anl C, COL2
0B6A 82A6      1282       anl C, COL3
0B6C 82B0      1283       anl C, COL4
0B6E 5002      1284       jnc Keypad_Find_Row
0B70 C3        1285       clr C
0B71 22        1286       ret
0B72           1287   
0B72           1288   Keypad_Find_Row:
0B72 D292      1289       setb ROW1
0B74 D294      1290       setb ROW2
0B76 D296      1291       setb ROW3
0B78 D2A0      1292       setb ROW4
0B7A           1293   
0B7A           1294       ; Row 1
0B7A C292      1295       clr ROW1
0B7C 30A23D    1296       jnb COL1, Keypad_Key_1
0B7F 30A43E    1297       jnb COL2, Keypad_Key_2
0B82 30A63F    1298       jnb COL3, Keypad_Key_3
0B85 30B040    1299       jnb COL4, Keypad_Key_A
0B88 D292      1300       setb ROW1
0B8A           1301   
0B8A           1302       ; Row 2
0B8A C294      1303       clr ROW2
0B8C 30A23D    1304       jnb COL1, Keypad_Key_4
0B8F 30A43E    1305       jnb COL2, Keypad_Key_5
0B92 30A63F    1306       jnb COL3, Keypad_Key_6
0B95 30B040    1307       jnb COL4, Keypad_Key_B
0B98 D294      1308       setb ROW2
0B9A           1309   
0B9A           1310       ; Row 3
0B9A C296      1311       clr ROW3
0B9C 30A23D    1312       jnb COL1, Keypad_Key_7
0B9F 30A43E    1313       jnb COL2, Keypad_Key_8
0BA2 30A63F    1314       jnb COL3, Keypad_Key_9
0BA5 30B040    1315       jnb COL4, Keypad_Key_C
0BA8 D296      1316       setb ROW3
0BAA           1317   
0BAA           1318       ; Row 4
0BAA C2A0      1319       clr ROW4
0BAC 30A23D    1320       jnb COL1, Keypad_Key_Star
0BAF 30A43E    1321       jnb COL2, Keypad_Key_0
0BB2 30A63F    1322       jnb COL3, Keypad_Key_Hash
0BB5 30B040    1323       jnb COL4, Keypad_Key_D
0BB8 D2A0      1324       setb ROW4
0BBA C3        1325       clr C
0BBB 22        1326       ret
0BBC           1327   
0BBC           1328   ; Key Mapping (Renamed to avoid conflicts)
0BBC 7F01      1329   Keypad_Key_1: mov R7, #1
0BBE 803C      1330          sjmp Wait_Release
0BC0 7F02      1331   Keypad_Key_2: mov R7, #2
0BC2 8038      1332          sjmp Wait_Release
0BC4 7F03      1333   Keypad_Key_3: mov R7, #3
0BC6 8034      1334          sjmp Wait_Release
0BC8 7F0A      1335   Keypad_Key_A: mov R7, #10
0BCA 8030      1336          sjmp Wait_Release
0BCC 7F04      1337   Keypad_Key_4: mov R7, #4
0BCE 802C      1338          sjmp Wait_Release
0BD0 7F05      1339   Keypad_Key_5: mov R7, #5
0BD2 8028      1340          sjmp Wait_Release
0BD4 7F06      1341   Keypad_Key_6: mov R7, #6
0BD6 8024      1342          sjmp Wait_Release
0BD8 7F0B      1343   Keypad_Key_B: mov R7, #11
0BDA 8020      1344          sjmp Wait_Release
0BDC 7F07      1345   Keypad_Key_7: mov R7, #7
0BDE 801C      1346          sjmp Wait_Release
0BE0 7F08      1347   Keypad_Key_8: mov R7, #8
0BE2 8018      1348          sjmp Wait_Release
0BE4 7F09      1349   Keypad_Key_9: mov R7, #9
0BE6 8014      1350          sjmp Wait_Release
0BE8 7F0D      1351   Keypad_Key_C: mov R7, #13
0BEA 8010      1352          sjmp Wait_Release
0BEC 7F0E      1353   Keypad_Key_Star: mov R7, #14
0BEE 800C      1354          sjmp Wait_Release
0BF0 7F00      1355   Keypad_Key_0: mov R7, #0
0BF2 8008      1356          sjmp Wait_Release
0BF4 7F0C      1357   Keypad_Key_Hash: mov R7, #12
0BF6 8004      1358          sjmp Wait_Release
0BF8 7F0F      1359   Keypad_Key_D: mov R7, #15
0BFA 8000      1360          sjmp Wait_Release
0BFC           1361   
0BFC           1362   Wait_Release:
0BFC A2A2      1363       mov C, COL1
0BFE 82A4      1364       anl C, COL2
0C00 82A6      1365       anl C, COL3
0C02 82B0      1366       anl C, COL4
0C04 50F6      1367       jnc Wait_Release
0C06 D3        1368       setb C
0C07 D292      1369       setb ROW1
0C09 D294      1370       setb ROW2
0C0B D296      1371       setb ROW3
0C0D D2A0      1372       setb ROW4
0C0F 22        1373       ret
0C10           1374   
0C10           1375   Wait_25ms:
0C10 780F      1376       mov R0, #15
0C12 794A      1377   W25_L3: mov R1, #74
0C14 7AFA      1378   W25_L2: mov R2, #250
0C16 DAFE      1379   W25_L1: djnz R2, W25_L1
0C18 D9FA      1380       djnz R1, W25_L2
0C1A D8F6      1381       djnz R0, W25_L3
0C1C 22        1382       ret
0C1D           1383   
0C1D           1384   ; ----------------------------------------------------------------
0C1D           1385   ; MODULE: BUFFER INIT (Reset Logic)
0C1D           1386   ; ----------------------------------------------------------------
0C1D           1387   Init_All_Buffers:
0C1D 7866      1388       mov R0, #Buf_Soak_Temp
0C1F 120C32    1389       lcall Init_Temp_Template
0C22 786F      1390       mov R0, #Buf_Refl_Temp
0C24 120C32    1391       lcall Init_Temp_Template
0C27 786A      1392       mov R0, #Buf_Soak_Time
0C29 120C3E    1393       lcall Init_Time_Template
0C2C 7873      1394       mov R0, #Buf_Refl_Time
0C2E 120C3E    1395       lcall Init_Time_Template
0C31 22        1396       ret
0C32           1397   
0C32           1398   Init_Temp_Template:
0C32 7630      1399       mov @R0, #'0'
0C34 08        1400       inc R0
0C35 7630      1401       mov @R0, #'0'
0C37 08        1402       inc R0
0C38 7630      1403       mov @R0, #'0'
0C3A 08        1404       inc R0
0C3B 7600      1405       mov @R0, #0
0C3D 22        1406       ret
0C3E           1407   
0C3E           1408   Init_Time_Template:
0C3E 7630      1409       mov @R0, #'0'
0C40 08        1410       inc R0
0C41 7630      1411       mov @R0, #'0'
0C43 08        1412       inc R0
0C44 7630      1413       mov @R0, #'0'
0C46 08        1414       inc R0
0C47 7630      1415       mov @R0, #'0'
0C49 08        1416       inc R0
0C4A 7600      1417       mov @R0, #0
0C4C 22        1418       ret
0C4D           1419   
0C4D           1420   Reset_Current_Buffer:
0C4D E564      1421       mov A, Current_State
0C4F B40106    1422       cjne A, #1, Reset_Chk_2
0C52 7866      1423       mov R0, #Buf_Soak_Temp
0C54 120C32    1424       lcall Init_Temp_Template
0C57 22        1425       ret
0C58           1426   Reset_Chk_2:
0C58 B40206    1427       cjne A, #2, Reset_Chk_3
0C5B 786A      1428       mov R0, #Buf_Soak_Time
0C5D 120C3E    1429       lcall Init_Time_Template
0C60 22        1430       ret
0C61           1431   Reset_Chk_3:
0C61 B40306    1432       cjne A, #3, Reset_Chk_4
0C64 786F      1433       mov R0, #Buf_Refl_Temp
0C66 120C32    1434       lcall Init_Temp_Template
0C69 22        1435       ret
0C6A           1436   Reset_Chk_4:
0C6A 7873      1437       mov R0, #Buf_Refl_Time
0C6C 120C3E    1438       lcall Init_Time_Template
0C6F 22        1439       ret
0C70           1440   
0C70           1441   ; ----------------------------------------------------------------
0C70           1442   ; MODULE: SCREEN UPDATE (Visual Logic)
0C70           1443   ; ----------------------------------------------------------------
0C70           1444   Update_Screen_Full:
0C70 120D67    1445       lcall Clear_Screen_Func
0C73 C0E0      1446            push acc
0C75 7401      1446            mov a, #1
0C77 14        1446            dec a
0C78 120581    1446            lcall ?Set_Cursor_1 ; Select column and row
0C7B D0E0      1446            pop acc
0C7D           1447   
0C7D           1448       ; --- Draw Line 1 (Titles) ---
0C7D E564      1449       mov A, Current_State
0C7F B40013    1450       cjne A, #0, Update_State_1
0C82 C083      1451            push dph
0C84 C082      1451            push dpl
0C86 C0E0      1451            push acc
0C88 900350    1451            mov dptr, #Txt_Home
0C8B 120574    1451            lcall ?Send_Constant_String
0C8E D0E0      1451            pop acc
0C90 D082      1451            pop dpl
0C92 D083      1451            pop dph
0C94 22        1452       ret 
0C95           1453   Update_State_1:
0C95 B40114    1454       cjne A, #1, Update_State_2
0C98 C083      1455            push dph
0C9A C082      1455            push dpl
0C9C C0E0      1455            push acc
0C9E 900361    1455            mov dptr, #Txt_SoakT
0CA1 120574    1455            lcall ?Send_Constant_String
0CA4 D0E0      1455            pop acc
0CA6 D082      1455            pop dpl
0CA8 D083      1455            pop dph
0CAA 8042      1456       sjmp Draw_Temp_Format
0CAC           1457   Update_State_2:
0CAC B40214    1458       cjne A, #2, Update_State_3
0CAF C083      1459            push dph
0CB1 C082      1459            push dpl
0CB3 C0E0      1459            push acc
0CB5 900372    1459            mov dptr, #Txt_SoakTime
0CB8 120574    1459            lcall ?Send_Constant_String
0CBB D0E0      1459            pop acc
0CBD D082      1459            pop dpl
0CBF D083      1459            pop dph
0CC1 8042      1460       sjmp Draw_Time_Format
0CC3           1461   Update_State_3:
0CC3 B40314    1462       cjne A, #3, Update_State_4
0CC6 C083      1463            push dph
0CC8 C082      1463            push dpl
0CCA C0E0      1463            push acc
0CCC 900383    1463            mov dptr, #Txt_ReflT
0CCF 120574    1463            lcall ?Send_Constant_String
0CD2 D0E0      1463            pop acc
0CD4 D082      1463            pop dpl
0CD6 D083      1463            pop dph
0CD8 8014      1464       sjmp Draw_Temp_Format
0CDA           1465   Update_State_4:
0CDA C083      1466            push dph
0CDC C082      1466            push dpl
0CDE C0E0      1466            push acc
0CE0 900394    1466            mov dptr, #Txt_ReflTime
0CE3 120574    1466            lcall ?Send_Constant_String
0CE6 D0E0      1466            pop acc
0CE8 D082      1466            pop dpl
0CEA D083      1466            pop dph
0CEC 8017      1467       sjmp Draw_Time_Format
0CEE           1468   
0CEE           1469   ; --- Draw Line 2 (Values) ---
0CEE           1470   Draw_Temp_Format:
0CEE C0E0      1471            push acc
0CF0 7401      1471            mov a, #1
0CF2 14        1471            dec a
0CF3 12057F    1471            lcall ?Set_Cursor_2 ; Select column and row
0CF6 D0E0      1471            pop acc
0CF8 120D77    1472       lcall Get_Current_Buffer_Addr
0CFB 120D5D    1473       lcall Print_String_RAM
0CFE 7443      1474       mov A, #'C'
0D00 120537    1475       lcall ?WriteData
0D03 802C      1476       sjmp Restore_Cursor
0D05           1477   
0D05           1478   Draw_Time_Format:
0D05 C0E0      1479            push acc
0D07 7401      1479            mov a, #1
0D09 14        1479            dec a
0D0A 12057F    1479            lcall ?Set_Cursor_2 ; Select column and row
0D0D D0E0      1479            pop acc
0D0F 120D77    1480       lcall Get_Current_Buffer_Addr
0D12           1481       ; MM
0D12 E6        1482       mov A, @R0
0D13 120537    1483       lcall ?WriteData
0D16 08        1484       inc R0
0D17 E6        1485       mov A, @R0
0D18 120537    1486       lcall ?WriteData
0D1B 08        1487       inc R0
0D1C           1488       ; Colon
0D1C 743A      1489       mov A, #':'
0D1E 120537    1490       lcall ?WriteData
0D21           1491       ; SS
0D21 E6        1492       mov A, @R0
0D22 120537    1493       lcall ?WriteData
0D25 08        1494       inc R0
0D26 E6        1495       mov A, @R0
0D27 120537    1496       lcall ?WriteData
0D2A           1497       ; Unit
0D2A 7473      1498       mov A, #'s'
0D2C 120537    1499       lcall ?WriteData
0D2F 8000      1500       sjmp Restore_Cursor
0D31           1501   
0D31           1502   ; --- Restore Cursor Position ---
0D31           1503   Restore_Cursor:
0D31 E564      1504       mov A, Current_State
0D33 B40202    1505       cjne A, #2, Check_State_4
0D36 800D      1506       sjmp Adjust_Cursor_Time
0D38           1507   Check_State_4:
0D38 B40402    1508       cjne A, #4, Normal_Cursor
0D3B 8008      1509       sjmp Adjust_Cursor_Time
0D3D           1510   
0D3D           1511   Normal_Cursor:
0D3D E565      1512       mov A, Cursor_Idx
0D3F 24C0      1513       add A, #0xC0
0D41 12053C    1514       lcall ?WriteCommand
0D44 22        1515       ret
0D45           1516   
0D45           1517   Adjust_Cursor_Time:
0D45           1518       ; Skip the colon index (2)
0D45 E565      1519       mov A, Cursor_Idx
0D47 B40201    1520       cjne A, #2, No_Skip
0D4A 04        1521       inc A 
0D4B           1522   No_Skip:
0D4B           1523       ; Add 1 if past the colon
0D4B C3        1524       clr C
0D4C 9402      1525       subb A, #2
0D4E 4005      1526       jc No_Add
0D50 E565      1527       mov A, Cursor_Idx
0D52 04        1528       inc A
0D53 8002      1529       sjmp Final_Cursor_Set
0D55           1530   No_Add:
0D55 E565      1531       mov A, Cursor_Idx
0D57           1532   Final_Cursor_Set:
0D57 24C0      1533       add A, #0xC0
0D59 12053C    1534       lcall ?WriteCommand
0D5C 22        1535       ret
0D5D           1536   
0D5D           1537   Print_String_RAM:
0D5D E6        1538       mov A, @R0
0D5E 6006      1539       jz Print_String_Done
0D60 120537    1540       lcall ?WriteData
0D63 08        1541       inc R0
0D64 80F7      1542       sjmp Print_String_RAM
0D66           1543   Print_String_Done:
0D66 22        1544       ret
0D67           1545   
0D67           1546   Clear_Screen_Func:
0D67 7401      1547       mov A, #0x01
0D69 12053C    1548       lcall ?WriteCommand
0D6C 7A0A      1549       mov R2, #10
0D6E 120C10    1550       lcall Wait_25ms
0D71 740F      1551       mov A, #0x0F
0D73 12053C    1552       lcall ?WriteCommand
0D76 22        1553       ret
0D77           1554   
0D77           1555   Get_Current_Buffer_Addr:
0D77 E564      1556       mov A, Current_State
0D79 B40103    1557       cjne A, #1, Get_Buf_2
0D7C 7866      1558       mov R0, #Buf_Soak_Temp
0D7E 22        1559       ret
0D7F           1560   Get_Buf_2:
0D7F B40203    1561       cjne A, #2, Get_Buf_3
0D82 786A      1562       mov R0, #Buf_Soak_Time
0D84 22        1563       ret
0D85           1564   Get_Buf_3:
0D85 B40303    1565       cjne A, #3, Get_Buf_4
0D88 786F      1566       mov R0, #Buf_Refl_Temp
0D8A 22        1567       ret
0D8B           1568   Get_Buf_4:
0D8B 7873      1569       mov R0, #Buf_Refl_Time
0D8D 22        1570       ret
0D8E           1571       
0D8E           1572   ; --- Helper to prevent "Machine Gun" button presses ---
0D8E           1573   Wait_For_P1_0_Release:
0D8E 3090FD    1574       jnb P1.0, $    ; Wait here while the button is still pressed (0)
0D91 22        1575       ret
0D92           1576       
0D92           1577       
0D92           1578   ; ================================================================
0D92           1579   ; MODULE: THERMOCOUPLE ADC DRIVER (5V REFERENCE)
0D92           1580   ; ================================================================
0D92           1581   Read_Thermocouple:
0D92           1582       ; 1. Initialize ADC & Delay
0D92 75A180    1583       mov ADC_C, #0x80    ; Reset ADC
0D95 120C10    1584       lcall Wait_25ms     ; Reuse existing wait to let signals settle
0D98           1585   
0D98           1586       ; 2. Read Channel 0 (AIN0)
0D98 75A100    1587       mov ADC_C, #0x00    ; <--- Select Channel 0
0D9B           1588       
0D9B           1589       ; 3. Get the Raw Count (0 to 4095)
0D9B 85A232    1590       mov x+0, ADC_L
0D9E 85A333    1591       mov x+1, ADC_H
0DA1 753400    1592       mov x+2, #0
0DA4 753500    1593       mov x+3, #0
0DA7           1594       
0DA7           1595       ; 4. Math: Convert Count to Voltage (mV)
0DA7           1596       ; Formula: mV = (ADC_Count * 5000) / 4095
0DA7           1597       ; (Because Max Count 4095 = 5000 mV)
0DA7           1598       
0DA7 753688    1599            mov y+0, #low (5000 % 0x10000) 
0DAA 753713    1599            mov y+1, #high(5000 % 0x10000) 
0DAD 753800    1599            mov y+2, #low (5000 / 0x10000) 
0DB0 753900    1599            mov y+3, #high(5000 / 0x10000)         ; Load 5000 mV
0DB3 12018C    1600       lcall mul32         ; x = Count * 5000
0DB6           1601       
0DB6 7536FF    1602            mov y+0, #low (4095 % 0x10000) 
0DB9 75370F    1602            mov y+1, #high(4095 % 0x10000) 
0DBC 753800    1602            mov y+2, #low (4095 / 0x10000) 
0DBF 753900    1602            mov y+3, #high(4095 / 0x10000)         ; Load Max resolution
0DC2 120280    1603       lcall div32         ; x = Voltage in mV (e.g. 2500 = 2.5V)
0DC5           1604   
0DC5           1605       ; 5. Math: Convert Voltage to Temperature
0DC5           1606       ; --- CHECK YOUR OP-AMP GAIN HERE ---
0DC5           1607       ; If 1 degree C = 10mV output: Divide by 10.
0DC5           1608       ; If 1 degree C = 5mV output (AD8495): Divide by 5.
0DC5           1609       
0DC5 75360A    1610            mov y+0, #low (10 % 0x10000) 
0DC8 753700    1610            mov y+1, #high(10 % 0x10000) 
0DCB 753800    1610            mov y+2, #low (10 / 0x10000) 
0DCE 753900    1610            mov y+3, #high(10 / 0x10000)           
0DD1 120280    1611       lcall div32
0DD4           1612       
0DD4           1613       ; 6. Store Result
0DD4 85323F    1614       mov current_temp+0, x+0
0DD7 853340    1615       mov current_temp+1, x+1
0DDA 853441    1616       mov current_temp+2, x+2
0DDD 853542    1617       mov current_temp+3, x+3
0DE0           1618       
0DE0 22        1619       ret
0DE1           1620       
0DE1           1621   ; ================================================================
0DE1           1622   ; MODULE: POWER CONTROLLER (The Brain)
0DE1           1623   ; ================================================================
0DE1           1624   Power_Control:
0DE1           1625       ; Default: Turn Heat OFF (Safety)
0DE1 755700    1626       mov power_output+0, #0
0DE4 755800    1627       mov power_output+1, #0
0DE7 755900    1628       mov power_output+2, #0
0DEA 755A00    1629       mov power_output+3, #0
0DED           1630   
0DED E563      1631       mov a, Control_FSM_state
0DEF           1632   
0DEF           1633       ; --- State 2: RAMP TO SOAK ---
0DEF B40202    1634       cjne a, #2, PC_Check_Soak
0DF2           1635       ; We are ramping. We haven't reached temp yet (or FSM would have moved).
0DF2           1636       ; FULL POWER!
0DF2 8016      1637       sjmp Set_Max_Power
0DF4           1638   
0DF4           1639   PC_Check_Soak:
0DF4           1640       ; --- State 3: SOAK PHASE ---
0DF4 B40305    1641       cjne a, #3, PC_Check_Ramp_Reflow
0DF7           1642       ; Bang-Bang Control:
0DF7           1643       ; If Flag=1 (Hot enough), Power=0 (Default).
0DF7           1644       ; If Flag=0 (Too cold), Power=100%.
0DF7 20030F    1645       jb soak_temp_reached, PC_Done
0DFA 800E      1646       sjmp Set_Max_Power
0DFC           1647   
0DFC           1648   PC_Check_Ramp_Reflow:
0DFC           1649       ; --- State 4: RAMP TO REFLOW ---
0DFC B40402    1650       cjne a, #4, PC_Check_Reflow
0DFF 8009      1651       sjmp Set_Max_Power
0E01           1652   
0E01           1653   PC_Check_Reflow:
0E01           1654       ; --- State 5: REFLOW PHASE ---
0E01 B40505    1655       cjne a, #5, PC_Done
0E04 200402    1656       jb reflow_temp_reached, PC_Done
0E07 8001      1657       sjmp Set_Max_Power
0E09           1658   
0E09           1659   PC_Done:
0E09 22        1660       ret
0E0A           1661   
0E0A           1662   ; --- Helper to set 100% Power ---
0E0A           1663   Set_Max_Power:
0E0A           1664       ; Load 1000 (0x03E8) into power_output
0E0A 7557E8    1665       mov power_output+0, #0xE8
0E0D 755803    1666       mov power_output+1, #0x03
0E10 755900    1667       mov power_output+2, #0
0E13 755A00    1668       mov power_output+3, #0
0E16 22        1669       ret
0E17           1670   
0E17           1671   END
