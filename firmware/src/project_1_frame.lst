0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
<<<<<<< HEAD
0000 020BC6       6       ljmp main
=======
0000 0214FF       6       ljmp main
>>>>>>> main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 02046E      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 02132C      21       ljmp Serial_ISR
0026             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
<<<<<<< HEAD
002B 020534      24       ljmp Timer2_ISR
=======
002B 0206BC      24       ljmp Timer2_ISR
>>>>>>> main
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
<<<<<<< HEAD
0030             37   current_time_sec:     ds 1
0031             38   current_time_minute:  ds 1
0032             39   ; math32 buffer variables
0032             40   x:      ds  4
0036             41   y:      ds  4
003A             42   bcd:    ds  5
003F             43   
003F             44   current_temp: ds 4 ;
0043             45   soak_temp:    ds 4 ;
0047             46   reflow_temp:  ds 4 ;
004B             47   
004B             48   wait25_btn_cnt:    ds 1
004C             49   wait25_keypad_cnt: ds 1
004D             50   wait25_adc_cnt:    ds 1
004E             51   wait25_lcd_cnt:    ds 1
004F             52   wait25_count: ds 1  
0050             53   
0050             54   current_time: ds 4 ;
0054             55   soak_time:    ds 4 ;
0058             56   reflow_time:  ds 4 ;
005C             57   
005C             58   power_output:  ds 4 ;
0060             59   pwm_counter: ds 4 ; counter for pwm (0-1500)
0064             60   
0064             61   KEY1_DEB_timer: ds 1
0065             62   SEC_FSM_timer:  ds 1
0066             63   KEY1_DEB_state:    ds 1
0067             64   SEC_FSM_state:     ds 1
0068             65   Control_FSM_state: ds 1 
0069             66   
0069             67   Current_State:     ds 1
006A             68   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
006E             69   proportional_gain_var: ds 4 ; power gain calculated from the proportional block
0072             70   ;-- UI buffers I added (ayaan)
0072             71   Cursor_Idx: ds 1
0073             72   
0073             73   ; These hold the TEXT (ASCII) safely
0073             74   ; Digits Only + Null Terminator, got rid of C,:, and s 
0073             75   
0073             76   ; Buzzer state
0073             77   beep_count:  ds 1      ; remaining beeps
0074             78   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
0075             79   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
0077             80   
0077             81   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
0078             82   
0078             83   ; --- ADD THIS FOR GUI ---
0078             84   rx_buffer:    ds 8    ; Stores "S:150"
0080             85   rx_index:     ds 1    ; Current char index
0081             86   cmd_received: ds 1    ; Flag: 1 = Command ready
0082             87   
0080             88   iseg at 0x80
0080             89   Buf_Soak_Temp: ds 4   
0084             90   Buf_Soak_Time: ds 5   
0089             91   Buf_Refl_Temp: ds 4   
008D             92   Buf_Refl_Time: ds 5
0092             93   
0092             94   
0092             95   
0092             96   ; 46d bytes used
0092             97   
0092             98   ;-------------------------------------------------------------------------------
0092             99   ; bit operation setb, clr, jb, and jnb
0000            100   bseg
0000            101   mf:     dbit 1 ; math32 sign
0001            102   one_second_flag: dbit 1
0002            103   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003            104   
0003            105   soak_temp_reached: dbit 1
0004            106   reflow_temp_reached: dbit 1
0005            107   cooling_temp_reached: dbit 1
0006            108   
0006            109   soak_time_reached: dbit 1
0007            110   reflow_time_reached: dbit 1
0008            111   
0008            112   reset_signal: dbit 1
0009            113   stop_signal: dbit 1
000A            114   start_signal: dbit 1
000B            115   config_finish_signal: dbit 1
000C            116   
000C            117   state_change_signal: dbit 1
000D            118   
000D            119   Key1_flag: dbit 1
000E            120   
000E            121   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
000F            122   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0010            123   PB0_flag: dbit 1 ; start entire program
0011            124   PB1_flag: dbit 1 ; start soak
0012            125   PB2_flag: dbit 1 ; pause process
0013            126   
0013            127   ;buzzer beep
0013            128   one_ms_beep_flag: dbit 1
0014            129   
0014            130   ; BSEG (Bit Segment)
0014            131   wait25_active: dbit 1 ; 1 = We are currently waiting
0015            132   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0016            133   wait25_btn_active:    dbit 1
0017            134   wait25_btn_done:      dbit 1
0018            135   wait25_keypad_active: dbit 1
0019            136   wait25_keypad_done:   dbit 1
001A            137   wait25_adc_active:    dbit 1
001B            138   wait25_adc_done:      dbit 1
001C            139   wait25_lcd_active:    dbit 1
001D            140   wait25_lcd_done:      dbit 1
001E            141   
001E            142   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
001F            143   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0020            144   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0021            145   ; 11 bits used
0021            146   
0021            147   ;-------------------------------------------------------------------------------
0320            148   cseg
0320            149   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            150   BAUD           EQU 57600
0320            151   
0320            152   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            153   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            154   ; is always 12 unlike the N76E003 where is selectable.
0320            155   
0320            156   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            157   
0320            158   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            159   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            160   
0320            161   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            162   
0320            163   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            164   
0320            165   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            166   
0320            167   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            168   ; P0 is in connector JPIO.
0320            169   
0320            170   ;Added correct I/O definitions
0320            171   ;-- LCD Pins ---
0320            172   ELCD_RS equ P1.7
0320            173   ELCD_E  equ P1.1
0320            174   ELCD_D4 equ P0.7
0320            175   ELCD_D5 equ P0.5
0320            176   ELCD_D6 equ P0.3
0320            177   ELCD_D7 equ P0.1
0320            178   
0320            179   ; -- Buttons --
0320            180   BTN_SOAK_TEMP equ P0.0
0320            181   BTN_SOAK_TIME equ P0.2
0320            182   BTN_REFL_TEMP equ P0.4
0320            183   BTN_REFL_TIME equ P0.6
0320            184   
0320            185   ; --- KEYPAD ---
0320            186   ROW1 equ P1.2
0320            187   ROW2 equ P1.4
0320            188   ROW3 equ P1.6
0320            189   ROW4 equ P2.0
0320            190   COL1 equ P2.2
0320            191   COL2 equ P2.4
0320            192   COL3 equ P2.6
0320            193   COL4 equ P3.0
0320            194   
0320            195   SERVO_OUT      EQU p3.6 ; servo pin
0320            196   
0320            197   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            198   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            199   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            200   
0320            201   COLD_JUNCTION_TEMP equ 20
0320            202   MAX_POWER           EQU 1500 ; max oven power
0320            203   NO_POWER            EQU 0    ; no power
0320            204   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
0320            205   KP                          EQU 5 ; proportional gain
0320            206   
0320            207   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   208   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   209   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   210   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            211   
0350            212   ; --- UI STRINGS (REQUIRED FOR KEYPAD LOGIC), <- I can fix if duplicates
0350 53656C65   213   Txt_Home:     db 'Select Mode:    ', 0
=======
0030             37   ; time buffer 
0030             38   current_time_sec:     ds 1
0031             39   current_time_minute:  ds 1
0032             40   soak_time_sec:        ds 1
0033             41   soak_time_minute:     ds 1
0034             42   reflow_time_sec:      ds 1
0035             43   reflow_time_minute:   ds 1
0036             44   soak_end_time_sec:      ds 1
0037             45   soak_end_time_minute:   ds 1
0038             46   reflow_end_time_sec:    ds 1
0039             47   reflow_end_time_minute: ds 1
003A             48   
003A             49   ; math32 buffer variables
003A             50   x:      ds  4
003E             51   y:      ds  4
0042             52   bcd:    ds  5
0047             53   
0047             54   current_temp: ds 4 ;
004B             55   soak_temp:    ds 4 ;
004F             56   reflow_temp:  ds 4 ;
0053             57   
0053             58   wait25_btn_cnt:    ds 1
0054             59   wait25_keypad_cnt: ds 1
0055             60   wait25_adc_cnt:    ds 1
0056             61   wait25_lcd_cnt:    ds 1
0057             62   wait25_count:      ds 1
0058             63   
0058             64   power_output:  ds 4 ;
005C             65   pwm_counter:   ds 4 ; counter for pwm (0-1500_timer: ds 1
0060             66   
0060             67   Control_FSM_state: ds 1 
0061             68   Current_State:     ds 1
0062             69   
0062             70   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
0066             71   proportional_gain_var: ds 4 ; power gain calculated from the proportional block
006A             72   
006A             73   ;-- UI buffers I added (ayaan)
006A             74   Cursor_Idx: ds 1
006B             75   
006B             76   ; Buzzer module variables
006B             77   buzz_state:      ds 1   ; 0=IDLE, 1=ON, 2=OFF
006C             78   buzz_timer:      ds 1   ; counts ms within ON/OFF window
006D             79   buzz_beeps_left: ds 1   ; how many beeps remaining
006E             80   buzz_priority:   ds 1   ; 0 none, 1=state, 2=done, 3=error
006F             81   
006F             82   SEC_FSM_timer: ds 1
0070             83   SEC_FSM_state: ds 1
0071             84   ; Push buttons for globel interrupt 
0071             85   PB0_DEB_timer:  ds 1
0072             86   PB0_DEB_state:  ds 1
0073             87   PB2_DEB_timer:  ds 1
0074             88   PB2_DEB_state:  ds 1
0075             89   
0075             90   ; Buzzer state
0075             91   beep_count:  ds 1      ; remaining beeps
0076             92   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
0077             93   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
0079             94   
0079             95   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
007A             96   ; In your data section
007A             97   BTN_DEB_state: ds 1
007B             98   BTN_DEB_timer: ds 1
007C             99   BTN_DEB_id:    ds 1
007D            100   
007D            101   ; UART RX state (polling)
007D            102   rx_idx:    ds 1
007E            103   rx_ready:  ds 1
007F            104   ; 79
007F            105   
0080            106   iseg at 0x80
0080            107   Buf_Soak_Temp: ds 4   
0084            108   Buf_Soak_Time: ds 5   
0089            109   Buf_Refl_Temp: ds 4   
008D            110   Buf_Refl_Time: ds 5
0092            111   
0092            112   ; UART RX line buffer (polling) in upper RAM
0092            113   rx_buf:        ds 40    ; null-terminated command line
00BA            114   ; 
00BA            115   ;-------------------------------------------------------------------------------
00BA            116   ; bit operation setb, clr, jb, and jnb
0000            117   bseg
0000            118   mf:     dbit 1 ; math32 sign
0001            119   one_second_flag: dbit 1
0002            120   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003            121   one_ms_buzz_flag: dbit 1 ; one_millisecond_flag for buzz
0004            122   one_second_lcd_flag: dbit 1
0005            123   
0005            124   soak_temp_reached: dbit 1
0006            125   reflow_temp_reached: dbit 1
0007            126   cooling_temp_reached: dbit 1
0008            127   
0008            128   soak_time_reached: dbit 1
0009            129   reflow_time_reached: dbit 1
000A            130   
000A            131   reset_signal: dbit 1
000B            132   stop_signal: dbit 1
000C            133   start_signal_count: dbit 1
000D            134   time_count_doing_signal: dbit 1
000E            135   config_finish_signal: dbit 1
000F            136   
000F            137   state_change_signal: dbit 1
0010            138   state_change_signal_TC: dbit 1
0011            139   state_change_signal_Count: dbit 1
0012            140   state_change_beep_signal: dbit 1
0013            141   
0013            142   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
0014            143   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0015            144   
0015            145   PB0_flag: dbit 1 ; start entire program
0016            146   PB1_flag: dbit 1 ; start soak
0017            147   PB2_flag: dbit 1 ; pause process
0018            148   
0018            149   ;buzzer beep
0018            150   one_ms_beep_flag: dbit 1
0019            151   beep_error_done: dbit 1
001A            152   
001A            153   ; BSEG (Bit Segment)
001A            154   wait25_active: dbit 1 ; 1 = We are currently waiting
001B            155   wait25_done:   dbit 1 ; 1 = The 25ms has finished
001C            156   wait25_btn_active:    dbit 1
001D            157   wait25_btn_done:      dbit 1
001E            158   wait25_keypad_active: dbit 1
001F            159   wait25_keypad_done:   dbit 1
0020            160   wait25_adc_active:    dbit 1
0021            161   wait25_adc_done:      dbit 1
0022            162   wait25_lcd_active:    dbit 1
0023            163   wait25_lcd_done:      dbit 1
0024            164   
0024            165   fullscreen_update_signal: dbit 1
0025            166   
0025            167   one_second_flag_test: dbit 1
0026            168   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
0027            169   
0027            170   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0028            171   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0029            172   
0029            173   remote_config_mode: dbit 1
002A            174   ; 40 bits used
002A            175   
002A            176   ;-------------------------------------------------------------------------------
0320            177   cseg
0320            178   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            179   BAUD           EQU 57600
0320            180   
0320            181   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            182   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            183   ; is always 12 unlike the N76E003 where is selectable.
0320            184   
0320            185   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            186   
0320            187   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            188   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            189   
0320            190   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            191   
0320            192   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            193   BEEP_ON_MS          EQU 100  ; 100ms
0320            194   BEEP_OFF_MS    EQU 100  ; 100ms
0320            195   
0320            196   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            197   
0320            198   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            199   ; P0 is in connector JPIO.
0320            200   
0320            201   ;Added correct I/O definitions
0320            202   ;-- LCD Pins ---
0320            203   ELCD_RS equ P1.7
0320            204   ELCD_E  equ P1.1
0320            205   ELCD_D4 equ P0.7
0320            206   ELCD_D5 equ P0.5
0320            207   ELCD_D6 equ P0.3
0320            208   ELCD_D7 equ P0.1
0320            209   
0320            210   ; -- Buttons --
0320            211   BTN_SOAK_TEMP equ P0.0
0320            212   BTN_SOAK_TIME equ P0.2
0320            213   BTN_REFL_TEMP equ P0.4
0320            214   BTN_REFL_TIME equ P0.6
0320            215   PB0                equ P1.0
0320            216   PB2                equ P3.7
0320            217   
0320            218   ; --- PB0PAD ---
0320            219   ROW1 equ P1.2
0320            220   ROW2 equ P1.4
0320            221   ROW3 equ P1.6
0320            222   ROW4 equ P2.0
0320            223   COL1 equ P2.2
0320            224   COL2 equ P2.4
0320            225   COL3 equ P2.6
0320            226   COL4 equ P3.0
0320            227   
0320            228   SERVO_OUT      EQU P3.6 ; servo pin
0320            229   
0320            230   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            231   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            232   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            233   
0320            234   COLD_JUNCTION_TEMP equ 20
0320            235   MAX_POWER           EQU 1500 ; max oven power
0320            236   NO_POWER            EQU 0    ; no power
0320            237   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
0320            238   KP                          EQU 5 ; proportional gain
0320            239   
0320            240   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   241   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   242   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   243   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            244   
0350            245   ; --- UI STRINGS (REQUIRED FOR PB0PAD LOGIC), <- I can fix if duplicates
0350 53656C65   246   Txt_Home:     db 'Select Mode:    ', 0
>>>>>>> main
     6374204D
     6F64653A
     20202020
     00
<<<<<<< HEAD
0361 53657420   214   Txt_SoakT:    db 'Set Soak Temp   ', 0
=======
0361 53657420   247   Txt_SoakT:    db 'Set Soak Temp   ', 0
>>>>>>> main
     536F616B
     2054656D
     70202020
     00
<<<<<<< HEAD
0372 53657420   215   Txt_SoakTime: db 'Set Soak Time   ', 0
=======
0372 53657420   248   Txt_SoakTime: db 'Set Soak Time   ', 0
>>>>>>> main
     536F616B
     2054696D
     65202020
     00
<<<<<<< HEAD
0383 53657420   216   Txt_ReflT:    db 'Set Reflow Temp ', 0
=======
0383 53657420   249   Txt_ReflT:    db 'Set Reflow Temp ', 0
>>>>>>> main
     5265666C
     6F772054
     656D7020
     00
<<<<<<< HEAD
0394 53657420   217   Txt_ReflTime: db 'Set Reflow Time ', 0
=======
0394 53657420   250   Txt_ReflTime: db 'Set Reflow Time ', 0
>>>>>>> main
     5265666C
     6F772054
     696D6520
     00
<<<<<<< HEAD
03A5            218   
03A5            219   ;                       1234567890123456
03A5 53657420   220   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   221   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   222   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   223   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   224   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            225   
03E5 54656D70   226   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            227   
03EC            228   ;                     1234567890123456
03EC 52616D70   229   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   230   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   231   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   232   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   233   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   234   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C            235   
044C 20202020   236   String_Blank:    db '                ', 0
=======
03A5            251   
03A5            252   ;                       1234567890123456
03A5 53657420   253   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   254   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   255   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   256   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   257   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            258   
03E5 54656D70   259   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            260   
03EC            261   ;                     1234567890123456
03EC 52616D70   262   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   263   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   264   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   265   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   266   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   267   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C            268   
044C 20202020   269   String_Blank:    db '                ', 0
>>>>>>> main
     20202020
     20202020
     20202020
     00
<<<<<<< HEAD
045D            237   
045D            238   ;-------------------------------------------------------------------------------
045D            239   ; Timers Setting:
045D            240   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
045D            241   ;   Timer 1: Serial port baud rate 57600 generator
045D            242   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
045D            243   ;-------------------------------------------------------------------------------
045D            244   ; Routine to initialize the ISR for Timer 0 ;
045D            245   Timer0_Init:
045D E589       246       mov a, TMOD
045F 54F0       247       anl a, #0xf0 ; Clear the bits for timer 0
0461 4401       248       orl a, #0x01 ; Configure timer 0 as 16-timer
0463 F589       249       mov TMOD, a
0465 758CFD     250       mov TH0, #high(TIMER0_RELOAD)
0468 758A5A     251       mov TL0, #low(TIMER0_RELOAD)
046B            252       ; Enable the timer and interrupts
046B D2A9       253       setb ET0  ; Enable timer 0 interrupt
046D            254       ; setb TR0  (no need to open at first)
046D 22         255       ret
046E            256   ; ISR for timer 0.  Set to execute every 1/4096Hz 
046E            257   ; to generate a 2048 Hz square wave at pin P1.5 
046E            258   Timer0_ISR:
046E            259       ;clr TF0  ; According to the data sheet this is done for us already.
046E 758CFD     260       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0471 758A5A     261       mov TL0, #low(TIMER0_RELOAD)
0474 B295       262       cpl SOUND_OUT ; Connect speaker to P1.5
0476 32         263       reti
0477            264   ; -----------------------------------------------------------------------------------------------;
0477            265   
0477            266   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0477            267   Initialize_Serial_Port:
0477 C28E       268       clr TR1             ; Disable timer 1
0479 53890F     269       anl TMOD, #0x0f     ; Mask the bits for timer 1
047C 438920     270       orl TMOD, #0x20     ; Set timer 1 in 8-bit auto reload mode
047F 438780     271       orl PCON, #80H      ; Set SMOD to 1
0482 758DFD     272       mov TH1, #low(TIMER_1_RELOAD)
0485 758BFD     273       mov TL1, #low(TIMER_1_RELOAD) 
0488 D28E       274       setb TR1            ; Enable timer 1
048A 759850     275       mov SCON, #50H      ; <--- CHANGED (Mode 1, REN=1, TI=0, RI=0)
048D D2AC       276       setb ES
048F 22         277       ret
0490            278   
0490            279   ; uart sending functions
0490            280   putchar:
0490 C2AC       281       clr ES        ; 1. Turn OFF Serial Interrupts (Silence!)
0492 F599       282       mov SBUF, a   ; 2. Load the data to send
0494 3099FD     283       jnb TI, $     ; 3. Wait here until hardware says "Done" (Blocking)
0497 C299       284       clr TI        ; 4. Clear the flag manually
0499 D2AC       285       setb ES       ; 5. Turn ON Serial Interrupts again (Listen for Python)
049B 22         286       ret
049C            287   
049C            288   SendString:
049C E4         289       clr a
049D 93         290       movc a, @a+dptr
049E 6006       291       jz SendString_L1
04A0 120490     292       lcall putchar
04A3 A3         293       inc dptr
04A4 80F6       294       sjmp SendString  
04A6            295   SendString_L1:
04A6 22         296       ret
04A7            297   
04A7            298   ;-------------------------------------------------------------------------------
04A7            299   ; serial debugging
04A7            300   ; send a four byte number via serial to laptop
04A7            301   ; need to be used with python script
04A7            302   ; content needed to be sent should be stored in the varaible x
04A7            303   ;-------------------------------------------------------------------------------
04A7            304   Send32:
04A7            305       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
04A7 74AA       306       mov A, #0AAH
04A9 120490     307       lcall putchar
04AC 7455       308       mov A, #055H
04AE 120490     309       lcall putchar
04B1            310   
04B1 E535       311       mov A, x+3
04B3 120490     312       lcall putchar
04B6 E534       313       mov A, x+2
04B8 120490     314       lcall putchar
04BB E533       315       mov A, x+1
04BD 120490     316       lcall putchar
04C0 E532       317       mov A, x+0
04C2 120490     318       lcall putchar
04C5            319   
04C5 740A       320       mov A, #0AH
04C7 120490     321       lcall putchar
04CA 22         322       ret
04CB            323   ; -----------------------------------------------------------------------------------------------;
04CB            324   
04CB            325   ;-------------------------------------------------------------------------------
04CB            326   ; Serial temperature line for PuTTY/screen
04CB            327   ; Outputs: "Temp: XXXC\r\n"
04CB            328   ;-------------------------------------------------------------------------------
04CB            329   Serial_Send_Temp_Line:
04CB 9003E5     330       mov dptr, #String_temp_line
04CE 12049C     331       lcall SendString
04D1            332   
04D1            333       ; Convert current_temp to BCD (same as LCD)
04D1 853F32     334       mov x, current_temp
04D4 854033     335       mov x+1, current_temp+1
04D7 854134     336       mov x+2, current_temp+2
04DA 854235     337       mov x+3, current_temp+3
04DD 12002E     338       lcall hex2bcd
04E0            339   
04E0 7F00       340       mov R7, #0          ; printed_flag = 0
04E2            341   
04E2            342       ; Print Hundreds (if non-zero)
04E2 E53B       343       mov a, bcd+1
04E4 540F       344       anl a, #0x0F
04E6 6007       345       jz Serial_Skip_Hundreds
04E8 2430       346       add a, #0x30
04EA 120490     347       lcall putchar
04ED 7F01       348       mov R7, #1
04EF            349   Serial_Skip_Hundreds:
04EF            350   
04EF            351       ; Print Tens (if non-zero or if hundreds already printed)
04EF E53A       352       mov a, bcd+0
04F1 C4         353       swap a
04F2 540F       354       anl a, #0x0F
04F4 7003       355       jnz Serial_Print_Tens
04F6 EF         356       mov a, R7
04F7 600C       357       jz Serial_Skip_Tens
04F9            358   Serial_Print_Tens:
04F9 E53A       359       mov a, bcd+0
04FB C4         360       swap a
04FC 540F       361       anl a, #0x0F
04FE 2430       362       add a, #0x30
0500 120490     363       lcall putchar
0503 7F01       364       mov R7, #1
0505            365   Serial_Skip_Tens:
0505            366   
0505            367       ; Print Ones (always)
0505 E53A       368       mov a, bcd+0
0507 540F       369       anl a, #0x0F
0509 2430       370       add a, #0x30
050B 120490     371       lcall putchar
050E            372   
050E            373       ; Print 'C' and newline
050E 7443       374       mov a, #'C'
0510 120490     375       lcall putchar
0513 740D       376       mov a, #0DH     ; CR
0515 120490     377       lcall putchar
0518 740A       378       mov a, #0AH     ; LF
051A 120490     379       lcall putchar
051D 22         380       ret
051E            381   
051E            382   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
051E              1   ;-------------------------------------------------------------------------------
051E              2   ; Timer2_ISR.inc
051E              3   ; Contains Initialization and ISR for the 1ms System Timer
051E              4   ;-------------------------------------------------------------------------------
051E              5   
051E              6   ;-------------------------------------------------------------------------------
051E              7   ; Routine to initialize the ISR for timer 2
051E              8   ;-------------------------------------------------------------------------------
051E              9   Timer2_Init:
051E 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0521 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
0524 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
0527             13       ; Set the reload value
0527 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
052A 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
052D             16       
052D C2CF        17       clr TF2       ; Clear flag just in case
052F             18       ; Enable the timer and interrupts
052F D2AD        19       setb ET2      ; Enable timer 2 interrupt
0531 D2CA        20       setb TR2      ; Enable timer 2
0533 22          21       ret
0534             22   
0534             23   ;-------------------------------------------------------------------------------
0534             24   ; ISR for timer 2.  Runs every 1 ms
0534             25   ;-------------------------------------------------------------------------------
0534             26   Timer2_ISR:
0534 C0E0        27       push acc
0536 C0D0        28       push psw
0538             29       
0538 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
053A             31   
053A             32       ; --- 1. Existing FSM Timers ---
053A 0564        33       inc KEY1_DEB_timer
053C 0565        34       inc SEC_FSM_timer
053E D202        35       setb one_ms_pwm_flag 
0540 D213        36       setb one_ms_beep_flag
0542 D21E        37       setb one_millisecond_flag_servo
0544             38   
0544             39       ; --- 2. NEW: Non-Blocking Delay Counters ---
0544             40       
0544             41       ; A. BUTTON DELAY
0544 30160B      42       jnb wait25_btn_active, T2_Check_Keypad
0547 054B        43       inc wait25_btn_cnt
0549 E54B        44       mov a, wait25_btn_cnt
054B B41904      45       cjne a, #25, T2_Check_Keypad
054E D217        46       setb wait25_btn_done
0550 C216        47       clr wait25_btn_active
0552             48       
0552             49       ; B. KEYPAD DELAY
0552             50   T2_Check_Keypad:
0552 30180B      51       jnb wait25_keypad_active, T2_Check_ADC
0555 054C        52       inc wait25_keypad_cnt
0557 E54C        53       mov a, wait25_keypad_cnt
0559 B41904      54       cjne a, #25, T2_Check_ADC
055C D219        55       setb wait25_keypad_done
055E C218        56       clr wait25_keypad_active
0560             57   
0560             58       ; C. ADC DELAY (Thermocouple)
0560             59   T2_Check_ADC:
0560 301A0B      60       jnb wait25_adc_active, T2_Check_LCD
0563 054D        61       inc wait25_adc_cnt
0565 E54D        62       mov a, wait25_adc_cnt
0567 B41904      63       cjne a, #25, T2_Check_LCD
056A D21B        64       setb wait25_adc_done
056C C21A        65       clr wait25_adc_active
056E             66   
056E             67       ; D. LCD DELAY
056E             68   T2_Check_LCD:
056E 301C0B      69       jnb wait25_lcd_active, T2_Check_Generic
0571 054E        70       inc wait25_lcd_cnt
0573 E54E        71       mov a, wait25_lcd_cnt
0575 B41904      72       cjne a, #25, T2_Check_Generic
0578 D21D        73       setb wait25_lcd_done
057A C21C        74       clr wait25_lcd_active
057C             75   
057C             76       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
057C             77   T2_Check_Generic:
057C 30140B      78       jnb wait25_active, Timer2_ISR_done
057F 054F        79       inc wait25_count
0581 E54F        80       mov a, wait25_count
0583 B41904      81       cjne a, #25, Timer2_ISR_done
0586 D215        82       setb wait25_done      ; Tells Wait_25ms that we are finished
0588 C214        83       clr wait25_active     ; Stop counting
058A             84   
058A             85   Timer2_ISR_done:
058A D0D0        86       pop psw
058C D0E0        87       pop acc
058E 32          88       reti
058F             89            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
058F              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
058F              2   cseg
058F              3   
058F              4   ; When using a 33.333333MHz crystal clock
058F              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
058F              6   
058F              7   ;---------------------------------;
058F              8   ; Wait 40 microseconds            ;
058F              9   ;---------------------------------;
058F             10   Wait40uSec:
058F C000        11            push AR0
0591 78BE        12            mov R0, #190
0593             13   L0: 
0593 00          14            nop
0594 00          15            nop
0595 00          16            nop
0596 00          17            nop
0597 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0599 D000        19            pop AR0
059B 22          20       ret
059C             21   
059C             22   ;---------------------------------;
059C             23   ; Wait 'R2' milliseconds          ;
059C             24   ;---------------------------------;
=======
045D            270   
045D            271   ;-------------------------------------------------------------------------------
045D            272   ; Timers Setting:
045D            273   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
045D            274   ;   Timer 1: Serial port baud rate 57600 generator
045D            275   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
045D            276   ;-------------------------------------------------------------------------------
045D            277   ; Routine to initialize the ISR for Timer 0 ;
045D            278   Timer0_Init:
045D E589       279       mov a, TMOD
045F 54F0       280       anl a, #0xf0 ; Clear the bits for timer 0
0461 4401       281       orl a, #0x01 ; Configure timer 0 as 16-timer
0463 F589       282       mov TMOD, a
0465 758CFD     283       mov TH0, #high(TIMER0_RELOAD)
0468 758A5A     284       mov TL0, #low(TIMER0_RELOAD)
046B            285       ; Enable the timer and interrupts
046B D2A9       286       setb ET0  ; Enable timer 0 interrupt
046D            287       ; setb TR0  (no need to open at first)
046D 22         288       ret
046E            289   ; ISR for timer 0.  Set to execute every 1/4096Hz 
046E            290   ; to generate a 2048 Hz square wave at pin P1.5 
046E            291   Timer0_ISR:
046E            292       ;clr TF0  ; According to the data sheet this is done for us already.
046E 758CFD     293       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0471 758A5A     294       mov TL0, #low(TIMER0_RELOAD)
0474 B295       295       cpl SOUND_OUT ; Connect speaker to P1.5
0476 32         296       reti
0477            297   ; -----------------------------------------------------------------------------------------------;
0477            298   
0477            299   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0477            300   Initialize_Serial_Port:
0477            301       ; Configure serial port and baud rate
0477 C28E       302       clr TR1 ; Disable timer 1
0479 53890F     303       anl TMOD, #0x0f ; Mask the bits for timer 1
047C 438920     304       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047F 438780     305       orl PCON, #80H ; Set SMOD to 1
0482 758DFD     306       mov TH1, #low(TIMER_1_RELOAD)
0485 758BFD     307       mov TL1, #low(TIMER_1_RELOAD) 
0488 D28E       308       setb TR1 ; Enable timer 1
048A 759852     309       mov SCON, #52H
048D 22         310       ret
048E            311   
048E            312   ; uart sending functions
048E            313   putchar:
048E 109902     314       jbc TI, putchar_L1
0491 80FB       315       sjmp putchar
0493            316   putchar_L1:
0493 F599       317       mov SBUF,a
0495 22         318       ret
0496            319   
0496            320   SendString:
0496 E4         321       clr a
0497 93         322       movc a, @a+dptr
0498 6006       323       jz SendString_L1
049A 12048E     324       lcall putchar
049D A3         325       inc dptr
049E 80F6       326       sjmp SendString  
04A0            327   SendString_L1:
04A0 22         328       ret
04A1            329   
04A1            330   ;------------------------------------------------------------
04A1            331   ; getchar_nb (non-blocking)
04A1            332   ; OUT: C=1 if got byte, A=byte
04A1            333   ;      C=0 if none
04A1            334   ;------------------------------------------------------------
04A1            335   getchar_nb:
04A1 309806     336       jnb RI, rx_none
04A4 E599       337       mov A, SBUF
04A6 C298       338       clr RI
04A8 D3         339       setb C
04A9 22         340       ret
04AA            341   rx_none:
04AA C3         342       clr C
04AB 22         343       ret
04AC            344   ;------------------------------------------------------------
04AC            345   ; Serial_RX_Pump
04AC            346   ; Builds a null-terminated line in rx_buf.
04AC            347   ; Sets rx_ready=1 when a full line received.
04AC            348   ;------------------------------------------------------------
04AC            349   Serial_RX_Pump:
04AC E57E       350       mov A, rx_ready
04AE 7034       351       jnz rxp_done          ; don't overwrite unprocessed line
04B0            352   
04B0            353   rxp_more:
04B0 1204A1     354       lcall getchar_nb
04B3 502F       355       jnc rxp_done          ; no new byte
04B5 F5F0       356       mov B, A              ; save received byte
04B7            357   
04B7            358       ; ignore CR
04B7 B40D02     359       cjne A, #0DH, rxp_not_cr
04BA 80F4       360       sjmp rxp_more
04BC            361   
04BC            362   rxp_not_cr:
04BC            363       ; if LF -> finish line
04BC B40A0F     364       cjne A, #0AH, rxp_store
04BF            365   
04BF            366       ; terminate string
04BF E57D       367       mov A, rx_idx
04C1 2492       368       add A, #rx_buf
04C3 F8         369       mov R0, A
04C4 7600       370       mov @R0, #0
04C6 757E01     371       mov rx_ready, #1
04C9 757D00     372       mov rx_idx, #0
04CC 8016       373       sjmp rxp_done
04CE            374   
04CE            375   rxp_store:
04CE            376       ; store char if room (max 39 chars)
04CE E57D       377       mov A, rx_idx
04D0 B42705     378       cjne A, #39, rxp_ok
04D3 757D00     379       mov rx_idx, #0        ; overflow: reset
04D6 800C       380       sjmp rxp_done
04D8            381   
04D8            382   rxp_ok:
04D8 E57D       383       mov A, rx_idx
04DA 2492       384       add A, #rx_buf
04DC F8         385       mov R0, A
04DD E5F0       386       mov A, B
04DF F6         387       mov @R0, A
04E0 057D       388       inc rx_idx
04E2 80CC       389       sjmp rxp_more
04E4            390   
04E4            391   rxp_done:
04E4 22         392       ret
04E5            393   ; copies 3 ASCII digits to buffer at R1, null terminates
04E5            394   ; R0 = src (first digit), R1 = dst
04E5            395   Copy3DigitsToBuf:
04E5 E6         396       mov A, @R0
04E6 F7         397       mov @R1, A
04E7 08         398       inc R0
04E8 09         399       inc R1
04E9 E6         400       mov A, @R0
04EA F7         401       mov @R1, A
04EB 08         402       inc R0
04EC 09         403       inc R1
04ED E6         404       mov A, @R0
04EE F7         405       mov @R1, A
04EF 09         406       inc R1
04F0 7700       407       mov @R1, #0
04F2 22         408       ret
04F3            409   
04F3            410   ; copies 4 ASCII digits to buffer at R1, null terminates
04F3            411   Copy4DigitsToBuf:
04F3 E6         412       mov A, @R0
04F4 F7         413       mov @R1, A
04F5 08         414       inc R0
04F6 09         415       inc R1
04F7 E6         416       mov A, @R0
04F8 F7         417       mov @R1, A
04F9 08         418       inc R0
04FA 09         419       inc R1
04FB E6         420       mov A, @R0
04FC F7         421       mov @R1, A
04FD 08         422       inc R0
04FE 09         423       inc R1
04FF E6         424       mov A, @R0
0500 F7         425       mov @R1, A
0501 09         426       inc R1
0502 7700       427       mov @R1, #0
0504 22         428       ret
0505            429   
0505            430   ;------------------------------------------------------------
0505            431   ; Serial_Process_Line
0505            432   ; Handles: UI:REMOTE, RUN:0/1, S:TTT, K:MMSS, R:TTT, L:MMSS, 
0505            433   ;          CFG:APPLY, CFG {json}, SAVE:1
0505            434   ;------------------------------------------------------------
0505            435   Serial_Process_Line:
0505 E57E       436       mov A, rx_ready
0507 7001       437       jnz SPL_HAVE
0509 22         438       ret
050A            439   SPL_HAVE:
050A 757E00     440       mov rx_ready, #0
050D 7892       441       mov R0, #rx_buf
050F E6         442       mov A, @R0
0510            443   
0510            444       ; Branch by first character (with trampolines for distance)
0510 B45502     445       cjne A, #'U', SPL_not_U
0513 801C       446       sjmp do_chk_UI_REMOTE
0515            447   SPL_not_U:
0515 B45202     448       cjne A, #'R', SPL_not_R
0518 801A       449       sjmp do_chk_R_commands
051A            450   SPL_not_R:
051A B45302     451       cjne A, #'S', SPL_not_S
051D 8018       452       sjmp do_chk_S_commands
051F            453   SPL_not_S:
051F B44B02     454       cjne A, #'K', SPL_not_K
0522 8016       455       sjmp do_chk_K
0524            456   SPL_not_K:
0524 B44C02     457       cjne A, #'L', SPL_not_L
0527 8014       458       sjmp do_chk_L
0529            459   SPL_not_L:
0529 B44302     460       cjne A, #'C', SPL_not_C
052C 8012       461       sjmp do_chk_CFG_commands
052E            462   SPL_not_C:
052E 02062E     463       ljmp spl_done
0531            464   
0531            465   ; --- Trampolines ---
0531            466   do_chk_UI_REMOTE:
0531 020543     467       ljmp chk_UI_REMOTE
0534            468   do_chk_R_commands:
0534 02055D     469       ljmp chk_R_commands
0537            470   do_chk_S_commands:
0537 020597     471       ljmp chk_S_commands
053A            472   do_chk_K:
053A 0205CB     473       ljmp chk_K
053D            474   do_chk_L:
053D 0205DD     475       ljmp chk_L
0540            476   do_chk_CFG_commands:
0540 0205EF     477       ljmp chk_CFG_commands
0543            478   
0543            479   ;------------------------------------------------------------
0543            480   ; UI:REMOTE - Switch to remote control mode
0543            481   ;------------------------------------------------------------
0543            482   chk_UI_REMOTE:
0543 7892       483       mov R0, #rx_buf
0545 E6         484       mov A, @R0
0546 B45511     485       cjne A, #'U', spl_done_bridge1
0549 08         486       inc R0
054A E6         487       mov A, @R0
054B B4490C     488       cjne A, #'I', spl_done_bridge1
054E 08         489       inc R0
054F E6         490       mov A, @R0
0550 B43A07     491       cjne A, #':', spl_done_bridge1
0553 08         492       inc R0
0554 E6         493       mov A, @R0
0555 B45202     494       cjne A, #'R', spl_done_bridge1
0558            495       ; Good enough - it's UI:R...
0558 8000       496       sjmp spl_done_bridge1
055A            497   
055A            498   spl_done_bridge1:
055A 02062E     499       ljmp spl_done
055D            500   
055D            501   ;------------------------------------------------------------
055D            502   ; R commands: R:TTT (reflow temp) or RUN:0/1
055D            503   ;------------------------------------------------------------
055D            504   chk_R_commands:
055D 7892       505       mov R0, #rx_buf
055F 08         506       inc R0                     ; Point to second char
0560 E6         507       mov A, @R0
0561 B43A08     508       cjne A, #':', chk_RUN_jump ; If not ':', check for RUN
0564            509       ; It's "R:" - Reflow temperature
0564 08         510       inc R0
0565 7989       511       mov R1, #Buf_Refl_Temp
0567 1204E5     512       lcall Copy3DigitsToBuf
056A 8002       513       sjmp spl_done_bridge2
056C            514   
056C            515   chk_RUN_jump:
056C 8003       516       sjmp chk_RUN
056E            517   
056E            518   spl_done_bridge2:
056E 02062E     519       ljmp spl_done
0571            520   
0571            521   chk_RUN:
0571            522       ; Check for "RUN:"
0571 7892       523       mov R0, #rx_buf
0573 08         524       inc R0
0574 E6         525       mov A, @R0
0575 B4551C     526       cjne A, #'U', spl_done_bridge3
0578 08         527       inc R0
0579 E6         528       mov A, @R0
057A B44E17     529       cjne A, #'N', spl_done_bridge3
057D 08         530       inc R0
057E E6         531       mov A, @R0
057F B43A12     532       cjne A, #':', spl_done_bridge3
0582 08         533       inc R0
0583 E6         534       mov A, @R0
0584            535       
0584            536       ; Check for '1' or '0'
0584 B43105     537       cjne A, #'1', chk_RUN_zero
0587            538       
0587            539       ; RUN:1 - Start the process
0587 020EA4     540       ljmp Control_FSM_state2_a
058A 8008       541       sjmp spl_done_bridge3
058C            542   
058C            543   chk_RUN_zero:
058C B43005     544       cjne A, #'0', spl_done_bridge3
058F            545       ; RUN:0 - Stop the process
058F 020E77     546       ljmp Control_FSM_state0_a
0592 8000       547       sjmp spl_done_bridge3
0594            548   
0594            549   spl_done_bridge3:
0594 02062E     550       ljmp spl_done
0597            551   
0597            552   ;------------------------------------------------------------
0597            553   ; S commands: S:TTT (soak temp) or SAVE:1
0597            554   ;------------------------------------------------------------
0597            555   chk_S_commands:
0597 7892       556       mov R0, #rx_buf
0599 08         557       inc R0                     ; Point to second char
059A E6         558       mov A, @R0
059B B43A08     559       cjne A, #':', chk_SAVE_jump
059E            560       ; It's "S:" - Soak temperature
059E 08         561       inc R0
059F 7980       562       mov R1, #Buf_Soak_Temp
05A1 1204E5     563       lcall Copy3DigitsToBuf
05A4 8002       564       sjmp spl_done_bridge4
05A6            565   
05A6            566   chk_SAVE_jump:
05A6 8003       567       sjmp chk_SAVE
05A8            568   
05A8            569   spl_done_bridge4:
05A8 02062E     570       ljmp spl_done
05AB            571   
05AB            572   chk_SAVE:
05AB            573       ; Check for "SAVE:"
05AB 7892       574       mov R0, #rx_buf
05AD 08         575       inc R0
05AE E6         576       mov A, @R0
05AF B44116     577       cjne A, #'A', spl_done_bridge5
05B2 08         578       inc R0
05B3 E6         579       mov A, @R0
05B4 B45611     580       cjne A, #'V', spl_done_bridge5
05B7 08         581       inc R0
05B8 E6         582       mov A, @R0
05B9 B4450C     583       cjne A, #'E', spl_done_bridge5
05BC 08         584       inc R0
05BD E6         585       mov A, @R0
05BE B43A07     586       cjne A, #':', spl_done_bridge5
05C1 08         587       inc R0
05C2 E6         588       mov A, @R0
05C3 B43102     589       cjne A, #'1', spl_done_bridge5
05C6            590       
05C6            591       ; SAVE:1 - Save to non-volatile memory (stub)
05C6 8000       592       sjmp spl_done_bridge5
05C8            593   
05C8            594   spl_done_bridge5:
05C8 02062E     595       ljmp spl_done
05CB            596   
05CB            597   ;------------------------------------------------------------
05CB            598   ; K:MMSS - Soak time
05CB            599   ;------------------------------------------------------------
05CB            600   chk_K:
05CB 7892       601       mov R0, #rx_buf
05CD 08         602       inc R0
05CE E6         603       mov A, @R0
05CF B43A08     604       cjne A, #':', spl_done_bridge6
05D2 08         605       inc R0
05D3 7984       606       mov R1, #Buf_Soak_Time
05D5 1204F3     607       lcall Copy4DigitsToBuf
05D8 8000       608       sjmp spl_done_bridge6
05DA            609   
05DA            610   spl_done_bridge6:
05DA 02062E     611       ljmp spl_done
05DD            612   
05DD            613   ;------------------------------------------------------------
05DD            614   ; L:MMSS - Reflow time
05DD            615   ;------------------------------------------------------------
05DD            616   chk_L:
05DD 7892       617       mov R0, #rx_buf
05DF 08         618       inc R0
05E0 E6         619       mov A, @R0
05E1 B43A08     620       cjne A, #':', spl_done_bridge7
05E4 08         621       inc R0
05E5 798D       622       mov R1, #Buf_Refl_Time
05E7 1204F3     623       lcall Copy4DigitsToBuf
05EA 8000       624       sjmp spl_done_bridge7
05EC            625   
05EC            626   spl_done_bridge7:
05EC 02062E     627       ljmp spl_done
05EF            628   
05EF            629   ;------------------------------------------------------------
05EF            630   ; CFG commands: CFG:APPLY or CFG {json}
05EF            631   ;------------------------------------------------------------
05EF            632   chk_CFG_commands:
05EF 7892       633       mov R0, #rx_buf
05F1 E6         634       mov A, @R0
05F2 B44336     635       cjne A, #'C', spl_done_bridge8
05F5 08         636       inc R0
05F6 E6         637       mov A, @R0
05F7 B44631     638       cjne A, #'F', spl_done_bridge8
05FA 08         639       inc R0
05FB E6         640       mov A, @R0
05FC B4472C     641       cjne A, #'G', spl_done_bridge8
05FF 08         642       inc R0
0600 E6         643       mov A, @R0
0601            644       
0601            645       ; Check if ':' (CFG:APPLY) or ' ' (CFG {json})
0601 B43A22     646       cjne A, #':', chk_CFG_json
0604            647       
0604            648       ; It's "CFG:" - check for APPLY
0604 08         649       inc R0
0605 E6         650       mov A, @R0
0606 B44122     651       cjne A, #'A', spl_done_bridge8
0609 08         652       inc R0
060A E6         653       mov A, @R0
060B B4501D     654       cjne A, #'P', spl_done_bridge8
060E 08         655       inc R0
060F E6         656       mov A, @R0
0610 B45018     657       cjne A, #'P', spl_done_bridge8
0613 08         658       inc R0
0614 E6         659       mov A, @R0
0615 B44C13     660       cjne A, #'L', spl_done_bridge8
0618 08         661       inc R0
0619 E6         662       mov A, @R0
061A B4590E     663       cjne A, #'Y', spl_done_bridge8
061D            664       
061D            665       ; CFG:APPLY - Apply configuration
061D 120F4E     666       lcall Update_FSM_Variables
0620 D20F       667       setb state_change_signal
0622 D224       668       setb fullscreen_update_signal
0624 8005       669       sjmp spl_done_bridge8
0626            670   
0626            671   chk_CFG_json:
0626            672       ; Check for space (CFG {json})
0626 B42002     673       cjne A, #' ', spl_done_bridge8
0629            674       ; It's "CFG {...}" - JSON config (ignored)
0629 8000       675       sjmp spl_done_bridge8
062B            676   
062B            677   spl_done_bridge8:
062B 02062E     678       ljmp spl_done
062E            679   
062E            680   ;------------------------------------------------------------
062E            681   spl_done:
062E 22         682       ret
062F            683   
062F            684   
062F            685   ;-------------------------------------------------------------------------------
062F            686   ; serial debugging
062F            687   ; send a four byte number via serial to laptop
062F            688   ; need to be used with python script
062F            689   ; content needed to be sent should be stored in the varaible x
062F            690   ;-------------------------------------------------------------------------------
062F            691   Send32:
062F            692       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
062F 74AA       693       mov A, #0AAH
0631 12048E     694       lcall putchar
0634 7455       695       mov A, #055H
0636 12048E     696       lcall putchar
0639            697   
0639 E53D       698       mov A, x+3
063B 12048E     699       lcall putchar
063E E53C       700       mov A, x+2
0640 12048E     701       lcall putchar
0643 E53B       702       mov A, x+1
0645 12048E     703       lcall putchar
0648 E53A       704       mov A, x+0
064A 12048E     705       lcall putchar
064D            706   
064D 740A       707       mov A, #0AH
064F 12048E     708       lcall putchar
0652 22         709       ret
0653            710   ; -----------------------------------------------------------------------------------------------;
0653            711   
0653            712   ;-------------------------------------------------------------------------------
0653            713   ; Serial temperature line for PuTTY/screen
0653            714   ; Outputs: "Temp: XXXC\r\n"
0653            715   ;-------------------------------------------------------------------------------
0653            716   Serial_Send_Temp_Line:
0653 9003E5     717       mov dptr, #String_temp_line
0656 120496     718       lcall SendString
0659            719   
0659            720       ; Convert current_temp to BCD (same as LCD)
0659 85473A     721       mov x, current_temp
065C 85483B     722       mov x+1, current_temp+1
065F 85493C     723       mov x+2, current_temp+2
0662 854A3D     724       mov x+3, current_temp+3
0665 12002E     725       lcall hex2bcd
0668            726   
0668 7F00       727       mov R7, #0          ; printed_flag = 0
066A            728   
066A            729       ; Print Hundreds (if non-zero)
066A E543       730       mov a, bcd+1
066C 540F       731       anl a, #0x0F
066E 6007       732       jz Serial_Skip_Hundreds
0670 2430       733       add a, #0x30
0672 12048E     734       lcall putchar
0675 7F01       735       mov R7, #1
0677            736   Serial_Skip_Hundreds:
0677            737   
0677            738       ; Print Tens (if non-zero or if hundreds already printed)
0677 E542       739       mov a, bcd+0
0679 C4         740       swap a
067A 540F       741       anl a, #0x0F
067C 7003       742       jnz Serial_Print_Tens
067E EF         743       mov a, R7
067F 600C       744       jz Serial_Skip_Tens
0681            745   Serial_Print_Tens:
0681 E542       746       mov a, bcd+0
0683 C4         747       swap a
0684 540F       748       anl a, #0x0F
0686 2430       749       add a, #0x30
0688 12048E     750       lcall putchar
068B 7F01       751       mov R7, #1
068D            752   Serial_Skip_Tens:
068D            753   
068D            754       ; Print Ones (always)
068D E542       755       mov a, bcd+0
068F 540F       756       anl a, #0x0F
0691 2430       757       add a, #0x30
0693 12048E     758       lcall putchar
0696            759   
0696            760       ; Print 'C' and newline
0696 7443       761       mov a, #'C'
0698 12048E     762       lcall putchar
069B 740D       763       mov a, #0DH     ; CR
069D 12048E     764       lcall putchar
06A0 740A       765       mov a, #0AH     ; LF
06A2 12048E     766       lcall putchar
06A5 22         767       ret
06A6            768   
06A6            769   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
06A6              1   ;-------------------------------------------------------------------------------
06A6              2   ; Timer2_ISR.inc
06A6              3   ; Contains Initialization and ISR for the 1ms System Timer
06A6              4   ;-------------------------------------------------------------------------------
06A6              5   
06A6              6   ;-------------------------------------------------------------------------------
06A6              7   ; Routine to initialize the ISR for timer 2
06A6              8   ;-------------------------------------------------------------------------------
06A6              9   Timer2_Init:
06A6 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
06A9 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
06AC 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
06AF             13       ; Set the reload value
06AF 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
06B2 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
06B5             16       
06B5 C2CF        17       clr TF2       ; Clear flag just in case
06B7             18       ; Enable the timer and interrupts
06B7 D2AD        19       setb ET2      ; Enable timer 2 interrupt
06B9 D2CA        20       setb TR2      ; Enable timer 2
06BB 22          21       ret
06BC             22   
06BC             23   ;-------------------------------------------------------------------------------
06BC             24   ; ISR for timer 2.  Runs every 1 ms
06BC             25   ;-------------------------------------------------------------------------------
06BC             26   Timer2_ISR:
06BC C0E0        27       push acc
06BE C0D0        28       push psw
06C0             29       
06C0 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
06C2             31   
06C2             32       ; --- 1. Existing Non-Blocking Seconds Increment and Periphals Debounce Timers ---
06C2 056F        33       inc SEC_FSM_timer
06C4 D202        34       setb one_ms_pwm_flag 
06C6 D203        35            setb one_ms_buzz_flag
06C8 D218        36       setb one_ms_beep_flag
06CA D226        37       setb one_millisecond_flag_servo
06CC             38     
06CC 0571        39       inc PB0_DEB_timer
06CE 0573        40       inc PB2_DEB_timer
06D0 057B        41       inc BTN_DEB_timer
06D2             42   
06D2             43       ; --- 2. NEW: Non-Blocking Delay Counters ---
06D2             44       ; A. BUTTON DELAY
06D2 301C0B      45       jnb wait25_btn_active, T2_Check_Keypad
06D5 0553        46       inc wait25_btn_cnt
06D7 E553        47       mov a, wait25_btn_cnt
06D9 B41904      48       cjne a, #25, T2_Check_Keypad
06DC D21D        49       setb wait25_btn_done
06DE C21C        50       clr wait25_btn_active
06E0             51       
06E0             52       ; B. KEYPAD DELAY
06E0             53   T2_Check_Keypad:
06E0 301E0B      54       jnb wait25_keypad_active, T2_Check_ADC
06E3 0554        55       inc wait25_keypad_cnt
06E5 E554        56       mov a, wait25_keypad_cnt
06E7 B41904      57       cjne a, #25, T2_Check_ADC
06EA D21F        58       setb wait25_keypad_done
06EC C21E        59       clr wait25_keypad_active
06EE             60   
06EE             61       ; C. ADC DELAY (Thermocouple)
06EE             62   T2_Check_ADC:
06EE 30200B      63       jnb wait25_adc_active, T2_Check_LCD
06F1 0555        64       inc wait25_adc_cnt
06F3 E555        65       mov a, wait25_adc_cnt
06F5 B41904      66       cjne a, #25, T2_Check_LCD
06F8 D221        67       setb wait25_adc_done
06FA C220        68       clr wait25_adc_active
06FC             69   
06FC             70       ; D. LCD DELAY
06FC             71   T2_Check_LCD:
06FC 30220B      72       jnb wait25_lcd_active, T2_Check_Generic
06FF 0556        73       inc wait25_lcd_cnt
0701 E556        74       mov a, wait25_lcd_cnt
0703 B41904      75       cjne a, #25, T2_Check_Generic
0706 D223        76       setb wait25_lcd_done
0708 C222        77       clr wait25_lcd_active
070A             78   
070A             79       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
070A             80   T2_Check_Generic:
070A 301A0B      81       jnb wait25_active, Timer2_ISR_done
070D 0557        82       inc wait25_count
070F E557        83       mov a, wait25_count
0711 B41904      84       cjne a, #25, Timer2_ISR_done
0714 D21B        85       setb wait25_done      ; Tells Wait_25ms that we are finished
0716 C21A        86       clr wait25_active     ; Stop counting
0718             87   
0718             88   Timer2_ISR_done:
0718 D0D0        89       pop psw
071A D0E0        90       pop acc
071C 32          91       reti
071D             92            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
071D              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
071D              2   cseg
071D              3   
071D              4   ; When using a 33.333333MHz crystal clock
071D              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
071D              6   
071D              7   ;---------------------------------;
071D              8   ; Wait 40 microseconds            ;
071D              9   ;---------------------------------;
071D             10   Wait40uSec:
071D C000        11            push AR0
071F 78BE        12            mov R0, #190
0721             13   L0: 
0721 00          14            nop
0722 00          15            nop
0723 00          16            nop
0724 00          17            nop
0725 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0727 D000        19            pop AR0
0729 22          20       ret
072A             21   
072A             22   ;---------------------------------;
072A             23   ; Wait 'R2' milliseconds          ;
072A             24   ;---------------------------------;
>>>>>>> main
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
<<<<<<< HEAD
059C             31   
059C             32   ?Wait_Milli_Seconds:
059C C000        33            push AR0
059E C001        34            push AR1
05A0 7932        35   L3: mov R1, #50
05A2 78DF        36   L2: mov R0, #223
05A4 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
05A6 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
05A8 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
05AA D001        40       pop AR1
05AC D000        41       pop AR0
05AE 22          42       ret
05AF             43            
05AF             44   ;---------------------------------;
05AF             45   ; Toggles the 'E' pin in the LCD  ;
05AF             46   ;---------------------------------;
05AF             47   ELCD_pulse:
05AF D291        48            setb ELCD_E
05B1 12058F      49            lcall Wait40uSec
05B4 C291        50            clr ELCD_E
05B6 12058F      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
05B9 22          52       ret
05BA             53   
05BA             54   ;---------------------------------;
05BA             55   ; Writes acc to LCD in 4-bit mode ;
05BA             56   ;---------------------------------;
05BA             57   ELCD_byte:
05BA             58            ; Write high 4 bits first
05BA A2E7        59            mov c, ACC.7
05BC 9281        60            mov ELCD_D7, c
05BE A2E6        61            mov c, ACC.6
05C0 9283        62            mov ELCD_D6, c
05C2 A2E5        63            mov c, ACC.5
05C4 9285        64            mov ELCD_D5, c
05C6 A2E4        65            mov c, ACC.4
05C8 9287        66            mov ELCD_D4, c
05CA 1205AF      67       lcall ELCD_pulse
05CD             68            ; Write low 4 bits next
05CD A2E3        69            mov c, ACC.3
05CF 9281        70            mov ELCD_D7, c
05D1 A2E2        71            mov c, ACC.2
05D3 9283        72            mov ELCD_D6, c
05D5 A2E1        73            mov c, ACC.1
05D7 9285        74            mov ELCD_D5, c
05D9 A2E0        75            mov c, ACC.0
05DB 9287        76            mov ELCD_D4, c
05DD 1205AF      77       lcall ELCD_pulse
05E0 22          78            ret
05E1             79   
05E1             80   ;---------------------------------;
05E1             81   ; Write data to LCD               ;
05E1             82   ;---------------------------------;
=======
072A             31   
072A             32   ?Wait_Milli_Seconds:
072A C000        33            push AR0
072C C001        34            push AR1
072E 7932        35   L3: mov R1, #50
0730 78DF        36   L2: mov R0, #223
0732 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
0734 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
0736 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
0738 D001        40       pop AR1
073A D000        41       pop AR0
073C 22          42       ret
073D             43            
073D             44   ;---------------------------------;
073D             45   ; Toggles the 'E' pin in the LCD  ;
073D             46   ;---------------------------------;
073D             47   ELCD_pulse:
073D D291        48            setb ELCD_E
073F 12071D      49            lcall Wait40uSec
0742 C291        50            clr ELCD_E
0744 12071D      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
0747 22          52       ret
0748             53   
0748             54   ;---------------------------------;
0748             55   ; Writes acc to LCD in 4-bit mode ;
0748             56   ;---------------------------------;
0748             57   ELCD_byte:
0748             58            ; Write high 4 bits first
0748 A2E7        59            mov c, ACC.7
074A 9281        60            mov ELCD_D7, c
074C A2E6        61            mov c, ACC.6
074E 9283        62            mov ELCD_D6, c
0750 A2E5        63            mov c, ACC.5
0752 9285        64            mov ELCD_D5, c
0754 A2E4        65            mov c, ACC.4
0756 9287        66            mov ELCD_D4, c
0758 12073D      67       lcall ELCD_pulse
075B             68            ; Write low 4 bits next
075B A2E3        69            mov c, ACC.3
075D 9281        70            mov ELCD_D7, c
075F A2E2        71            mov c, ACC.2
0761 9283        72            mov ELCD_D6, c
0763 A2E1        73            mov c, ACC.1
0765 9285        74            mov ELCD_D5, c
0767 A2E0        75            mov c, ACC.0
0769 9287        76            mov ELCD_D4, c
076B 12073D      77       lcall ELCD_pulse
076E 22          78            ret
076F             79   
076F             80   ;---------------------------------;
076F             81   ; Write data to LCD               ;
076F             82   ;---------------------------------;
>>>>>>> main
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
<<<<<<< HEAD
05E1             87            
05E1             88   ?WriteData:
05E1 D297        89            setb ELCD_RS
05E3 0205BA      90            ljmp ELCD_byte
05E6             91   
05E6             92   ;---------------------------------;
05E6             93   ; Write command to LCD            ;
05E6             94   ;---------------------------------;
=======
076F             87            
076F             88   ?WriteData:
076F D297        89            setb ELCD_RS
0771 020748      90            ljmp ELCD_byte
0774             91   
0774             92   ;---------------------------------;
0774             93   ; Write command to LCD            ;
0774             94   ;---------------------------------;
>>>>>>> main
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
<<<<<<< HEAD
05E6             99   
05E6            100   ?WriteCommand:
05E6 C297       101            clr ELCD_RS
05E8 0205BA     102            ljmp ELCD_byte
05EB            103   
05EB            104   ;---------------------------------;
05EB            105   ; Configure LCD in 4-bit mode     ;
05EB            106   ;---------------------------------;
05EB            107   ELCD_4BIT:
05EB C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
05ED            109            ;clr ELCD_RW  ; RW forced to zero
05ED            110            
05ED            111            ; After power on, let the LCD start up before initializing
05ED C002       112            push AR2
05EF 7A28       112            mov R2, #40
05F1 12059C     112            lcall ?Wait_Milli_Seconds
05F4 D002       112            pop AR2
05F6            113            
05F6            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
05F6 7433       115            mov a, #0x33
05F8 1205E6     115            lcall ?WriteCommand
05FB 7433       116            mov a, #0x33
05FD 1205E6     116            lcall ?WriteCommand
0600 7432       117            mov a, #0x32
0602 1205E6     117            lcall ?WriteCommand ; change to 4-bit mode
0605            118   
0605            119            ; Configure the LCD
0605 7428       120            mov a, #0x28
0607 1205E6     120            lcall ?WriteCommand
060A 740C       121            mov a, #0x0c
060C 1205E6     121            lcall ?WriteCommand
060F 7401       122            mov a, #0x01
0611 1205E6     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
0614            123   
0614            124       ;Wait for the clear screen command to finish.
0614 C002       125            push AR2
0616 7A02       125            mov R2, #2
0618 12059C     125            lcall ?Wait_Milli_Seconds
061B D002       125            pop AR2
061D 22         126       ret
061E            127   
061E            128   ;---------------------------------;
061E            129   ; Send a constant string to LCD   ;
061E            130   ;---------------------------------;
=======
0774             99   
0774            100   ?WriteCommand:
0774 C297       101            clr ELCD_RS
0776 020748     102            ljmp ELCD_byte
0779            103   
0779            104   ;---------------------------------;
0779            105   ; Configure LCD in 4-bit mode     ;
0779            106   ;---------------------------------;
0779            107   ELCD_4BIT:
0779 C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
077B            109            ;clr ELCD_RW  ; RW forced to zero
077B            110            
077B            111            ; After power on, let the LCD start up before initializing
077B C002       112            push AR2
077D 7A28       112            mov R2, #40
077F 12072A     112            lcall ?Wait_Milli_Seconds
0782 D002       112            pop AR2
0784            113            
0784            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
0784 7433       115            mov a, #0x33
0786 120774     115            lcall ?WriteCommand
0789 7433       116            mov a, #0x33
078B 120774     116            lcall ?WriteCommand
078E 7432       117            mov a, #0x32
0790 120774     117            lcall ?WriteCommand ; change to 4-bit mode
0793            118   
0793            119            ; Configure the LCD
0793 7428       120            mov a, #0x28
0795 120774     120            lcall ?WriteCommand
0798 740C       121            mov a, #0x0c
079A 120774     121            lcall ?WriteCommand
079D 7401       122            mov a, #0x01
079F 120774     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
07A2            123   
07A2            124       ;Wait for the clear screen command to finish.
07A2 C002       125            push AR2
07A4 7A02       125            mov R2, #2
07A6 12072A     125            lcall ?Wait_Milli_Seconds
07A9 D002       125            pop AR2
07AB 22         126       ret
07AC            127   
07AC            128   ;---------------------------------;
07AC            129   ; Send a constant string to LCD   ;
07AC            130   ;---------------------------------;
>>>>>>> main
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
<<<<<<< HEAD
061E            141   
061E            142   ?Send_Constant_String:
061E E4         143       clr a
061F 93         144       movc a, @a+dptr
0620 6006       145       jz ?Send_Constant_String_Done
0622 1205E1     146       lcall ?WriteData
0625 A3         147       inc dptr
0626 80F6       148       sjmp ?Send_Constant_String
0628            149   ?Send_Constant_String_Done:
0628 22         150       ret  
0629            151   
0629            152   ;---------------------------------;
0629            153   ; Set LCD cursor at row, column   ;
0629            154   ;---------------------------------;
=======
07AC            141   
07AC            142   ?Send_Constant_String:
07AC E4         143       clr a
07AD 93         144       movc a, @a+dptr
07AE 6006       145       jz ?Send_Constant_String_Done
07B0 12076F     146       lcall ?WriteData
07B3 A3         147       inc dptr
07B4 80F6       148       sjmp ?Send_Constant_String
07B6            149   ?Send_Constant_String_Done:
07B6 22         150       ret  
07B7            151   
07B7            152   ;---------------------------------;
07B7            153   ; Set LCD cursor at row, column   ;
07B7            154   ;---------------------------------;
>>>>>>> main
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
<<<<<<< HEAD
0629            162   
0629            163   ?Set_Cursor_2:
0629 4440       164            orl a, #01000000B
062B            165   ?Set_Cursor_1:
062B 4480       166            orl a, #10000000B
062D 0205E6     167            ljmp ?WriteCommand ; Select column and row
0630            168   
0630            169   ;---------------------------------;
0630            170   ; Display a BCD number in the LCD ;
0630            171   ;---------------------------------;
=======
07B7            162   
07B7            163   ?Set_Cursor_2:
07B7 4440       164            orl a, #01000000B
07B9            165   ?Set_Cursor_1:
07B9 4480       166            orl a, #10000000B
07BB 020774     167            ljmp ?WriteCommand ; Select column and row
07BE            168   
07BE            169   ;---------------------------------;
07BE            170   ; Display a BCD number in the LCD ;
07BE            171   ;---------------------------------;
>>>>>>> main
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
<<<<<<< HEAD
0630            178   
0630            179   ?Display_BCD:
0630 C0E0       180            push acc
0632            181            ; Write most significant digit
0632 E8         182            mov a, r0
0633 C4         183            swap a
0634 540F       184            anl a, #0fh
0636 4430       185            orl a, #30h
0638 1205E1     186            lcall ?WriteData
063B            187            ; write least significant digit
063B E8         188            mov a, r0
063C 540F       189            anl a, #0fh
063E 4430       190            orl a, #30h
0640 1205E1     191            lcall ?WriteData
0643 D0E0       192            pop acc
0645 22         193            ret
0646            194   
0646            195   ;------------------------------------;
0646            196   ; Display a char in the LCD          ;
0646            197   ;------------------------------------;
=======
07BE            178   
07BE            179   ?Display_BCD:
07BE C0E0       180            push acc
07C0            181            ; Write most significant digit
07C0 E8         182            mov a, r0
07C1 C4         183            swap a
07C2 540F       184            anl a, #0fh
07C4 4430       185            orl a, #30h
07C6 12076F     186            lcall ?WriteData
07C9            187            ; write least significant digit
07C9 E8         188            mov a, r0
07CA 540F       189            anl a, #0fh
07CC 4430       190            orl a, #30h
07CE 12076F     191            lcall ?WriteData
07D1 D0E0       192            pop acc
07D3 22         193            ret
07D4            194   
07D4            195   ;------------------------------------;
07D4            196   ; Display a char in the LCD          ;
07D4            197   ;------------------------------------;
>>>>>>> main
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
<<<<<<< HEAD
0646            204   
0646            385            ;-----------------------------------------------------------------------------------------------;
0646            386   
0646            387   ;-------------------------------------------------------------------------------
0646            388   ; Display Function for 7-segment displays       
0646            389   ;-------------------------------------------------------------------------------
0646            390   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0646            391   T_7seg:
0646 C0F9A4B0   392       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
064B 9282F880   393       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
0650 8883C6A1   394       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0656            395   
0656            396   ; Displays a BCD number pased in R0 in HEX5-HEX0
0656            397   Display_BCD_7_Seg_HEX10:
0656 900646     398       mov dptr, #T_7seg
0659 E8         399       mov a, R0
065A C4         400       swap a
065B 540F       401       anl a, #0FH
065D 93         402       movc a, @a+dptr
065E F592       403       mov HEX1, a
0660 E8         404       mov a, R0
0661 540F       405       anl a, #0FH
0663 93         406       movc a, @a+dptr
0664 F591       407       mov HEX0, a
0666 22         408       ret
0667            409   
0667            410   Display_BCD_7_Seg_HEX32:
0667 900646     411       mov dptr, #T_7seg
066A E8         412       mov a, R0
066B C4         413       swap a
066C 540F       414       anl a, #0FH
066E 93         415       movc a, @a+dptr
066F F594       416       mov HEX3, a
0671 E8         417       mov a, R0
0672 540F       418       anl a, #0FH
0674 93         419       movc a, @a+dptr
0675 F593       420       mov HEX2, a
0677 22         421       ret
0678            422   
0678            423   Display_BCD_7_Seg_HEX54:
0678 900646     424       mov dptr, #T_7seg
067B E8         425       mov a, R0
067C C4         426       swap a
067D 540F       427       anl a, #0FH
067F 93         428       movc a, @a+dptr
0680 F58F       429       mov HEX5, a
0682 E8         430       mov a, R0
0683 540F       431       anl a, #0FH
0685 93         432       movc a, @a+dptr
0686 F58E       433       mov HEX4, a
0688 22         434       ret
0689            435   
0689            436   ; The 8-bit hex number passed in the accumulator is converted to
0689            437   ; BCD and stored in [R1, R0]
0689            438   Hex_to_bcd_8bit:
0689 75F064     439       mov b, #100
068C 84         440       div ab
068D F9         441       mov R1, a   ; After dividing, a has the 100s
068E E5F0       442       mov a, b    ; Remainder is in register b
0690 75F00A     443       mov b, #10
0693 84         444       div ab ; The tens are stored in a, the units are stored in b 
0694 C4         445       swap a
0695 54F0       446       anl a, #0xf0
0697 45F0       447       orl a, b
0699 F8         448       mov R0, a
069A 22         449       ret
069B            450   ;-------------------------------------------------------------------------------
069B            451   ; Display Function for LCD                      
069B            452   ;-------------------------------------------------------------------------------
069B            453   LCD_Print_2Digits:
069B 120689     454       lcall Hex_to_bcd_8bit
069E E8         455       mov a, R0
069F C4         456       swap a
06A0 540F       457       anl a, #0x0F
06A2 2430       458       add a, #0x30
06A4 1205E1     459       lcall ?WriteData
06A7 E8         460       mov a, R0
06A8 540F       461       anl a, #0x0F
06AA 2430       462       add a, #0x30
06AC 1205E1     463       lcall ?WriteData
06AF 22         464       ret
06B0            465   
06B0            466   LCD_Display_Update_func:
06B0 C0E0       467       push acc
06B2            468       
06B2            469       ; ==========================================
06B2            470       ; PART 1: STATIC TEXT (Title)
06B2            471       ; Runs ONLY when the state changes
06B2            472       ; ==========================================
06B2            473       
06B2            474       ; [FIX] "Trampoline" logic for long distance jump
06B2            475       ; If signal is SET (1), we stay here and update.
06B2            476       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
06B2 200C03     477       jb state_change_signal, Do_Static_Update
06B5 0207EE     478       ljmp Check_Live_Update
06B8            479   
06B8            480   Do_Static_Update:
06B8 C20C       481       clr state_change_signal
06BA            482       
06BA            483       ; State Changed: Clear Screen and Write Title
06BA 121005     484       lcall Clear_Screen_Func
06BD E568       485       mov a, Control_FSM_state
06BF            486       
06BF            487       ; State 0: Welcome
06BF B4003B     488       cjne a, #0, LCD_Check_1
06C2 C0E0       489            push acc
06C4 7401       489            mov a, #1
06C6 14         489            dec a
06C7 12062B     489            lcall ?Set_Cursor_1 ; Select column and row
06CA D0E0       489            pop acc
06CC C083       490            push dph
06CE C082       490            push dpl
06D0 C0E0       490            push acc
06D2 900330     490            mov dptr, #String_state0_1
06D5 12061E     490            lcall ?Send_Constant_String
06D8 D0E0       490            pop acc
06DA D082       490            pop dpl
06DC D083       490            pop dph
06DE C0E0       491            push acc
06E0 7401       491            mov a, #1
06E2 14         491            dec a
06E3 120629     491            lcall ?Set_Cursor_2 ; Select column and row
06E6 D0E0       491            pop acc
06E8 C083       492            push dph
06EA C082       492            push dpl
06EC C0E0       492            push acc
06EE 900340     492            mov dptr, #String_state0_2
06F1 12061E     492            lcall ?Send_Constant_String
06F4 D0E0       492            pop acc
06F6 D082       492            pop dpl
06F8 D083       492            pop dph
06FA 0207EB     493       ljmp LCD_Done_Bridge ; Exit
06FD            494   
06FD            495   LCD_Check_1: ; Setup
06FD B4011F     496       cjne a, #1, LCD_Check_2
0700 C0E0       497            push acc
0702 7401       497            mov a, #1
0704 14         497            dec a
0705 12062B     497            lcall ?Set_Cursor_1 ; Select column and row
0708 D0E0       497            pop acc
070A C083       498            push dph
070C C082       498            push dpl
070E C0E0       498            push acc
0710 9003A5     498            mov dptr, #String_state1
0713 12061E     498            lcall ?Send_Constant_String
0716 D0E0       498            pop acc
0718 D082       498            pop dpl
071A D083       498            pop dph
071C 0207EB     499       ljmp LCD_Done_Bridge
071F            500   
071F            501   LCD_Check_2: ; Ramp to Soak
071F B4021F     502       cjne a, #2, LCD_Check_3
0722 C0E0       503            push acc
0724 7401       503            mov a, #1
0726 14         503            dec a
0727 12062B     503            lcall ?Set_Cursor_1 ; Select column and row
072A D0E0       503            pop acc
072C C083       504            push dph
072E C082       504            push dpl
0730 C0E0       504            push acc
0732 9003EC     504            mov dptr, #String_state2
0735 12061E     504            lcall ?Send_Constant_String
0738 D0E0       504            pop acc
073A D082       504            pop dpl
073C D083       504            pop dph
073E 02080E     505       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
0741            506   
0741            507   LCD_Check_3: ; Soak
0741 B4031F     508       cjne a, #3, LCD_Check_4
0744 C0E0       509            push acc
0746 7401       509            mov a, #1
0748 14         509            dec a
0749 12062B     509            lcall ?Set_Cursor_1 ; Select column and row
074C D0E0       509            pop acc
074E C083       510            push dph
0750 C082       510            push dpl
0752 C0E0       510            push acc
0754 9003FC     510            mov dptr, #String_state3
0757 12061E     510            lcall ?Send_Constant_String
075A D0E0       510            pop acc
075C D082       510            pop dpl
075E D083       510            pop dph
0760 02080E     511       ljmp LCD_Update_Temp_Value
0763            512   
0763            513   LCD_Check_4: ; Ramp to Peak
0763 B4041F     514       cjne a, #4, LCD_Check_5
0766 C0E0       515            push acc
0768 7401       515            mov a, #1
076A 14         515            dec a
076B 12062B     515            lcall ?Set_Cursor_1 ; Select column and row
076E D0E0       515            pop acc
0770 C083       516            push dph
0772 C082       516            push dpl
0774 C0E0       516            push acc
0776 90040C     516            mov dptr, #String_state4
0779 12061E     516            lcall ?Send_Constant_String
077C D0E0       516            pop acc
077E D082       516            pop dpl
0780 D083       516            pop dph
0782 02080E     517       ljmp LCD_Update_Temp_Value
0785            518   
0785            519   LCD_Check_5: ; Reflow
0785 B4051F     520       cjne a, #5, LCD_Check_6
0788 C0E0       521            push acc
078A 7401       521            mov a, #1
078C 14         521            dec a
078D 12062B     521            lcall ?Set_Cursor_1 ; Select column and row
0790 D0E0       521            pop acc
0792 C083       522            push dph
0794 C082       522            push dpl
0796 C0E0       522            push acc
0798 90041C     522            mov dptr, #String_state5
079B 12061E     522            lcall ?Send_Constant_String
079E D0E0       522            pop acc
07A0 D082       522            pop dpl
07A2 D083       522            pop dph
07A4 02080E     523       ljmp LCD_Update_Temp_Value
07A7            524   
07A7            525   LCD_Check_6: ; Cooling
07A7 B4061F     526       cjne a, #6, LCD_Check_7
07AA C0E0       527            push acc
07AC 7401       527            mov a, #1
07AE 14         527            dec a
07AF 12062B     527            lcall ?Set_Cursor_1 ; Select column and row
07B2 D0E0       527            pop acc
07B4 C083       528            push dph
07B6 C082       528            push dpl
07B8 C0E0       528            push acc
07BA 90042C     528            mov dptr, #String_state6
07BD 12061E     528            lcall ?Send_Constant_String
07C0 D0E0       528            pop acc
07C2 D082       528            pop dpl
07C4 D083       528            pop dph
07C6 02080E     529       ljmp LCD_Update_Temp_Value
07C9            530   
07C9            531   LCD_Check_7: ; Done
07C9            532       ; [FIX] Check distance safe logic for State 7
07C9 B4071F     533       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
07CC C0E0       534            push acc
07CE 7401       534            mov a, #1
07D0 14         534            dec a
07D1 12062B     534            lcall ?Set_Cursor_1 ; Select column and row
07D4 D0E0       534            pop acc
07D6 C083       535            push dph
07D8 C082       535            push dpl
07DA C0E0       535            push acc
07DC 90043C     535            mov dptr, #String_state7
07DF 12061E     535            lcall ?Send_Constant_String
07E2 D0E0       535            pop acc
07E4 D082       535            pop dpl
07E6 D083       535            pop dph
07E8 0207EB     536       ljmp LCD_Done_Bridge
07EB            537   
07EB            538   ; Local bridge to reach the far-away LCD_Done
07EB            539   LCD_Done_Bridge:
07EB 02086F     540       ljmp LCD_Done
07EE            541   
07EE            542   ; ==========================================
07EE            543   ; PART 2: DYNAMIC VALUES (Temperature)
07EE            544   ; Runs every time 'one_second_flag' is set
07EE            545   ; ==========================================
07EE            546   Check_Live_Update:
07EE 3001FA     547       jnb one_second_flag, LCD_Done_Bridge
07F1 C201       548       clr one_second_flag
07F3            549       
07F3            550       ; Only update temp for States 2, 3, 4, 5, 6
07F3 E568       551       mov a, Control_FSM_state
07F5 B40202     552       cjne a, #2, Check_St3
07F8 8014       553       sjmp LCD_Update_Temp_Value
07FA            554   Check_St3:
07FA B40302     555       cjne a, #3, Check_St4
07FD 800F       556       sjmp LCD_Update_Temp_Value
07FF            557   Check_St4:
07FF B40402     558       cjne a, #4, Check_St5
0802 800A       559       sjmp LCD_Update_Temp_Value
0804            560   Check_St5:
0804 B40502     561       cjne a, #5, Check_St6
0807 8005       562       sjmp LCD_Update_Temp_Value
0809            563   Check_St6:
0809 B40663     564       cjne a, #6, LCD_Done
080C 8000       565       sjmp LCD_Update_Temp_Value
080E            566   
080E            567   ; --- HELPER: Prints "XXX C" on Line 2 ---
080E            568   LCD_Update_Temp_Value:
080E C0E0       569            push acc
0810 7401       569            mov a, #1
0812 14         569            dec a
0813 120629     569            lcall ?Set_Cursor_2 ; Select column and row
0816 D0E0       569            pop acc
0818            570       
0818            571       ; Convert current_temp to BCD
0818 853F32     572       mov x, current_temp
081B 854033     573       mov x+1, current_temp+1
081E 854134     574       mov x+2, current_temp+2
0821 854235     575       mov x+3, current_temp+3
0824 12002E     576       lcall hex2bcd
0827            577   
0827            578       ; Update HEX2-HEX0 with temperature
0827 120872     579       lcall Update_HEX_Temp
082A            580       
082A            581       ; Print Hundreds
082A E53B       582       mov a, bcd+1
082C 540F       583       anl a, #0x0F
082E 2430       584       add a, #0x30
0830 1205E1     585       lcall ?WriteData
0833            586       
0833            587       ; Print Tens
0833 E53A       588       mov a, bcd+0
0835 C4         589       swap a
0836 540F       590       anl a, #0x0F
0838 2430       591       add a, #0x30
083A 1205E1     592       lcall ?WriteData
083D            593       
083D            594       ; Print Ones
083D E53A       595       mov a, bcd+0
083F 540F       596       anl a, #0x0F
0841 2430       597       add a, #0x30
0843 1205E1     598       lcall ?WriteData
0846            599       
0846            600       ; Print 'C'
0846 7443       601       mov a, #'C'
0848 1205E1     602       lcall ?WriteData
084B            603       
084B            604       ; Clear remaining line space (prevents garbage)
084B 7420       605       mov a, #' '
084D 1205E1     606       lcall ?WriteData
0850 1205E1     607       lcall ?WriteData
0853            608   
0853            609       ; Print time MM:SS at bottom right
0853 C0E0       610            push acc
0855 740C       610            mov a, #12
0857 14         610            dec a
0858 120629     610            lcall ?Set_Cursor_2 ; Select column and row
085B D0E0       610            pop acc
085D E531       611       mov a, current_time_minute
085F 12069B     612       lcall LCD_Print_2Digits
0862 743A       613       mov a, #':'
0864 1205E1     614       lcall ?WriteData
0867 E530       615       mov a, current_time_sec
0869 12069B     616       lcall LCD_Print_2Digits
086C            617   
086C            618       ; Mirror temp to serial (PuTTY/screen)
086C 1204CB     619       lcall Serial_Send_Temp_Line
086F            620   
086F            621   LCD_Done:
086F D0E0       622       pop acc
0871 22         623       ret
0872            624   ;---------------------------------------------------------
0872            625   
0872            626   ;-------------------------------------------------------------------------------
0872            627   ; Update HEX2-HEX0 with temperature (3 digits)
0872            628   ;-------------------------------------------------------------------------------
0872            629   Update_HEX_Temp:
0872 900646     630       mov dptr, #T_7seg
0875            631       ; Hundreds -> HEX2
0875 E53B       632       mov a, bcd+1
0877 540F       633       anl a, #0x0F
0879 93         634       movc a, @a+dptr
087A F593       635       mov HEX2, a
087C            636       ; Tens -> HEX1
087C E53A       637       mov a, bcd+0
087E C4         638       swap a
087F 540F       639       anl a, #0x0F
0881 93         640       movc a, @a+dptr
0882 F592       641       mov HEX1, a
0884            642       ; Ones -> HEX0
0884 E53A       643       mov a, bcd+0
0886 540F       644       anl a, #0x0F
0888 93         645       movc a, @a+dptr
0889 F591       646       mov HEX0, a
088B 22         647       ret
088C            648   
088C            649   KEY1_DEB:
088C            650   ;non-blocking state machine for KEY1 debounce
088C E566       651       mov a, KEY1_DEB_state
088E            652   KEY1_DEB_state0:
088E B4000A     653       cjne a, #0, KEY1_DEB_state1
0891 20F92D     654       jb KEY.1, KEY1_DEB_done
0894 756400     655       mov KEY1_DEB_timer, #0
0897 0566       656       inc KEY1_DEB_state
0899 8026       657       sjmp KEY1_DEB_done
089B            658   KEY1_DEB_state1:
089B B40109     659       cjne a, #1, KEY1_DEB_state2
089E            660       ; this is the debounce state
089E E564       661       mov a, KEY1_DEB_timer
08A0 B4321E     662       cjne a, #50, KEY1_DEB_done ; 50 ms passed?
08A3 0566       663       inc KEY1_DEB_state
08A5 801A       664       sjmp KEY1_DEB_done  
08A7            665   KEY1_DEB_state2:
08A7 B4020C     666       cjne a, #2, KEY1_DEB_state3
08AA 20F904     667       jb KEY.1, KEY1_DEB_state2b
08AD 0566       668       inc KEY1_DEB_state
08AF 8010       669       sjmp KEY1_DEB_done  
08B1            670   KEY1_DEB_state2b:
08B1 756600     671       mov KEY1_DEB_state, #0
08B4 800B       672       sjmp KEY1_DEB_done
08B6            673   KEY1_DEB_state3:
08B6 B40308     674       cjne a, #3, KEY1_DEB_done
08B9 30F905     675       jnb KEY.1, KEY1_DEB_done
08BC D20D       676       setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
08BE 756600     677       mov KEY1_DEB_state, #0  
08C1            678   KEY1_DEB_done:
08C1 22         679       ret
08C2            680   ; ------------------------------------------------------------------------------
08C2            681   ; Non-blocking FSM for the one second counter
08C2            682   ;-------------------------------------------------------------------------------
08C2            683   SEC_FSM:
08C2 E567       684       mov a, SEC_FSM_state
08C4            685   SEC_FSM_state0:
08C4 B4000C     686       cjne a, #0, SEC_FSM_state1
08C7 E565       687       mov a, SEC_FSM_timer
08C9 B4FA4B     688       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08CC 756500     689       mov SEC_FSM_timer, #0
08CF 0567       690       inc SEC_FSM_state
08D1 8044       691       sjmp SEC_FSM_done
08D3            692   SEC_FSM_state1: 
08D3 B4010E     693       cjne a, #1, SEC_FSM_state2
08D6 D2E9       694       setb LEDRA.1
08D8 E565       695       mov a, SEC_FSM_timer
08DA B4FA3A     696       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08DD 756500     697       mov SEC_FSM_timer, #0
08E0 0567       698       inc SEC_FSM_state
08E2 8033       699       sjmp SEC_FSM_done
08E4            700   SEC_FSM_state2: 
08E4 B4020E     701       cjne a, #2, SEC_FSM_state3
08E7 D2EA       702       setb LEDRA.2
08E9 E565       703       mov a, SEC_FSM_timer
08EB B4FA29     704       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08EE 756500     705       mov SEC_FSM_timer, #0
08F1 0567       706       inc SEC_FSM_state
08F3 8022       707       sjmp SEC_FSM_done
08F5            708   SEC_FSM_state3: 
08F5 B4031F     709       cjne a, #3, SEC_FSM_done
08F8 D2EB       710       setb LEDRA.3
08FA E565       711       mov a, SEC_FSM_timer
08FC B4FA18     712       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08FF 756500     713       mov SEC_FSM_timer, #0
0902 756700     714       mov SEC_FSM_state, #0
0905            715       
0905            716       ; --- 1 Second has passed! ---
0905 D201       717       setb one_second_flag
0907            718       
0907 E530       719       mov a, current_time_sec
0909 B43B07     720       cjne a, #59, IncCurrentTimeSec 
090C            721       
090C            722       ; --- FIX: 59s -> 0s AND Increment Minute ---
090C 753000     723       mov current_time_sec, #0
090F 0531       724       inc current_time_minute    ; <--- YOU WERE MISSING THIS!
0911            725       ; -------------------------------------------
0911            726       
0911 8004       727       sjmp SEC_FSM_done
0913            728   
0913            729   IncCurrentTimeSec:
0913 0530       730       inc current_time_sec
0915 B2E8       731       cpl LEDRA.0 
0917            732   SEC_FSM_done:
0917 22         733       ret
0918            734   ;-------------------------------------------------------------------------------
0918            735   ; PWM
0918            736   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0918            737   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0918            738   ; ------------------------------------------------------------------------------
0918            739   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0918 100202     740       jbc one_ms_pwm_flag, pwm_wave_generator
091B 8071       741       sjmp end_pwm_generator
091D            742   
091D            743   pwm_wave_generator:
091D C200       744       clr mf
091F            745       ; move pwm counter value into x for comparison purpose
091F 856032     746       mov x, pwm_counter
0922 856133     747       mov x+1, pwm_counter+1
0925 856234     748       mov x+2, pwm_counter+2
0928 856335     749       mov x+3, pwm_counter+3
092B            750   
092B 7536DB     751            mov y+0, #low (PWM_PERIOD % 0x10000) 
092E 753705     751            mov y+1, #high(PWM_PERIOD % 0x10000) 
0931 753800     751            mov y+2, #low (PWM_PERIOD / 0x10000) 
0934 753900     751            mov y+3, #high(PWM_PERIOD / 0x10000) 
0937            752   
0937            753       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0937            754       ; increase x by 1
0937 120152     755       lcall x_eq_y 
093A 20001D     756       jb mf, wrap_pwm_counter
093D            757       ; x not equal 1499, increment by 1
093D 753601     758            mov y+0, #low (1 % 0x10000) 
0940 753700     758            mov y+1, #high(1 % 0x10000) 
0943 753800     758            mov y+2, #low (1 / 0x10000) 
0946 753900     758            mov y+3, #high(1 / 0x10000) 
0949 1200D3     759       lcall add32
094C            760       ; update pwm_counter
094C 853260     761       mov pwm_counter, x
094F 853361     762       mov pwm_counter+1, x+1
0952 853462     763       mov pwm_counter+2, x+2
0955 853563     764       mov pwm_counter+3, x+3
0958 8018       765       sjmp set_pwm
095A            766   
095A            767   wrap_pwm_counter:
095A            768       ; x equal 1499, wrap to 0
095A 753200     769            mov x+0, #low (0 % 0x10000) 
095D 753300     769            mov x+1, #high(0 % 0x10000) 
0960 753400     769            mov x+2, #low (0 / 0x10000) 
0963 753500     769            mov x+3, #high(0 / 0x10000) 
0966 853260     770       mov pwm_counter, x
0969 853361     771       mov pwm_counter+1, x+1
096C 853462     772       mov pwm_counter+2, x+2
096F 853563     773       mov pwm_counter+3, x+3
0972            774   
0972            775   set_pwm:
0972            776       ; compare with power_output, if pwm counter smaller than power_output, 
0972            777       ; set pwm pin high; else set pwm pin low load y with power output value
0972 855C36     778       mov y, power_output
0975 855D37     779       mov y+1, power_output+1
0978 855E38     780       mov y+2, power_output+2
097B 855F39     781       mov y+3, power_output+3
097E            782   
097E            783       ; compare x(pwm counter) with y(power output)
097E 12011A     784       lcall x_lt_y
0981 200006     785       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
0984            786       ;output set pwm pin low if pwm counter greater than power output
0984 C293       787       clr PWM_OUT
0986 C2EC       788       clr LEDRA.4
0988 8004       789       sjmp end_pwm_generator
098A            790   
098A            791   set_pwm_high:
098A D293       792       setb PWM_OUT
098C D2EC       793       setb LEDRA.4
098E            794   
098E            795   end_pwm_generator:
098E 22         796       ret
098F            797   
098F            798   ;-------------------------------------------------------------------------------;
098F            799   ; Temp_Compare
098F            800   ; Checks if we have reached the user's target temperatures.
098F            801   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
098F            802   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
098F            803   ;-------------------------------------------------------------------------------;
098F            804   Temp_Compare:
098F            805       ; Reset flags initially
098F C203       806       clr soak_temp_reached
0991 C204       807       clr reflow_temp_reached
0993            808   
0993 C0E0       809       push acc
0995 C0D0       810       push psw
0997 C000       811       push AR0
0999 C001       812       push AR1
099B C002       813       push AR2
099D            814       
099D            815       ; --- 1. CHECK SOAK TEMP ---
099D            816       ; Copy current_temp to X
099D 783F       817       mov R0, #current_temp
099F 7932       818       mov R1, #x
09A1 120A15     819       lcall Copy4_Bytes_R0_to_R1
09A4            820   
09A4            821       ; Copy soak_temp to Y
09A4 7843       822       mov R0, #soak_temp
09A6 7936       823       mov R1, #y
09A8 120A15     824       lcall Copy4_Bytes_R0_to_R1
09AB            825   
09AB            826       ; Compare: Is X (Current) < Y (Target)?
09AB 12011A     827       lcall x_lt_y
09AE 200002     828       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
09B1            829       
09B1            830       ; If we are here, Current >= Target
09B1 D203       831       setb soak_temp_reached
09B3            832   
09B3            833   Check_Reflow_Threshold:
09B3            834       ; --- 2. CHECK REFLOW TEMP ---
09B3            835       ; Copy current_temp to X (Need to reload X because math32 destroys it)
09B3 783F       836       mov R0, #current_temp
09B5 7932       837       mov R1, #x
09B7 120A15     838       lcall Copy4_Bytes_R0_to_R1
09BA            839   
09BA            840       ; Copy reflow_temp to Y
09BA 7847       841       mov R0, #reflow_temp
09BC 7936       842       mov R1, #y
09BE 120A15     843       lcall Copy4_Bytes_R0_to_R1
09C1            844   
09C1            845       ; Compare
09C1 12011A     846       lcall x_lt_y
09C4 200002     847       jb mf, Temp_Compare_Done
09C7            848       
09C7            849       ; If Current >= Target
09C7 D204       850       setb reflow_temp_reached
09C9            851   
09C9            852   Temp_Compare_Done:
09C9 D002       853       pop AR2
09CB D001       854       pop AR1
09CD D000       855       pop AR0
09CF D0D0       856       pop psw
09D1 D0E0       857       pop acc
09D3 22         858       ret
09D4            859   ;-------------------------------------------------------------------------------;
09D4            860   ; Time_Compare
09D4            861   ;
09D4            862   ; PURPOSE:
09D4            863   ;   Compare the elapsed time against soak and reflow
09D4            864   ;   time limits.
09D4            865   ;
09D4            866   ; BEHAVIOR:
09D4            867   ;   - If current_time >= soak_time   if soak_time_reached    = 1
09D4            868   ;   - If current_time >= reflow_time if reflow_time_reached = 1
09D4            869   ;
09D4            870   ; NOTES:
09D4            871   ;   - Time values are treated as 32-bit UNSIGNED numbers
09D4            872   ;     (e.g., milliseconds or seconds).
09D4            873   ;   - Uses the SAME compare logic as Temp_Compare.
09D4            874   ;   - This routine ONLY SETS flags.
09D4            875   ;
09D4            876   ; EXPECTED VARIABLES:
09D4            877   ;   current_time[4], soak_time[4], reflow_time[4]
09D4            878   ;   x[4], y[4]
09D4            879   ;   mf, soak_time_reached, reflow_time_reached
09D4            880   ;-------------------------------------------------------------------------------;
09D4            881   Time_Compare:
09D4 C0E0       882       push acc
09D6 C0D0       883       push psw
09D8 C000       884       push AR0
09DA C001       885       push AR1
09DC C002       886       push AR2
09DE            887   
09DE            888   ; Check: current_time >= soak_time ?
09DE            889       ; Copy current_time of x
09DE 7850       890       mov  R0, #current_time
09E0 7932       891       mov  R1, #x
09E2 120A15     892       lcall Copy4_Bytes_R0_to_R1
09E5            893   
09E5            894       ; Copy soak_time of y
09E5 7854       895       mov  R0, #soak_time
09E7 7936       896       mov  R1, #y
09E9 120A15     897       lcall Copy4_Bytes_R0_to_R1
09EC            898   
09EC            899       ; Compare elapsed time vs soak time
09EC 12011A     900       lcall x_lt_y
09EF 200002     901       jb   mf, Time_Soak_NotReached
09F2 D206       902       setb soak_time_reached
09F4            903   
09F4            904   ; Check: current_time >= reflow_time ?
09F4            905   Time_Soak_NotReached:
09F4            906       ; Copy current_time of x
09F4 7850       907       mov  R0, #current_time
09F6 7932       908       mov  R1, #x
09F8 120A15     909       lcall Copy4_Bytes_R0_to_R1
09FB            910   
09FB            911       ; Copy reflow_time of y
09FB 7858       912       mov  R0, #reflow_time
09FD 7936       913       mov  R1, #y
09FF 120A15     914       lcall Copy4_Bytes_R0_to_R1
0A02            915   
0A02            916       ; Compare elapsed time vs reflow time
0A02 12011A     917       lcall x_lt_y
0A05 200002     918       jb   mf, Time_Reflow_NotReached
0A08 D207       919       setb reflow_time_reached
0A0A            920   
0A0A            921   Time_Reflow_NotReached:
0A0A D002       922       pop  AR2
0A0C D001       923       pop  AR1
0A0E D000       924       pop  AR0
0A10 D0D0       925       pop  psw
0A12 D0E0       926       pop  acc
0A14 22         927       ret
0A15            928   
0A15            929   ;-------------------------------------------------------------------------------;
0A15            930   ; Copy4_Bytes_R0_to_R1
0A15            931   ;
0A15            932   ; PURPOSE:
0A15            933   ;   Utility routine to copy a 32-bit value (4 bytes)
0A15            934   ;   from one memory location to another.
0A15            935   ;
0A15            936   ; INPUTS:
0A15            937   ;   R0 st source address
0A15            938   ;   R1 at destination address
0A15            939   ;
0A15            940   ; USES:
0A15            941   ;   R2 as loop counter
0A15            942   ;
0A15            943   ; EXAMPLE:
0A15            944   ;   mov R0, #current_temp
0A15            945   ;   mov R1, #x
0A15            946   ;   lcall Copy4_Bytes_R0_to_R1
0A15            947   ;-------------------------------------------------------------------------------;
0A15            948   Copy4_Bytes_R0_to_R1:
0A15 7A04       949       mov  R2, #4
0A17            950   Copy4_Loop:
0A17 E6         951       mov  a, @R0
0A18 F7         952       mov  @R1, a
0A19 08         953       inc  R0
0A1A 09         954       inc  R1
0A1B DAFA       955       djnz R2, Copy4_Loop
0A1D 22         956       ret
0A1E            957   
0A1E            958   ;-------------------------------------------------------------------------------;
0A1E            959   ; Abort condition safety check Temperature time
0A1E            960   ;
0A1E            961   ; PURPOSE:
0A1E            962   ;   Automatic cycle termination on error:
0A1E            963   ;   Abort if oven fails to reach at least 50C in first 60s.
0A1E            964   ;
0A1E            965   ; TRIP CONDITION:
0A1E            966   ;   if (current_time >= 60s) AND (current_temp < 50C)
0A1E            967   ;       -> set tc_missing_abort
0A1E            968   ;       -> set stop_signal
0A1E            969   ;
0A1E            970   ; ASSUMPTIONS:
0A1E            971   ;   - current_time is in SECONDS (32-bit, little-endian)
0A1E            972   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0A1E            973   ;
0A1E            974   ;   the Load_Y constants accordingly.
0A1E            975   ;-------------------------------------------------------------------------------;
0A1E            976   Safety_Check_TC:
0A1E C0E0       977       push acc
0A20 C0D0       978       push psw
0A22 C000       979       push AR0
0A24 C001       980       push AR1
0A26 C002       981       push AR2
0A28            982   
0A28            983       ; ---------------------------------------------------------
0A28            984       ; [FIX] GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0A28            985       ; ---------------------------------------------------------
0A28 E568       986       mov a, Control_FSM_state
0A2A B40202     987       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0A2D 8003       988       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0A2F            989   
0A2F            990       Safety_TC_Exit_Bridge:
0A2F 020A7D     991           ljmp Safety_TC_Done               ; Jump to the end
0A32            992   
0A32            993       Safety_Logic_Proceed:
0A32            994           ; If already aborted or startup window closed, do nothing
0A32 200E48     995           jb   tc_missing_abort, Safety_TC_Done
0A35 300F45     996           jnb  tc_startup_window, Safety_TC_Done
0A38            997   
0A38            998       ; Check: current_time >= 60 ?
0A38 7850       999       mov  R0, #current_time
0A3A 7932      1000       mov  R1, #x
0A3C 120A15    1001       lcall Copy4_Bytes_R0_to_R1
0A3F           1002   
0A3F 75363C    1003            mov y+0, #low (60 % 0x10000) 
0A42 753700    1003            mov y+1, #high(60 % 0x10000) 
0A45 753800    1003            mov y+2, #low (60 / 0x10000) 
0A48 753900    1003            mov y+3, #high(60 / 0x10000) 
0A4B 12011A    1004       lcall x_lt_y
0A4E 2000DE    1005       jb   mf, Safety_TC_Exit_Bridge        ; still < 60s  keep waiting
0A51           1006   
0A51           1007       ; We reached 60s: close the startup window so it won't re-check later
0A51 C20F      1008       clr  tc_startup_window
0A53           1009   
0A53           1010       ; Now check: current_temp < 50 ?
0A53 783F      1011       mov  R0, #current_temp
0A55 7932      1012       mov  R1, #x
0A57 120A15    1013       lcall Copy4_Bytes_R0_to_R1
0A5A           1014   
0A5A 753632    1015            mov y+0, #low (50 % 0x10000) 
0A5D 753700    1015            mov y+1, #high(50 % 0x10000) 
0A60 753800    1015            mov y+2, #low (50 / 0x10000) 
0A63 753900    1015            mov y+3, #high(50 / 0x10000) 
0A66 12011A    1016       lcall x_lt_y
0A69 3000C3    1017       jnb  mf, Safety_TC_Exit_Bridge        ; temp >= 50  pass
0A6C           1018   
0A6C           1019       ; FAIL: at 60s, still below 50C  abort
0A6C C293      1020       clr  PWM_OUT
0A6E D20E      1021       setb tc_missing_abort
0A70 D209      1022       setb stop_signal
0A72 120A92    1023            lcall Beep_Ten
0A75           1024       ; 3. Force FSM to State 0 (Welcome)
0A75 756800    1025       mov Control_FSM_state, #0
0A78           1026       
0A78           1027       ; 4. Force UI to State 0 (Home Screen)
0A78 756900    1028       mov Current_State, #0
0A7B           1029       
0A7B           1030       ; 5. Trigger Screen Refresh
0A7B D20C      1031       setb state_change_signal ; Tell loop to redraw "Welcome"
0A7D           1032   
0A7D           1033   Safety_TC_Done:
0A7D D002      1034       pop  AR2
0A7F D001      1035       pop  AR1
0A81 D000      1036       pop  AR0
0A83 D0D0      1037       pop  psw
0A85 D0E0      1038       pop  acc
0A87 22        1039       ret
0A88           1040   
0A88           1041   ; ============================================================
0A88           1042   ; BUZZER STARTUP FUNCTIONS
0A88           1043   ; ============================================================
0A88           1044   
0A88           1045   Beep_Once:
0A88 757301    1046       mov beep_count, #1
0A8B 800A      1047       sjmp Beep_Start
0A8D           1048   
0A8D           1049   Beep_Five:
0A8D 757305    1050       mov beep_count, #5
0A90 8005      1051       sjmp Beep_Start
0A92           1052   
0A92           1053   Beep_Ten:
0A92 75730A    1054       mov beep_count, #10
0A95 8000      1055       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0A97           1056   
0A97           1057   Beep_Start:
0A97 C28C      1058       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0A99 757401    1059       mov beep_state, #1   ; Set State to ON
0A9C 757500    1060       mov beep_tmr, #0     ; Reset Timer High Byte
0A9F 757600    1061       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0AA2 D2A9      1062       setb ET0             ; [FIX] Ensure Interrupt is enabled
0AA4 D28C      1063       setb TR0             ; START the 2kHz tone
0AA6 22        1064       ret
0AA7           1065   ;============================================================
0AA7           1066   
0AA7           1067   ;============================================================
0AA7           1068   ; Buzzer beep Task 
0AA7           1069   ; Purpose: beeps, holds, stop
0AA7           1070   ; Buzzer task:
0AA7           1071   ; Beep once when state changes
0AA7           1072   ; Beep five times if finished
0AA7           1073   ; Beep ten times if meets error
0AA7           1074   ;============================================================
0AA7           1075   
0AA7           1076   Beep_Task:
0AA7 301335    1077       jnb one_ms_beep_flag, Beep_Done
0AAA C213      1078       clr one_ms_beep_flag
0AAC           1079   
0AAC E574      1080       mov a, beep_state
0AAE 602F      1081       jz Beep_Done
0AB0           1082   
0AB0           1083   ; ---- increment 16-bit timer ----
0AB0 0575      1084       inc beep_tmr
0AB2 E575      1085       mov a, beep_tmr
0AB4 7002      1086       jnz Beep_Check
0AB6 0576      1087       inc beep_tmr+1
0AB8           1088   
0AB8           1089   Beep_Check:
0AB8           1090       ; [FIX] FUZZY TIMER CHECK
0AB8           1091       ; Check if High Byte is non-zero (Time >= 256ms)
0AB8 E576      1092       mov a, beep_tmr+1
0ABA 6023      1093       jz Beep_Done        ; If 0, keep beeping
0ABC           1094   
0ABC           1095       ; --- Time Limit Reached ---
0ABC 757500    1096       mov beep_tmr, #0    ; Reset timer
0ABF 757600    1097       mov beep_tmr+1, #0
0AC2           1098   
0AC2 E574      1099       mov a, beep_state
0AC4 B40106    1100       cjne a, #1, Beep_Off_State
0AC7           1101   
0AC7           1102       ; State was 1 (ON) -> Turn OFF
0AC7 C28C      1103       clr TR0             ; Hardware Silence
0AC9 757402    1104       mov beep_state, #2  ; Set State to OFF (Pause)
0ACC 22        1105       ret
0ACD           1106   
0ACD           1107   Beep_Off_State:
0ACD           1108   ; ---- OFF finished -> decrement count / next ON ----
0ACD 1573      1109       dec beep_count
0ACF E573      1110       mov a, beep_count
0AD1 6006      1111       jz  Beep_Stop
0AD3           1112   
0AD3 757401    1113       mov beep_state, #1
0AD6 D28C      1114       setb TR0
0AD8 22        1115       ret
0AD9           1116   
0AD9           1117   Beep_Stop:
0AD9 C28C      1118       clr TR0
0ADB 757400    1119       mov beep_state, #0
0ADE 22        1120       ret
0ADF           1121   
0ADF           1122   Beep_Done:
0ADF 22        1123       ret
0AE0           1124   ;==================================================================
0AE0           1125   
0AE0           1126   ;-------------------------------------------------------------------------------;
0AE0           1127   ; Main Control FSM for the entire process
0AE0           1128   ;-------------------------------------------------------------------------------;
0AE0           1129   ;-------------------------------------------------------------------------------;
0AE0           1130   ; FSM LOGIC (Button Logic Fixed)
0AE0           1131   ;-------------------------------------------------------------------------------;
0AE0           1132   Control_FSM:
0AE0 E568      1133       mov a, Control_FSM_state
0AE2 8005      1134       sjmp Control_FSM_state0
0AE4           1135   
0AE4           1136   Control_FSM_state0_a:
0AE4 756800    1137       mov Control_FSM_state, #0
0AE7 D20C      1138       setb state_change_signal
0AE9           1139            
0AE9           1140   Control_FSM_state0:
0AE9 B40014    1141       cjne a, #0, Control_FSM_state1
0AEC           1142   
0AEC 300D04    1143       jnb Key1_flag, Control_FSM_done_bridge ; If Key1 not pressed, exit
0AEF C20D      1144       clr Key1_flag                          ; Clear the flag
0AF1 8001      1145       sjmp Control_FSM_state1_a              ; Jump to Start Oven
0AF3           1146       
0AF3           1147   Control_FSM_done_bridge:
0AF3 22        1148       ret
0AF4           1149   
0AF4           1150   Control_FSM_state1_a:
0AF4 0568      1151       inc Control_FSM_state
0AF6 756900    1152       mov Current_State, #0
0AF9 120F0D    1153       lcall Update_Screen_Full 
0AFC D20C      1154       setb state_change_signal
0AFE E568      1155       mov a, Control_FSM_state
0B00           1156       
0B00           1157   Control_FSM_state1:
0B00 B40127    1158       cjne a, #1, Control_FSM_state2
0B03 120D45    1159       lcall Check_Buttons 
0B06 120D91    1160       lcall Check_Keypad
0B09           1161       
0B09           1162       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0B09 209008    1163       jb P1.0, Control_FSM_state1_ret
0B0C           1164       
0B0C           1165       ; If we get here, Button is LOW (Pressed)
0B0C 12102F    1166       lcall Wait_For_P1_0_Release
0B0F 120CC9    1167       lcall Update_FSM_Variables
0B12 8001      1168       sjmp Control_FSM_state2_a
0B14           1169   Control_FSM_state1_ret:
0B14 22        1170       ret
0B15           1171   
0B15           1172   ; --- STATE 2: RAMP TO SOAK ---
0B15           1173   Control_FSM_state2_a:
0B15 0568      1174       inc Control_FSM_state
0B17 E568      1175       mov a, Control_FSM_state   ; [FIX] RELOAD 'A' so it matches the new state!
0B19 D20C      1176       setb state_change_signal
0B1B 120A88    1177       lcall Beep_Once
0B1E           1178   
0B1E D20F      1179       setb tc_startup_window    ; OPEN the safety window
0B20 C20E      1180       clr tc_missing_abort      ; Clear any previous aborts
0B22 753000    1181       mov current_time_sec, #0  ; Reset Seconds to 0
0B25 753100    1182       mov current_time_minute, #0 ; Reset Minutes to 0
0B28           1183       
0B28           1184       ; [FIX] CLEAR FLAG ON ENTRY
0B28           1185       ; Force the system to wait for at least one fresh temp reading
0B28           1186       ; before deciding we are done.
0B28 C203      1187       clr soak_temp_reached      
0B2A           1188   
0B2A           1189   Control_FSM_state2:
0B2A B4021F    1190       cjne a, #2, Control_FSM_state3
0B2D 301205    1191       jnb PB2_flag, State2_Check
0B30 C212      1192       clr PB2_flag
0B32 020B9D    1193       ljmp Control_FSM_state6_a ; Pause
0B35           1194   
0B35           1195   State2_Check:
0B35 300313    1196       jnb soak_temp_reached, State2_Ret
0B38           1197       
0B38           1198       ; --- We reached Temp! Move to State 3 ---
0B38 C203      1199       clr soak_temp_reached
0B3A 0568      1200       inc Control_FSM_state
0B3C           1201       
0B3C           1202       ; [FIX] RELOAD 'A' (Good practice)
0B3C E568      1203       mov a, Control_FSM_state   
0B3E           1204       
0B3E D20C      1205       setb state_change_signal
0B40 120A88    1206       lcall Beep_Once
0B43           1207       
0B43 753000    1208       mov current_time_sec, #0
0B46 753100    1209       mov current_time_minute, #0
0B49           1210       
0B49           1211       ; Ensure we start State 3 fresh
0B49 C206      1212       clr soak_time_reached 
0B4B           1213   
0B4B           1214   State2_Ret:
0B4B 22        1215       ret
0B4C           1216   
0B4C           1217   ; --- STATE 3: SOAK PHASE ---
0B4C           1218   Control_FSM_state3:
0B4C B40315    1219       cjne a, #3, Control_FSM_state4
0B4F 301205    1220       jnb PB2_flag, State3_Check
0B52 C212      1221       clr PB2_flag
0B54 020B9D    1222       ljmp Control_FSM_state6_a
0B57           1223   State3_Check:
0B57 300609    1224       jnb soak_time_reached, State3_Ret
0B5A C206      1225       clr soak_time_reached
0B5C 0568      1226       inc Control_FSM_state      
0B5E D20C      1227       setb state_change_signal 
0B60 120A88    1228            lcall Beep_Once
0B63           1229   State3_Ret:
0B63 22        1230       ret
0B64           1231   
0B64           1232   ; --- STATE 4: RAMP TO PEAK ---
0B64           1233   Control_FSM_state4:
0B64 B4041D    1234       cjne a, #4, Control_FSM_state5
0B67 301205    1235       jnb PB2_flag, State4_Check
0B6A C212      1236       clr PB2_flag
0B6C 020B9D    1237       ljmp Control_FSM_state6_a
0B6F           1238   State4_Check:
0B6F 300411    1239       jnb reflow_temp_reached, State4_Ret
0B72 C204      1240       clr reflow_temp_reached
0B74 0568      1241       inc Control_FSM_state
0B76 D20C      1242       setb state_change_signal
0B78 120A88    1243            lcall Beep_Once
0B7B 753000    1244       mov current_time_sec, #0
0B7E 753100    1245       mov current_time_minute, #0
0B81           1246       ; --- ADD THIS LINE ---
0B81 C207      1247       clr reflow_time_reached ; Kill the ghost flag
0B83           1248       ; ---------------------
0B83           1249   State4_Ret:
0B83 22        1250       ret
0B84           1251   
0B84           1252   ; --- STATE 5: REFLOW PHASE ---
0B84           1253   Control_FSM_state5:
0B84 B40502    1254       cjne a, #5, Control_FSM_state6_trampoline
0B87 8003      1255       sjmp State5_Logic
0B89           1256   Control_FSM_state6_trampoline:
0B89 020BA4    1257       ljmp Control_FSM_state6
0B8C           1258   
0B8C           1259   State5_Logic:
0B8C 301205    1260       jnb PB2_flag, State5_Check
0B8F C212      1261       clr PB2_flag
0B91 020B9D    1262       ljmp Control_FSM_state6_a
0B94           1263   State5_Check:
0B94 300705    1264       jnb reflow_time_reached, State5_Ret
0B97 C207      1265       clr reflow_time_reached
0B99 020B9D    1266       ljmp Control_FSM_state6_a
0B9C           1267   State5_Ret:
0B9C 22        1268       ret
0B9D           1269   
0B9D           1270   ; --- STATE 6: COOLING ---
0B9D           1271   Control_FSM_state6_a:
0B9D 0568      1272       inc Control_FSM_state
0B9F D20C      1273       setb state_change_signal
0BA1 120A8D    1274            lcall Beep_Five
0BA4           1275   Control_FSM_state6:
0BA4 B4060A    1276       cjne a, #6, Control_FSM_state7
0BA7           1277       ; Wait for Cooling Temp Reached
0BA7 300506    1278       jnb cooling_temp_reached, State6_Ret
0BAA C205      1279       clr cooling_temp_reached
0BAC 0568      1280       inc Control_FSM_state
0BAE D20C      1281       setb state_change_signal
0BB0           1282   State6_Ret:
0BB0 22        1283       ret
0BB1           1284   
0BB1           1285   ; --- STATE 7: DONE ---
0BB1           1286   Control_FSM_state7:
0BB1 B40711    1287       cjne a, #7, Control_FSM_done
0BB4           1288       
0BB4           1289       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0BB4 201009    1290       jb PB0_flag, Control_FSM_Reset_Logic ; Wait, PB0_flag is software flag?
0BB7           1291       
0BB7           1292       ; Let's assume you meant the physical button P1.0 like State 0
0BB7 20900B    1293       jb P1.0, Control_FSM_done
0BBA           1294       
0BBA 12102F    1295       lcall Wait_For_P1_0_Release
0BBD 020AE4    1296       ljmp Control_FSM_state0_a
0BC0           1297   
0BC0           1298   Control_FSM_Reset_Logic:
0BC0           1299       ; If using PB0_flag from ISR, handle here
0BC0 C210      1300       clr PB0_flag
0BC2 020AE4    1301       ljmp Control_FSM_state0_a
0BC5           1302   
0BC5           1303   Control_FSM_done:
0BC5 22        1304       ret
0BC6           1305   ;-------------------------------------------------------------------------------;
0BC6           1306   ;         Main program.          
0BC6           1307   ;-------------------------------------------------------------------------------;
0BC6           1308   main:
0BC6           1309   
0BC6           1310       ; --------------------------------------------------------
0BC6           1311       ; 1. SAFETY SHUTDOWN
0BC6           1312       ; --------------------------------------------------------
0BC6 C2AF      1313       clr EA              ; FORCE Interrupts OFF immediately
0BC8 7581C0    1314       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0BCB           1315       
0BCB           1316       ; --------------------------------------------------------
0BCB           1317       ; 2. THE "DIRTY DELAY" (Fixes Reset Garbage)
0BCB           1318       ; We burn ~100ms here using a raw loop. 
0BCB           1319       ; We cannot use timers yet because they aren't initialized.
0BCB           1320       ; --------------------------------------------------------
0BCB 78FA      1321       mov R0, #250
0BCD           1322   Reset_Delay_Outer:
0BCD 79FF      1323       mov R1, #255
0BCF           1324   Reset_Delay_Inner:
0BCF D9FE      1325       djnz R1, Reset_Delay_Inner
0BD1 D8FA      1326       djnz R0, Reset_Delay_Outer
0BD3           1327       ; --------------------------------------------------------
0BD3           1328   
0BD3           1329       ; ... NOW continue with your normal Port Configuration ...
0BD3           1330       
0BD3           1331       ; --- PORT CONFIGURATION ---
0BD3 759AAA    1332       mov P0MOD, #0xAA
0BD6           1333   
0BD6           1334       ; P1: Mixed usage 
0BD6           1335       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0BD6           1336       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0BD6           1337       ; P1.0 (Unused/RX) -> Input
0BD6           1338       ; Binary: 11111110 -> Hex: 0xFE
0BD6 759BFE    1339       mov P1MOD, #0xFE
0BD9           1340   
0BD9           1341       ; P2: Row4(Out), Cols(In)
0BD9           1342       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0BD9           1343       ; Binary: 00000001 -> Hex: 0x01
0BD9 759C01    1344       mov P2MOD, #0x01
0BDC           1345   
0BDC           1346       ; P3: Col4(In)
0BDC           1347       ; P3.0 (Col4) is In (0).
0BDC 759D40    1348       mov P3MOD, #01000000B
0BDF           1349       ; Turn off all the LEDs
0BDF 75E800    1350       mov LEDRA, #0 ; LEDRA is bit addressable
0BE2 759500    1351       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0BE5           1352   
0BE5           1353       ; FSM initial states
0BE5 756600    1354       mov KEY1_DEB_state, #0
0BE8 756700    1355       mov SEC_FSM_state, #0
0BEB 756800    1356       mov Control_FSM_state, #0
0BEE 756900    1357       mov Current_State, #0
0BF1           1358       
0BF1           1359       ; FSM timers initialization
0BF1 756400    1360       mov KEY1_DEB_timer, #0
0BF4 756500    1361       mov SEC_FSM_timer, #0
0BF7           1362       ; time counters initialization
0BF7 753000    1363       mov current_time_sec, #0
0BFA 753100    1364       mov current_time_minute, #0
0BFD           1365       ; Initialize counter to zero
0BFD 756000    1366       mov pwm_counter, #0
0C00 756100    1367       mov pwm_counter+1, #0
0C03 756200    1368       mov pwm_counter+2, #0
0C06 756300    1369       mov pwm_counter+3, #0
0C09           1370       ; Initialize power output
0C09 755F00    1371       mov power_output+3, #0
0C0C 755E00    1372       mov power_output+2, #0
0C0F 755D02    1373       mov power_output+1, #02H
0C12 755CEE    1374       mov power_output, #0EEH ; (initilize to 750 for testing)
0C15           1375   
0C15           1376       ; --- ADD THIS TO CLEAN SERIAL VARIABLES ---
0C15 758000    1377       mov rx_index, #0
0C18 758100    1378       mov cmd_received, #0
0C1B           1379   
0C1B           1380       ; Clear all the flags
0C1B C20E      1381       clr  tc_missing_abort
0C1D C209      1382       clr  stop_signal
0C1F C210      1383       clr PB0_flag
0C21 C211      1384       clr PB1_flag
0C23 C212      1385       clr PB2_flag
0C25 C201      1386       clr one_second_flag
0C27 C20B      1387       clr config_finish_signal
0C29 C203      1388       clr soak_temp_reached
0C2B C206      1389       clr soak_time_reached
0C2D C204      1390       clr reflow_temp_reached
0C2F C207      1391       clr reflow_time_reached
0C31 C205      1392       clr cooling_temp_reached
0C33 C20C      1393       clr state_change_signal
0C35 C21E      1394       clr one_millisecond_flag_servo
0C37           1395       
0C37 D20C      1396       setb state_change_signal
0C39           1397   
0C39           1398       ; Set bit
0C39 D20F      1399       setb tc_startup_window
0C3B           1400   
0C3B           1401       ; --------------------------------------
0C3B           1402       ; [FIX] ADD THIS BLOCK TO STOP STARTUP BEEP
0C3B           1403       ; --------------------------------------
0C3B 757400    1404       mov beep_state, #0
0C3E 757300    1405       mov beep_count, #0
0C41 757500    1406       mov beep_tmr, #0
0C44 757600    1407       mov beep_tmr+1, #0
0C47 C213      1408       clr one_ms_beep_flag
0C49 C28C      1409       clr TR0              ; Force buzzer hardware OFF
0C4B           1410       ; --------------------------------------
0C4B           1411   
0C4B           1412   
0C4B 12045D    1413       lcall Timer0_Init
0C4E 12051E    1414       lcall Timer2_Init
0C51 1205EB    1415       lcall ELCD_4BIT
0C54           1416       ;----- Two new lines I added to initialize the UI
0C54 120EBA    1417       lcall Init_All_Buffers
0C57           1418       ;lcall Update_Screen_Full
0C57           1419       ;-----
0C57 120477    1420       lcall Initialize_Serial_Port
0C5A           1421   
0C5A           1422       ; Enable Global interrupts
0C5A D2AF      1423       setb EA  
0C5C           1424   ;-------------------------------------------------------------------------------;
0C5C           1425   ; while(1) loop
0C5C           1426   ;-------------------------------------------------------------------------------;
0C5C           1427   loop:
0C5C           1428       ; Full reset button on P3.7 (active-low to GND)
0C5C 30B702    1429        jnb P3_7, Full_Reset_Trig
0C5F 8003      1430       sjmp Full_Reset_Check_Done
0C61           1431   
0C61           1432   Full_Reset_Trig:
0C61 021037    1433       ljmp Full_Reset
0C64           1434   
0C64           1435   Full_Reset_Check_Done:
0C64           1436   
0C64 121371    1437       lcall Process_Serial_Command
0C67           1438   
0C67           1439       ; Check the FSM for KEY1 debounce
0C67 12088C    1440       lcall KEY1_DEB
0C6A           1441       
0C6A           1442       ; Added to take temp readings
0C6A 12103D    1443       lcall Read_Thermocouple
0C6D           1444       
0C6D           1445       ; 1. Check if we reached temp (Observer)
0C6D 12098F    1446       lcall Temp_Compare
0C70           1447       
0C70           1448       ; 2. Decide heater power based on flags (Driver)
0C70           1449       ;lcall Power_Control
0C70 12117F    1450       lcall proportional_power_control
0C73           1451   
0C73           1452       ; 3. [FIX] Calculate Total Seconds (Minutes * 60 + Seconds)
0C73           1453       ; ---------------------------------------------------------
0C73           1454       ; Load Minutes into X
0C73 853132    1455       mov x+0, current_time_minute
0C76 753300    1456       mov x+1, #0
0C79 753400    1457       mov x+2, #0
0C7C 753500    1458       mov x+3, #0
0C7F           1459       
0C7F           1460       ; Multiply by 60 (Minutes -> Seconds)
0C7F 75363C    1461            mov y+0, #low (60 % 0x10000) 
0C82 753700    1461            mov y+1, #high(60 % 0x10000) 
0C85 753800    1461            mov y+2, #low (60 / 0x10000) 
0C88 753900    1461            mov y+3, #high(60 / 0x10000) 
0C8B 12018C    1462       lcall mul32
0C8E           1463       
0C8E           1464       ; Load Seconds into Y
0C8E 853036    1465       mov y+0, current_time_sec
0C91 753700    1466       mov y+1, #0
0C94 753800    1467       mov y+2, #0
0C97 753900    1468       mov y+3, #0
0C9A           1469       
0C9A           1470       ; Add them together (Total Seconds = X + Y)
0C9A 1200D3    1471       lcall add32
0C9D           1472       
0C9D           1473       ; Store Final Result into 'current_time'
0C9D 853250    1474       mov current_time+0, x+0
0CA0 853351    1475       mov current_time+1, x+1
0CA3 853452    1476       mov current_time+2, x+2
0CA6 853553    1477       mov current_time+3, x+3
0CA9           1478       
0CA9 1209D4    1479       lcall Time_Compare
0CAC           1480       
0CAC 120A1E    1481       lcall Safety_Check_TC
0CAF           1482   
0CAF           1483   
0CAF           1484       ; Check the FSM for one second counter
0CAF 1208C2    1485       lcall SEC_FSM
0CB2           1486   
0CB2           1487       ; Check the FSM for the overall control flow of the reflow process
0CB2 120AE0    1488       lcall Control_FSM
0CB5           1489   
0CB5           1490       ; Update the LCD display based on the current state
0CB5 1206B0    1491       lcall LCD_Display_Update_func
0CB8           1492   
0CB8 300202    1493       jnb one_ms_pwm_flag, Skip_Beep_Sync
0CBB D213      1494       setb one_ms_beep_flag  ; Give the buzzer its own copy of the time tick
0CBD           1495   
0CBD           1496   Skip_Beep_Sync:
0CBD           1497       ; Update the pwm output for the ssr
0CBD 120918    1498       lcall PWM_Wave 
0CC0           1499            ; Update the Buzzer 
0CC0 120AA7    1500            lcall Beep_Task
0CC3           1501       ; Update the pwm output for the servo
0CC3 121112    1502       lcall call_servo_control
0CC6           1503       ; After initialization the program stays in this 'forever' loop
0CC6 020C5C    1504       ljmp loop
0CC9           1505   ;-------------------------------------------------------------------------------;
0CC9           1506   
0CC9           1507   ; ================================================================
0CC9           1508   ; UI & HELPER SUBROUTINES
0CC9           1509   ; ================================================================
0CC9           1510   
0CC9           1511   ; ----------------------------------------------------------------
0CC9           1512   ; MODULE: BRIDGE (Text to Integer Conversion)
0CC9           1513   ; ----------------------------------------------------------------
0CC9           1514   Update_FSM_Variables:
0CC9           1515       ; --- 1. SOAK TEMP ---
0CC9 7880      1516       mov R0, #Buf_Soak_Temp
0CCB 120D08    1517       lcall Parse_Temp_String
0CCE 8F43      1518       mov soak_temp+0, R7
0CD0 754400    1519       mov soak_temp+1, #0
0CD3 754500    1520       mov soak_temp+2, #0
0CD6 754600    1521       mov soak_temp+3, #0
0CD9           1522   
0CD9           1523       ; --- 2. REFLOW TEMP ---
0CD9 7889      1524       mov R0, #Buf_Refl_Temp
0CDB 120D08    1525       lcall Parse_Temp_String
0CDE 8F47      1526       mov reflow_temp+0, R7
0CE0 754800    1527       mov reflow_temp+1, #0
0CE3 754900    1528       mov reflow_temp+2, #0
0CE6 754A00    1529       mov reflow_temp+3, #0
0CE9           1530   
0CE9           1531       ; --- 3. SOAK TIME ---
0CE9 7884      1532       mov R0, #Buf_Soak_Time
0CEB 120D1C    1533       lcall Parse_Time_String
0CEE 8F54      1534       mov soak_time+0, R7
0CF0 8E55      1535       mov soak_time+1, R6
0CF2 755600    1536       mov soak_time+2, #0
0CF5 755700    1537       mov soak_time+3, #0
0CF8           1538   
0CF8           1539       ; --- 4. REFLOW TIME ---
0CF8 788D      1540       mov R0, #Buf_Refl_Time
0CFA 120D1C    1541       lcall Parse_Time_String
0CFD 8F58      1542       mov reflow_time+0, R7
0CFF 8E59      1543       mov reflow_time+1, R6
0D01 755A00    1544       mov reflow_time+2, #0
0D04 755B00    1545       mov reflow_time+3, #0
0D07 22        1546       ret
0D08           1547   
0D08           1548   ; --- Helper: Parse "123" to Integer ---
0D08           1549   Parse_Temp_String:
0D08 7F00      1550       mov R7, #0              ; Clear Result
0D0A           1551   Parse_Temp_Loop:
0D0A E6        1552       mov A, @R0
0D0B 600E      1553       jz Parse_Temp_Done      ; If Null, we are done
0D0D           1554       
0D0D           1555       ; Convert ASCII to Digit
0D0D C3        1556       clr C
0D0E 9430      1557       subb A, #0x30
0D10 FD        1558       mov R5, A               ; R5 = New Digit
0D11           1559       
0D11           1560       ; Result = (Result * 10) + New Digit
0D11 EF        1561       mov A, R7
0D12 75F00A    1562       mov B, #10
0D15 A4        1563       mul AB
0D16 2D        1564       add A, R5
0D17 FF        1565       mov R7, A
0D18           1566       
0D18 08        1567       inc R0
0D19 80EF      1568       sjmp Parse_Temp_Loop
0D1B           1569   Parse_Temp_Done:
0D1B 22        1570       ret
0D1C           1571   
0D1C           1572   ; --- Helper: Parse "MMSS" to Seconds ---
0D1C           1573   Parse_Time_String:
0D1C           1574       ; 1. Minutes Tens
0D1C E6        1575       mov A, @R0
0D1D 9430      1576       subb A, #0x30
0D1F 75F00A    1577       mov B, #10
0D22 A4        1578       mul AB
0D23 FD        1579       mov R5, A
0D24 08        1580       inc R0
0D25           1581       
0D25           1582       ; 2. Minutes Ones
0D25 E6        1583       mov A, @R0
0D26 9430      1584       subb A, #0x30
0D28 2D        1585       add A, R5
0D29 FD        1586       mov R5, A               ; R5 = Total Minutes
0D2A 08        1587       inc R0
0D2B           1588       
0D2B           1589       ; 3. Seconds Tens
0D2B E6        1590       mov A, @R0
0D2C 9430      1591       subb A, #0x30
0D2E 75F00A    1592       mov B, #10
0D31 A4        1593       mul AB
0D32 FC        1594       mov R4, A
0D33 08        1595       inc R0
0D34           1596       
0D34           1597       ; 4. Seconds Ones
0D34 E6        1598       mov A, @R0
0D35 9430      1599       subb A, #0x30
0D37 2C        1600       add A, R4               ; R4 = Total Seconds
0D38           1601       
0D38           1602       ; 5. Calculate Total Seconds = (Mins * 60) + Secs
0D38 ED        1603       mov A, R5
0D39 75F03C    1604       mov B, #60
0D3C A4        1605       mul AB
0D3D 2C        1606       add A, R4
0D3E FF        1607       mov R7, A               ; Low Byte
0D3F E5F0      1608       mov A, B
0D41 3400      1609       addc A, #0
0D43 FE        1610       mov R6, A               ; High Byte
0D44 22        1611       ret
0D45           1612   
0D45           1613   ; ----------------------------------------------------------------
0D45           1614   ; MODULE: BUTTON HANDLER (Mode Selection)
0D45           1615   ; ----------------------------------------------------------------
0D45           1616   Check_Buttons:
0D45           1617       ; --- FORCE INPUT MODE ---
0D45           1618       ; This clears any '0' the LCD library might have written to our buttons
0D45 438055    1619       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0D48           1620       ; ------------------------
0D48           1621   
0D48 30800A    1622       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0D4B 308212    1623       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0D4E 30841A    1624       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0D51 308622    1625       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0D54 22        1626       ret
0D55           1627   
0D55           1628   Btn_Soak_Temp_Press:
0D55 120FFF    1629       lcall Wait_25ms_BLOCKING
0D58 756901    1630       mov Current_State, #1
0D5B 757200    1631       mov Cursor_Idx, #0
0D5E 8021      1632       sjmp Redraw_Screen
0D60           1633   
0D60           1634   Btn_Soak_Time_Press:
0D60 120FFF    1635       lcall Wait_25ms_BLOCKING
0D63 756902    1636       mov Current_State, #2
0D66 757200    1637       mov Cursor_Idx, #0
0D69 8016      1638       sjmp Redraw_Screen
0D6B           1639   
0D6B           1640   Btn_Refl_Temp_Press:
0D6B 120FFF    1641       lcall Wait_25ms_BLOCKING
0D6E 756903    1642       mov Current_State, #3
0D71 757200    1643       mov Cursor_Idx, #0
0D74 800B      1644       sjmp Redraw_Screen
0D76           1645   
0D76           1646   Btn_Refl_Time_Press:
0D76 120FFF    1647       lcall Wait_25ms_BLOCKING 
0D79 756904    1648       mov Current_State, #4
0D7C 757200    1649       mov Cursor_Idx, #0
0D7F 8000      1650       sjmp Redraw_Screen
0D81           1651   
0D81           1652   Redraw_Screen:
0D81           1653       ; Wait for button release
0D81 3080FD    1654       jnb BTN_SOAK_TEMP, $
0D84 3082FD    1655       jnb BTN_SOAK_TIME, $
0D87 3084FD    1656       jnb BTN_REFL_TEMP, $
0D8A 3086FD    1657       jnb BTN_REFL_TIME, $
0D8D           1658   
0D8D 120F0D    1659       lcall Update_Screen_Full
0D90 22        1660       ret
0D91           1661   
0D91           1662   ; ----------------------------------------------------------------
0D91           1663   ; MODULE: KEYPAD HANDLER (Input Logic)
0D91           1664   ; ----------------------------------------------------------------
0D91           1665   Check_Keypad:
0D91           1666       ; If State is 0 (Home), ignore keypad
0D91 E569      1667       mov A, Current_State
0D93 6050      1668       jz Keypad_Exit
0D95           1669       
0D95 120DE6    1670       lcall Keypad_Scan
0D98 504B      1671       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0D9A           1672   
0D9A           1673       ; --- Check Special Keys ---
0D9A EF        1674       mov A, R7
0D9B B40E0A    1675       cjne A, #14, Check_Hash ; 14 is Star (*)
0D9E           1676       
0D9E           1677       ; Star Key Pressed: Reset Buffer
0D9E 120EEA    1678       lcall Reset_Current_Buffer
0DA1 120F0D    1679       lcall Update_Screen_Full
0DA4 757200    1680       mov Cursor_Idx, #0
0DA7 22        1681       ret
0DA8           1682   
0DA8           1683   Check_Hash:
0DA8 EF        1684       mov A, R7
0DA9 B40C01    1685       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0DAC 22        1686       ret                     ; Ignore Hash key
0DAD           1687   
0DAD           1688   Check_Numeric:
0DAD           1689       ; Ensure key is 0-9
0DAD EF        1690       mov A, R7
0DAE C3        1691       clr C
0DAF 940A      1692       subb A, #10
0DB1 5031      1693       jnc Symbol_Key_Ignored
0DB3           1694       
0DB3           1695       ; Convert to ASCII
0DB3 EF        1696       mov A, R7
0DB4 2430      1697       add A, #0x30
0DB6 FD        1698       mov R5, A
0DB7           1699   
0DB7           1700       ; Save to Buffer
0DB7 121018    1701       lcall Get_Current_Buffer_Addr
0DBA E572      1702       mov A, Cursor_Idx
0DBC 28        1703       add A, R0
0DBD F8        1704       mov R0, A
0DBE ED        1705       mov A, R5
0DBF F6        1706       mov @R0, A
0DC0 0572      1707       inc Cursor_Idx
0DC2           1708   
0DC2           1709       ; --- Check Cursor Limits ---
0DC2 E569      1710       mov A, Current_State
0DC4 B40102    1711       cjne A, #1, Check_Limit_Time_1
0DC7 8005      1712       sjmp Limit_Temp_3
0DC9           1713   
0DC9           1714   Check_Limit_Time_1:
0DC9 B4030B    1715       cjne A, #3, Limit_Time_4
0DCC 8000      1716       sjmp Limit_Temp_3
0DCE           1717   
0DCE           1718   Limit_Temp_3:
0DCE E572      1719       mov A, Cursor_Idx
0DD0 B4030D    1720       cjne A, #3, Do_Refresh
0DD3 1572      1721       dec Cursor_Idx          ; Stay at last digit
0DD5 8009      1722       sjmp Do_Refresh
0DD7           1723   
0DD7           1724   Limit_Time_4:
0DD7 E572      1725       mov A, Cursor_Idx
0DD9 B40404    1726       cjne A, #4, Do_Refresh
0DDC 1572      1727       dec Cursor_Idx          ; Stay at last digit
0DDE 8000      1728       sjmp Do_Refresh
0DE0           1729   
0DE0           1730   Do_Refresh:
0DE0 120F0D    1731       lcall Update_Screen_Full
0DE3 22        1732       ret
0DE4           1733   
0DE4           1734   Symbol_Key_Ignored:
0DE4 22        1735       ret
0DE5           1736   Keypad_Exit:
0DE5 22        1737       ret
0DE6           1738   
0DE6           1739   ; ----------------------------------------------------------------
0DE6           1740   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0DE6           1741   ; ----------------------------------------------------------------
0DE6           1742   Keypad_Scan:
0DE6           1743       ; Step 1: Check if ANY key is pressed (All Rows Low)
0DE6 C292      1744       clr ROW1
0DE8 C294      1745       clr ROW2
0DEA C296      1746       clr ROW3
0DEC C2A0      1747       clr ROW4
0DEE A2A2      1748       mov C, COL1
0DF0 82A4      1749       anl C, COL2
0DF2 82A6      1750       anl C, COL3
0DF4 82B0      1751       anl C, COL4
0DF6 5002      1752       jnc Keypad_Debounce
0DF8 C3        1753       clr C
0DF9 22        1754       ret
0DFA           1755   
0DFA           1756   Keypad_Debounce:
0DFA 120FFF    1757       lcall Wait_25ms_BLOCKING
0DFD A2A2      1758       mov C, COL1
0DFF 82A4      1759       anl C, COL2
0E01 82A6      1760       anl C, COL3
0E03 82B0      1761       anl C, COL4
0E05 5002      1762       jnc Keypad_Find_Row
0E07 C3        1763       clr C
0E08 22        1764       ret
0E09           1765   
0E09           1766   Keypad_Find_Row:
0E09 D292      1767       setb ROW1
0E0B D294      1768       setb ROW2
0E0D D296      1769       setb ROW3
0E0F D2A0      1770       setb ROW4
0E11           1771   
0E11           1772       ; Row 1
0E11 C292      1773       clr ROW1
0E13 30A23D    1774       jnb COL1, Keypad_Key_1
0E16 30A43E    1775       jnb COL2, Keypad_Key_2
0E19 30A63F    1776       jnb COL3, Keypad_Key_3
0E1C 30B040    1777       jnb COL4, Keypad_Key_A
0E1F D292      1778       setb ROW1
0E21           1779   
0E21           1780       ; Row 2
0E21 C294      1781       clr ROW2
0E23 30A23D    1782       jnb COL1, Keypad_Key_4
0E26 30A43E    1783       jnb COL2, Keypad_Key_5
0E29 30A63F    1784       jnb COL3, Keypad_Key_6
0E2C 30B040    1785       jnb COL4, Keypad_Key_B
0E2F D294      1786       setb ROW2
0E31           1787   
0E31           1788       ; Row 3
0E31 C296      1789       clr ROW3
0E33 30A23D    1790       jnb COL1, Keypad_Key_7
0E36 30A43E    1791       jnb COL2, Keypad_Key_8
0E39 30A63F    1792       jnb COL3, Keypad_Key_9
0E3C 30B040    1793       jnb COL4, Keypad_Key_C
0E3F D296      1794       setb ROW3
0E41           1795   
0E41           1796       ; Row 4
0E41 C2A0      1797       clr ROW4
0E43 30A23D    1798       jnb COL1, Keypad_Key_Star
0E46 30A43E    1799       jnb COL2, Keypad_Key_0
0E49 30A63F    1800       jnb COL3, Keypad_Key_Hash
0E4C 30B040    1801       jnb COL4, Keypad_Key_D
0E4F D2A0      1802       setb ROW4
0E51 C3        1803       clr C
0E52 22        1804       ret
0E53           1805   
0E53           1806   ; Key Mapping (Renamed to avoid conflicts)
0E53 7F01      1807   Keypad_Key_1: mov R7, #1
0E55 803C      1808          sjmp Wait_Release
0E57 7F02      1809   Keypad_Key_2: mov R7, #2
0E59 8038      1810          sjmp Wait_Release
0E5B 7F03      1811   Keypad_Key_3: mov R7, #3
0E5D 8034      1812          sjmp Wait_Release
0E5F 7F0A      1813   Keypad_Key_A: mov R7, #10
0E61 8030      1814          sjmp Wait_Release
0E63 7F04      1815   Keypad_Key_4: mov R7, #4
0E65 802C      1816          sjmp Wait_Release
0E67 7F05      1817   Keypad_Key_5: mov R7, #5
0E69 8028      1818          sjmp Wait_Release
0E6B 7F06      1819   Keypad_Key_6: mov R7, #6
0E6D 8024      1820          sjmp Wait_Release
0E6F 7F0B      1821   Keypad_Key_B: mov R7, #11
0E71 8020      1822          sjmp Wait_Release
0E73 7F07      1823   Keypad_Key_7: mov R7, #7
0E75 801C      1824          sjmp Wait_Release
0E77 7F08      1825   Keypad_Key_8: mov R7, #8
0E79 8018      1826          sjmp Wait_Release
0E7B 7F09      1827   Keypad_Key_9: mov R7, #9
0E7D 8014      1828          sjmp Wait_Release
0E7F 7F0D      1829   Keypad_Key_C: mov R7, #13
0E81 8010      1830          sjmp Wait_Release
0E83 7F0E      1831   Keypad_Key_Star: mov R7, #14
0E85 800C      1832          sjmp Wait_Release
0E87 7F00      1833   Keypad_Key_0: mov R7, #0
0E89 8008      1834          sjmp Wait_Release
0E8B 7F0C      1835   Keypad_Key_Hash: mov R7, #12
0E8D 8004      1836          sjmp Wait_Release
0E8F 7F0F      1837   Keypad_Key_D: mov R7, #15
0E91 8000      1838          sjmp Wait_Release
0E93           1839   
0E93           1840   Wait_Release:
0E93 A2A2      1841       mov C, COL1
0E95 82A4      1842       anl C, COL2
0E97 82A6      1843       anl C, COL3
0E99 82B0      1844       anl C, COL4
0E9B 50F6      1845       jnc Wait_Release
0E9D D3        1846       setb C
0E9E D292      1847       setb ROW1
0EA0 D294      1848       setb ROW2
0EA2 D296      1849       setb ROW3
0EA4 D2A0      1850       setb ROW4
0EA6 22        1851       ret
0EA7           1852   
0EA7           1853   Wait_25ms:
0EA7           1854       ; 1. Check if we are already waiting
0EA7 20140E    1855       jb wait25_active, Check_Timer_Status
0EAA           1856       
0EAA           1857       ; 2. Check if we just finished
0EAA 301504    1858       jnb wait25_done, Start_New_Timer
0EAD           1859       
0EAD           1860       ; 3. Timer is DONE! Reset flags and return True
0EAD C215      1861       clr wait25_done
0EAF D3        1862       setb C          ; Carry = 1 means "Done"
0EB0 22        1863       ret
0EB1           1864   
0EB1           1865   Start_New_Timer:
0EB1           1866       ; 4. Start a new 25ms wait
0EB1 754F00    1867       mov wait25_count, #0
0EB4 D214      1868       setb wait25_active
0EB6 C3        1869       clr C           ; Carry = 0 means "Not Done Yet"
0EB7 22        1870       ret
0EB8           1871   
0EB8           1872   Check_Timer_Status:
0EB8           1873       ; 5. Still waiting... return False immediately
0EB8 C3        1874       clr C           ; Carry = 0 means "Not Done Yet"
0EB9 22        1875       ret
0EBA           1876   
0EBA           1877   ; ----------------------------------------------------------------
0EBA           1878   ; MODULE: BUFFER INIT (Reset Logic)
0EBA           1879   ; ----------------------------------------------------------------
0EBA           1880   Init_All_Buffers:
0EBA 7880      1881       mov R0, #Buf_Soak_Temp
0EBC 120ECF    1882       lcall Init_Temp_Template
0EBF 7889      1883       mov R0, #Buf_Refl_Temp
0EC1 120ECF    1884       lcall Init_Temp_Template
0EC4 7884      1885       mov R0, #Buf_Soak_Time
0EC6 120EDB    1886       lcall Init_Time_Template
0EC9 788D      1887       mov R0, #Buf_Refl_Time
0ECB 120EDB    1888       lcall Init_Time_Template
0ECE 22        1889       ret
0ECF           1890   
0ECF           1891   Init_Temp_Template:
0ECF 7630      1892       mov @R0, #'0'
0ED1 08        1893       inc R0
0ED2 7630      1894       mov @R0, #'0'
0ED4 08        1895       inc R0
0ED5 7630      1896       mov @R0, #'0'
0ED7 08        1897       inc R0
0ED8 7600      1898       mov @R0, #0
0EDA 22        1899       ret
0EDB           1900   
0EDB           1901   Init_Time_Template:
0EDB 7630      1902       mov @R0, #'0'
0EDD 08        1903       inc R0
0EDE 7630      1904       mov @R0, #'0'
0EE0 08        1905       inc R0
0EE1 7630      1906       mov @R0, #'0'
0EE3 08        1907       inc R0
0EE4 7630      1908       mov @R0, #'0'
0EE6 08        1909       inc R0
0EE7 7600      1910       mov @R0, #0
0EE9 22        1911       ret
0EEA           1912   
0EEA           1913   Reset_Current_Buffer:
0EEA E569      1914       mov A, Current_State
0EEC B40106    1915       cjne A, #1, Reset_Chk_2
0EEF 7880      1916       mov R0, #Buf_Soak_Temp
0EF1 120ECF    1917       lcall Init_Temp_Template
0EF4 22        1918       ret
0EF5           1919   Reset_Chk_2:
0EF5 B40206    1920       cjne A, #2, Reset_Chk_3
0EF8 7884      1921       mov R0, #Buf_Soak_Time
0EFA 120EDB    1922       lcall Init_Time_Template
0EFD 22        1923       ret
0EFE           1924   Reset_Chk_3:
0EFE B40306    1925       cjne A, #3, Reset_Chk_4
0F01 7889      1926       mov R0, #Buf_Refl_Temp
0F03 120ECF    1927       lcall Init_Temp_Template
0F06 22        1928       ret
0F07           1929   Reset_Chk_4:
0F07 788D      1930       mov R0, #Buf_Refl_Time
0F09 120EDB    1931       lcall Init_Time_Template
0F0C 22        1932       ret
0F0D           1933   
0F0D           1934   ; ----------------------------------------------------------------
0F0D           1935   ; MODULE: SCREEN UPDATE (Visual Logic)
0F0D           1936   ; ----------------------------------------------------------------
0F0D           1937   Update_Screen_Full:
0F0D 121005    1938       lcall Clear_Screen_Func
0F10 C0E0      1939            push acc
0F12 7401      1939            mov a, #1
0F14 14        1939            dec a
0F15 12062B    1939            lcall ?Set_Cursor_1 ; Select column and row
0F18 D0E0      1939            pop acc
0F1A           1940   
0F1A           1941       ; --- Draw Line 1 (Titles) ---
0F1A E569      1942       mov A, Current_State
0F1C B40013    1943       cjne A, #0, Update_State_1
0F1F C083      1944            push dph
0F21 C082      1944            push dpl
0F23 C0E0      1944            push acc
0F25 900350    1944            mov dptr, #Txt_Home
0F28 12061E    1944            lcall ?Send_Constant_String
0F2B D0E0      1944            pop acc
0F2D D082      1944            pop dpl
0F2F D083      1944            pop dph
0F31 22        1945       ret 
0F32           1946   Update_State_1:
0F32 B40114    1947       cjne A, #1, Update_State_2
0F35 C083      1948            push dph
0F37 C082      1948            push dpl
0F39 C0E0      1948            push acc
0F3B 900361    1948            mov dptr, #Txt_SoakT
0F3E 12061E    1948            lcall ?Send_Constant_String
0F41 D0E0      1948            pop acc
0F43 D082      1948            pop dpl
0F45 D083      1948            pop dph
0F47 8042      1949       sjmp Draw_Temp_Format
0F49           1950   Update_State_2:
0F49 B40214    1951       cjne A, #2, Update_State_3
0F4C C083      1952            push dph
0F4E C082      1952            push dpl
0F50 C0E0      1952            push acc
0F52 900372    1952            mov dptr, #Txt_SoakTime
0F55 12061E    1952            lcall ?Send_Constant_String
0F58 D0E0      1952            pop acc
0F5A D082      1952            pop dpl
0F5C D083      1952            pop dph
0F5E 8042      1953       sjmp Draw_Time_Format
0F60           1954   Update_State_3:
0F60 B40314    1955       cjne A, #3, Update_State_4
0F63 C083      1956            push dph
0F65 C082      1956            push dpl
0F67 C0E0      1956            push acc
0F69 900383    1956            mov dptr, #Txt_ReflT
0F6C 12061E    1956            lcall ?Send_Constant_String
0F6F D0E0      1956            pop acc
0F71 D082      1956            pop dpl
0F73 D083      1956            pop dph
0F75 8014      1957       sjmp Draw_Temp_Format
0F77           1958   Update_State_4:
0F77 C083      1959            push dph
0F79 C082      1959            push dpl
0F7B C0E0      1959            push acc
0F7D 900394    1959            mov dptr, #Txt_ReflTime
0F80 12061E    1959            lcall ?Send_Constant_String
0F83 D0E0      1959            pop acc
0F85 D082      1959            pop dpl
0F87 D083      1959            pop dph
0F89 8017      1960       sjmp Draw_Time_Format
0F8B           1961   
0F8B           1962   ; --- Draw Line 2 (Values) ---
0F8B           1963   Draw_Temp_Format:
0F8B C0E0      1964            push acc
0F8D 7401      1964            mov a, #1
0F8F 14        1964            dec a
0F90 120629    1964            lcall ?Set_Cursor_2 ; Select column and row
0F93 D0E0      1964            pop acc
0F95 121018    1965       lcall Get_Current_Buffer_Addr
0F98 120FF5    1966       lcall Print_String_RAM
0F9B 7443      1967       mov A, #'C'
0F9D 1205E1    1968       lcall ?WriteData
0FA0 8027      1969       sjmp Restore_Cursor
0FA2           1970   
0FA2           1971   Draw_Time_Format:
0FA2 C0E0      1972            push acc
0FA4 7401      1972            mov a, #1
0FA6 14        1972            dec a
0FA7 120629    1972            lcall ?Set_Cursor_2 ; Select column and row
0FAA D0E0      1972            pop acc
0FAC 121018    1973       lcall Get_Current_Buffer_Addr
0FAF           1974       ; MM
0FAF E6        1975       mov A, @R0
0FB0 1205E1    1976       lcall ?WriteData
0FB3 08        1977       inc R0
0FB4 E6        1978       mov A, @R0
0FB5 1205E1    1979       lcall ?WriteData
0FB8 08        1980       inc R0
0FB9           1981       ; Colon
0FB9 743A      1982       mov A, #':'
0FBB 1205E1    1983       lcall ?WriteData
0FBE           1984       ; SS
0FBE E6        1985       mov A, @R0
0FBF 1205E1    1986       lcall ?WriteData
0FC2 08        1987       inc R0
0FC3 E6        1988       mov A, @R0
0FC4 1205E1    1989       lcall ?WriteData
0FC7           1990       ; Unit
0FC7           1991       ;got rid of the "s"
0FC7           1992       ;mov A, #'s'
0FC7           1993       ;lcall ?WriteData
0FC7 8000      1994       sjmp Restore_Cursor
0FC9           1995   
0FC9           1996   ; --- Restore Cursor Position ---
0FC9           1997   Restore_Cursor:
0FC9 E569      1998       mov A, Current_State
0FCB B40202    1999       cjne A, #2, RC_Check_State_4  
0FCE 800D      2000       sjmp Adjust_Cursor_Time
0FD0           2001   RC_Check_State_4:             
0FD0 B40402    2002       cjne A, #4, Normal_Cursor
0FD3 8008      2003       sjmp Adjust_Cursor_Time
0FD5           2004   
0FD5           2005   Normal_Cursor:
0FD5 E572      2006       mov A, Cursor_Idx
0FD7 24C0      2007       add A, #0xC0
0FD9 1205E6    2008       lcall ?WriteCommand
0FDC 22        2009       ret
0FDD           2010   
0FDD           2011   Adjust_Cursor_Time:
0FDD           2012       ; Skip the colon index (2)
0FDD E572      2013       mov A, Cursor_Idx
0FDF B40201    2014       cjne A, #2, No_Skip
0FE2 04        2015       inc A 
0FE3           2016   No_Skip:
0FE3           2017       ; Add 1 if past the colon
0FE3 C3        2018       clr C
0FE4 9402      2019       subb A, #2
0FE6 4005      2020       jc No_Add
0FE8 E572      2021       mov A, Cursor_Idx
0FEA 04        2022       inc A
0FEB 8002      2023       sjmp Final_Cursor_Set
0FED           2024   No_Add:
0FED E572      2025       mov A, Cursor_Idx
0FEF           2026   Final_Cursor_Set:
0FEF 24C0      2027       add A, #0xC0
0FF1 1205E6    2028       lcall ?WriteCommand
0FF4 22        2029       ret
0FF5           2030   
0FF5           2031   Print_String_RAM:
0FF5 E6        2032       mov A, @R0
0FF6 6006      2033       jz Print_String_Done
0FF8 1205E1    2034       lcall ?WriteData
0FFB 08        2035       inc R0
0FFC 80F7      2036       sjmp Print_String_RAM
0FFE           2037   Print_String_Done:
0FFE 22        2038       ret
0FFF           2039   
0FFF           2040   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0FFF           2041   Wait_25ms_BLOCKING:
0FFF 120EA7    2042       lcall Wait_25ms
1002 50FB      2043       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
1004 22        2044       ret
1005           2045   
1005           2046   Clear_Screen_Func:
1005 7401      2047       mov A, #0x01
1007 1205E6    2048       lcall ?WriteCommand
100A           2049       
100A           2050       ; --- FIX: HARDWARE DELAY LOOP (MAX STRENGTH) ---
100A           2051       ; The LCD needs ~2ms to clear. 
100A           2052       ; We use R0=255 to guarantee ~5ms+ delay.
100A           2053       ; This ensures the LCD is 100% ready before we send "Ramp to Soak".
100A 78FF      2054       mov R0, #255
100C           2055   Clear_Delay_Loop_Outer:
100C 79FF      2056       mov R1, #255
100E           2057   Clear_Delay_Loop_Inner:
100E D9FE      2058       djnz R1, Clear_Delay_Loop_Inner
1010 D8FA      2059       djnz R0, Clear_Delay_Loop_Outer
1012           2060       ; -----------------------------------------------
1012           2061   
1012 740C      2062       mov A, #0x0C  ; Display ON, Cursor OFF
1014 1205E6    2063       lcall ?WriteCommand
1017 22        2064       ret
1018           2065   
1018           2066   Get_Current_Buffer_Addr:
1018 E569      2067       mov A, Current_State
101A B40103    2068       cjne A, #1, Get_Buf_2
101D 7880      2069       mov R0, #Buf_Soak_Temp
101F 22        2070       ret
1020           2071   Get_Buf_2:
1020 B40203    2072       cjne A, #2, Get_Buf_3
1023 7884      2073       mov R0, #Buf_Soak_Time
1025 22        2074       ret
1026           2075   Get_Buf_3:
1026 B40303    2076       cjne A, #3, Get_Buf_4
1029 7889      2077       mov R0, #Buf_Refl_Temp
102B 22        2078       ret
102C           2079   Get_Buf_4:
102C 788D      2080       mov R0, #Buf_Refl_Time
102E 22        2081       ret
102F           2082       
102F           2083   ; --- Helper to prevent "Machine Gun" button presses ---
102F           2084   Wait_For_P1_0_Release:
102F 3090FD    2085       jnb P1.0, $    ; Wait here while the button is still pressed (0)
1032 22        2086       ret
1033           2087   
1033           2088   ; --- Full reset helper for P3.7 (active-low) ---
1033           2089   Wait_For_P3_7_Release:
1033 30B7FD    2090       jnb P3_7, $    ; Wait here while the button is still pressed (0)
1036 22        2091       ret
1037           2092   
1037           2093   Full_Reset:
1037 121033    2094       lcall Wait_For_P3_7_Release
103A 020BC6    2095       ljmp main
103D           2096   
103D           2097   ; ================================================================
103D           2098   ; MODULE: THERMOCOUPLE ADC DRIVER (WITH NOISE SUPPRESSION & JUMP FIX)
103D           2099   ; ================================================================
103D           2100   Read_Thermocouple:
103D           2101       ; 1. Check Non-Blocking Timer
103D 120EA7    2102       lcall Wait_25ms
1040           2103       
1040           2104       ; [FIX] TRAMPOLINE JUMP
1040           2105       ; "jnc" cannot jump to the end because the code is too long.
1040           2106       ; We invert logic: If Carry=1 (Time is up), Jump NEARBY.
1040 4001      2107       jc Proceed_Reading
1042 22        2108       ret  ; If Carry=0, Return immediately.
1043           2109   
1043           2110   Proceed_Reading:
1043           2111       ; --- 25ms Passed! Time to Read ---
1043           2112   
1043           2113       ; [FIX] SILENCE THE BUZZER (Noise Suppression)
1043           2114       ; Save buzzer state and force it OFF during the sensitive read
1043 E588      2115       mov A, TCON      
1045 5410      2116       anl A, #0x10     ; Isolate TR0 bit
1047 C0E0      2117       push acc         ; Save it
1049 C28C      2118       clr TR0          ; STOP NOISE
104B           2119   
104B           2120       ; 2. Initialize / Trigger ADC
104B 75A180    2121       mov ADC_C, #0x80    ; Reset
104E 00        2122       nop
104F 00        2123       nop
1050 75A101    2124       mov ADC_C, #0x01    ; Start Channel 0
1053           2125       
1053           2126       ; 3. Settle Delay
1053 7DFA      2127       mov R5, #250
1055           2128   ADC_Settle_Loop:
1055 00        2129       nop
1056 00        2130       nop
1057 DDFC      2131       djnz R5, ADC_Settle_Loop
1059           2132       
1059           2133       ; 4. Read Raw Data
1059 85A232    2134       mov x+0, ADC_L
105C 85A333    2135       mov x+1, ADC_H
105F 753400    2136       mov x+2, #0
1062 753500    2137       mov x+3, #0
1065           2138       
1065           2139       ; 5. Mask Data
1065 E533      2140       mov a, x+1
1067 540F      2141       anl a, #0x0F
1069 F533      2142       mov x+1, a
106B           2143       
106B           2144       ; [FIX] RESTORE THE BUZZER
106B D0E0      2145       pop acc          ; Get previous state
106D 6002      2146       jz Skip_Restore  ; If it was OFF, keep it OFF
106F D28C      2147       setb TR0         ; If it was ON, turn it back ON
1071           2148   Skip_Restore:
1071           2149   
1071           2150       ; 6. Math Conversions
1071 753616    2151            mov y+0, #low (4118 % 0x10000) 
1074 753710    2151            mov y+1, #high(4118 % 0x10000) 
1077 753800    2151            mov y+2, #low (4118 / 0x10000) 
107A 753900    2151            mov y+3, #high(4118 / 0x10000) 
107D 12018C    2152       lcall mul32       
1080           2153   
1080 75A104    2154       mov ADC_C, #0x04    ; Read LM4040
1083 85A236    2155       mov y+0, ADC_L      
1086 85A337    2156       mov y+1, ADC_H      
1089 753800    2157       mov y+2, #0
108C 753900    2158       mov y+3, #0
108F 75A100    2159       mov ADC_C, #0x00    ; Reset
1092           2160       
1092 120280    2161       lcall div32         
1095 753664    2162            mov y+0, #low (100 % 0x10000) 
1098 753700    2162            mov y+1, #high(100 % 0x10000) 
109B 753800    2162            mov y+2, #low (100 / 0x10000) 
109E 753900    2162            mov y+3, #high(100 / 0x10000) 
10A1 12018C    2163       lcall mul32
10A4 75362B    2164            mov y+0, #low (1323 % 0x10000) 
10A7 753705    2164            mov y+1, #high(1323 % 0x10000) 
10AA 753800    2164            mov y+2, #low (1323 / 0x10000) 
10AD 753900    2164            mov y+3, #high(1323 / 0x10000)         
10B0 120280    2165       lcall div32    
10B3 753614    2166            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
10B6 753700    2166            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
10B9 753800    2166            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
10BC 753900    2166            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
10BF 1200D3    2167       lcall add32     
10C2           2168       
10C2           2169       ; 8. Store Result
10C2 85323F    2170       mov current_temp+0, x+0
10C5 853340    2171       mov current_temp+1, x+1
10C8 853441    2172       mov current_temp+2, x+2
10CB 853542    2173       mov current_temp+3, x+3
10CE           2174   
10CE 22        2175       ret
10CF           2176       
10CF           2177   ; ================================================================
10CF           2178   ; MODULE: POWER CONTROLLER (The Brain)
10CF           2179   ; ================================================================
10CF           2180   Power_Control:
10CF           2181       ; Default: Turn Heat OFF (Safety)
10CF 755C00    2182       mov power_output+0, #0
10D2 755D00    2183       mov power_output+1, #0
10D5 755E00    2184       mov power_output+2, #0
10D8 755F00    2185       mov power_output+3, #0
10DB           2186   
10DB E568      2187       mov a, Control_FSM_state
10DD           2188   
10DD           2189       ; --- State 2: RAMP TO SOAK ---
10DD B40202    2190       cjne a, #2, PC_Check_Soak
10E0           2191       ; Mode: Full Speed Ahead
10E0 8016      2192       sjmp Set_Max_Power
10E2           2193   
10E2           2194   PC_Check_Soak:
10E2           2195       ; --- State 3: SOAK PHASE ---
10E2 B40305    2196       cjne a, #3, PC_Check_Ramp_Reflow
10E5           2197       ; Mode: Maintenance (Low Power)
10E5           2198       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
10E5 20030F    2199       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
10E8 801B      2200       sjmp Set_20_Percent_Power     ; If cold, use 20%
10EA           2201   
10EA           2202   PC_Check_Ramp_Reflow:
10EA           2203       ; --- State 4: RAMP TO REFLOW ---
10EA B40402    2204       cjne a, #4, PC_Check_Reflow
10ED           2205       ; Mode: Full Speed Ahead
10ED 8009      2206       sjmp Set_Max_Power
10EF           2207   
10EF           2208   PC_Check_Reflow:
10EF           2209       ; --- State 5: REFLOW PHASE ---
10EF B40505    2210       cjne a, #5, PC_Done
10F2           2211       ; Mode: Maintenance (Low Power)
10F2 200402    2212       jb reflow_temp_reached, PC_Done
10F5 800E      2213       sjmp Set_20_Percent_Power
10F7           2214   
10F7           2215   PC_Done:
10F7 22        2216       ret
10F8           2217   
10F8           2218   ; --- Power Helpers ---
10F8           2219   
10F8           2220   Set_Max_Power:
10F8           2221       ; Load 1500 (0x05DC) = 100% Duty Cycle
10F8 755CDC    2222       mov power_output+0, #0xDC
10FB 755D05    2223       mov power_output+1, #0x05
10FE 755E00    2224       mov power_output+2, #0
1101 755F00    2225       mov power_output+3, #0
1104 22        2226       ret
1105           2227   
1105           2228   Set_20_Percent_Power:
1105           2229       ; Load 300 (0x012C) = 20% Duty Cycle
1105 755C2C    2230       mov power_output+0, #0x2C
1108 755D01    2231       mov power_output+1, #0x01
110B 755E00    2232       mov power_output+2, #0
110E 755F00    2233       mov power_output+3, #0
1111 22        2234       ret
1112           2235   
1112           2236   
1112           2237   ;--------------------------------------------------------------
1112           2238   ; set servo angle according to the state
1112           2239   ; call servo control function every 1ms
1112           2240   ;--------------------------------------------------------------
1112           2241   call_servo_control:
1112           2242            ; check current state and change servo angle
1112 E568      2243            mov a, Control_FSM_state
1114           2244            
1114           2245            ; handle state 0
1114 B40004    2246            cjne a, #0, servo_state1
1117 C21F      2247            clr servo_angle_zero ; close door at state 0
1119 802C      2248            sjmp check_servo_flag
111B           2249   
111B           2250            ; handle state 1
111B           2251            servo_state1:
111B B40104    2252            cjne a, #1, servo_state2
111E D21F      2253            setb servo_angle_zero ; open door at state 1
1120 8025      2254            sjmp check_servo_flag
1122           2255   
1122           2256            ; handle state 2
1122           2257            servo_state2:
1122 B40204    2258            cjne a, #2, servo_state3
1125 C21F      2259            clr servo_angle_zero ; close door at state 2
1127 801E      2260            sjmp check_servo_flag
1129           2261   
1129           2262            ; handle state 3
1129           2263            servo_state3:
1129 B40304    2264            cjne a, #3, servo_state4
112C C21F      2265            clr servo_angle_zero ; close door at state 3
112E 8017      2266            sjmp check_servo_flag
1130           2267   
1130           2268            ; handle state 4
1130           2269            servo_state4:
1130 B40404    2270            cjne a, #4, servo_state5
1133 C21F      2271            clr servo_angle_zero ; close door at state 4
1135 8010      2272            sjmp check_servo_flag
1137           2273   
1137           2274            ; handle state 5
1137           2275            servo_state5:
1137 B40504    2276            cjne a, #5, servo_state6
113A C21F      2277            clr servo_angle_zero ; close door at state 5
113C 8009      2278            sjmp check_servo_flag
113E           2279   
113E           2280            ; handle state 6
113E           2281            servo_state6:
113E B40604    2282            cjne a, #6, servo_state7
1141 C21F      2283            clr servo_angle_zero ; close door at state 6
1143 8002      2284            sjmp check_servo_flag
1145           2285   
1145           2286            ; handle state 7
1145           2287            servo_state7:
1145 D21F      2288            setb servo_angle_zero ; open door at state 7
1147           2289   
1147           2290   check_servo_flag:
1147           2291            ; check 1 ms flag
1147 101E01    2292            jbc one_millisecond_flag_servo, run_servo_control
114A 22        2293            ret
114B           2294   
114B           2295   run_servo_control:
114B 12114F    2296            lcall servo_control
114E 22        2297            ret
114F           2298   
114F           2299   
114F           2300   ;---------------------------------------------------------------
114F           2301   ; servo control
114F           2302   ; generate a 20 ms period pwm signal to control the servo motor
114F           2303   ; able to make the servo motor stay at 0 degree and 180 degree
114F           2304   ;---------------------------------------------------------------
114F           2305   servo_control:
114F D2ED      2306       setb LEDRA.5
1151 C0E0      2307            push acc
1153 C0D0      2308            push psw
1155 E577      2309            mov a, servo_pwm_counter ; move servo counter to accumulator
1157 04        2310            inc A ; a += 1
1158 B41402    2311            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
115B 7400      2312            mov a, #0
115D           2313   
115D           2314   servo_pwm_angle_compare: ; read target angle
115D F577      2315            mov servo_pwm_counter, A
115F 201F09    2316            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
1162           2317            ; set servo motor to 180 degrees
1162 E577      2318            mov a, servo_pwm_counter
1164 C3        2319            clr c
1165 9402      2320            subb a, #SERVO_180
1167 400B      2321            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
1169 800D      2322            sjmp servo_pwm_set_low ; set low if greater
116B           2323   
116B           2324   set_zero_degree:
116B           2325            ; set servo motor to 0 degree
116B E577      2326            mov a, servo_pwm_counter
116D C3        2327            clr c
116E 9401      2328            subb a, #SERVO_0
1170 4002      2329            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
1172 8004      2330            sjmp servo_pwm_set_low ; set low if greater
1174           2331   
1174           2332   servo_pwm_set_high:
1174           2333            ; set pwm pin high
1174 D2B6      2334            setb SERVO_OUT
1176 8002      2335            sjmp servo_control_done
1178           2336   
1178           2337   servo_pwm_set_low:
1178           2338            ; set pwm pin low
1178 C2B6      2339            clr SERVO_OUT
117A           2340   
117A           2341   servo_control_done:
117A D0D0      2342            pop psw
117C D0E0      2343            pop acc
117E 22        2344            ret
117F           2345   
117F           2346   ;-------------------------------------------------------------------------------
117F           2347   ; power_control
117F           2348   ;-------------------------------------------------------------------------------
117F           2349   ; Determine the power output based on current state and current temperature 
117F           2350   ; input parameter: Control_FSM_state
117F           2351   ;-------------------------------------------------------------------------------
117F           2352   
117F           2353   proportional_power_control:
117F E568      2354            mov a, Control_FSM_state
1181           2355   
1181           2356   state0_power_control:
1181           2357            ; idle
1181           2358            ; 0% power
1181 B4000F    2359            cjne a, #0, state1_power_control
1184 755C00    2360            mov power_output, #low(NO_POWER)
1187 755D00    2361            mov power_output+1, #low(NO_POWER)
118A 755E00    2362            mov power_output+2, #0
118D 755F00    2363            mov power_output+3, #0
1190 02132B    2364            ljmp power_control_done
1193           2365   
1193           2366   state1_power_control:
1193           2367            ; idle
1193           2368            ; 0% power
1193 B4010F    2369            cjne a, #1, state2_power_control
1196 755C00    2370            mov power_output, #low(NO_POWER)
1199 755D00    2371            mov power_output+1, #low(NO_POWER)
119C 755E00    2372            mov power_output+2, #0
119F 755F00    2373            mov power_output+3, #0
11A2 02132B    2374            ljmp power_control_done
11A5           2375            
11A5           2376   state2_power_control:
11A5           2377            ; ramp to soak, ramp to ~150C
11A5           2378            ; 100% power
11A5 B4020F    2379            cjne a, #2, state3_power_control
11A8 755CDC    2380            mov power_output, #low(MAX_POWER)
11AB 755D05    2381            mov power_output+1, #high(MAX_POWER)
11AE 755E00    2382            mov power_output+2, #0
11B1 755F00    2383            mov power_output+3, #0
11B4 02132B    2384            ljmp power_control_done
11B7           2385   
11B7           2386   state3_power_control:
11B7           2387            ; soak period, hold at 150C
11B7           2388            ; 20% base power + proportional calculated power
11B7 B40302    2389            cjne a, #3, jump_state4_power_control
11BA 8003      2390            sjmp state3_power_control_calculation
11BC           2391   
11BC           2392   jump_state4_power_control:
11BC 0212E9    2393            ljmp state4_power_control
11BF           2394   
11BF           2395   state3_power_control_calculation:
11BF           2396            ; move soak_temp to x
11BF 854332    2397            mov x, soak_temp
11C2 854433    2398            mov x+1, soak_temp+1
11C5 854534    2399            mov x+2, soak_temp+2
11C8 854635    2400            mov x+3, soak_temp+3
11CB           2401            ; move current_temp to y
11CB 853F36    2402            mov y, current_temp
11CE 854037    2403            mov y+1, current_temp+1
11D1 854138    2404            mov y+2, current_temp+2
11D4 854239    2405            mov y+3, current_temp+3
11D7           2406   
11D7           2407            ; compare between soak_temp and current_temp
11D7 C200      2408            clr mf
11D9 120178    2409            lcall x_gteq_y
11DC 10002B    2410            jbc mf, st_sub_ct
11DF           2411            ; current_temp - soak_temp if st < ct
11DF C220      2412            clr soak_temp_greater
11E1           2413            ; move current_temp to y
11E1 854336    2414            mov y, soak_temp
11E4 854437    2415            mov y+1, soak_temp+1
11E7 854538    2416            mov y+2, soak_temp+2
11EA 854639    2417            mov y+3, soak_temp+3
11ED           2418            ; move current_temp to x
11ED 853F32    2419            mov x, current_temp
11F0 854033    2420            mov x+1, current_temp+1
11F3 854134    2421            mov x+2, current_temp+2
11F6 854235    2422            mov x+3, current_temp+3
11F9 1200F6    2423            lcall sub32
11FC 85326A    2424            mov soak_temp_diff, x
11FF 85336B    2425            mov soak_temp_diff+1, x+1
1202 85346C    2426            mov soak_temp_diff+2, x+2
1205 85356D    2427            mov soak_temp_diff+3, x+3
1208 8011      2428            sjmp proportional_input_soak
120A           2429   
120A           2430   st_sub_ct:
120A           2431            ; soak_temp - current_temp
120A D220      2432            setb soak_temp_greater
120C 1200F6    2433            lcall sub32
120F 85326A    2434            mov soak_temp_diff, x
1212 85336B    2435            mov soak_temp_diff+1, x+1
1215 85346C    2436            mov soak_temp_diff+2, x+2
1218 85356D    2437            mov soak_temp_diff+3, x+3
121B           2438   
121B           2439   proportional_input_soak:
121B           2440            ; proportaional block calculation       
121B           2441            ; move soak_temp_diff to x
121B 856A32    2442            mov x, soak_temp_diff
121E 856B33    2443            mov x+1, soak_temp_diff+1
1221 856C34    2444            mov x+2, soak_temp_diff+2
1224 856D35    2445            mov x+3, soak_temp_diff+3
1227           2446            ; move proportional gain to y
1227 753605    2447            mov y+0, #low (KP % 0x10000) 
122A 753700    2447            mov y+1, #high(KP % 0x10000) 
122D 753800    2447            mov y+2, #low (KP / 0x10000) 
1230 753900    2447            mov y+3, #high(KP / 0x10000) 
1233 12018C    2448            lcall mul32 ; proportional_output = proportional_gain * difference
1236           2449            
1236 85326E    2450            mov proportional_gain_var, x
1239 85336F    2451            mov proportional_gain_var+1, x+1
123C 853470    2452            mov proportional_gain_var+2, x+2
123F 853571    2453            mov proportional_gain_var+3, x+3
1242           2454   
1242           2455            ; base_power + soak_power when soak_temp > current_temp
1242 302029    2456            jnb soak_temp_greater, sub_proportional_soak
1245 856E32    2457            mov x, proportional_gain_var
1248 856F33    2458            mov x+1, proportional_gain_var+1
124B 857034    2459            mov x+2, proportional_gain_var+2
124E 857135    2460            mov x+3, proportional_gain_var+3
1251 75362C    2461            mov y+0, #low (BASE_POWER % 0x10000) 
1254 753701    2461            mov y+1, #high(BASE_POWER % 0x10000) 
1257 753800    2461            mov y+2, #low (BASE_POWER / 0x10000) 
125A 753900    2461            mov y+3, #high(BASE_POWER / 0x10000) 
125D 1200D3    2462            lcall add32
1260           2463            ; x now holds the power output before the saturator
1260 85326E    2464            mov proportional_gain_var, x
1263 85336F    2465            mov proportional_gain_var+1, x+1
1266 853470    2466            mov proportional_gain_var+2, x+2
1269 853571    2467            mov proportional_gain_var+3, x+3
126C 803D      2468            sjmp saturator_soak
126E           2469   
126E           2470   sub_proportional_soak:
126E           2471            ; base_power - soak_power when soak_temp <= current_temp
126E 75322C    2472            mov x+0, #low (BASE_POWER % 0x10000) 
1271 753301    2472            mov x+1, #high(BASE_POWER % 0x10000) 
1274 753400    2472            mov x+2, #low (BASE_POWER / 0x10000) 
1277 753500    2472            mov x+3, #high(BASE_POWER / 0x10000) 
127A 856E36    2473            mov y, proportional_gain_var
127D 856F37    2474            mov y+1, proportional_gain_var+1
1280 857038    2475            mov y+2, proportional_gain_var+2
1283 857139    2476            mov y+3, proportional_gain_var+3
1286           2477   
1286           2478            ; compare whether base_power < proportional_gain_var
1286 C200      2479            clr mf
1288 12011A    2480            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
128B 30000E    2481            jnb mf, bp_gteq_pgv
128E 756E00    2482            mov proportional_gain_var, #low(NO_POWER)
1291 756F00    2483            mov proportional_gain_var+1, #high(NO_POWER)
1294 757000    2484            mov proportional_gain_var+2, #0
1297 757100    2485            mov proportional_gain_var+3, #0
129A 800F      2486            sjmp saturator_soak
129C           2487   
129C           2488   bp_gteq_pgv:
129C           2489            ; calculate subtracted gain
129C 1200F6    2490            lcall sub32
129F           2491            ; x now holds the power output before the saturator
129F 85326E    2492            mov proportional_gain_var, x
12A2 85336F    2493            mov proportional_gain_var+1, x+1
12A5 853470    2494            mov proportional_gain_var+2, x+2
12A8 853571    2495            mov proportional_gain_var+3, x+3
12AB           2496   
12AB           2497   saturator_soak:
12AB           2498            ; proportional_gain_var now holds the power output before the saturator
12AB           2499            ; saturate power output to max power
12AB 856E32    2500            mov x, proportional_gain_var
12AE 856F33    2501            mov x+1, proportional_gain_var+1
12B1 857034    2502            mov x+2, proportional_gain_var+2
12B4 857135    2503            mov x+3, proportional_gain_var+3
12B7           2504   
12B7 7536DC    2505            mov y+0, #low (MAX_POWER % 0x10000) 
12BA 753705    2505            mov y+1, #high(MAX_POWER % 0x10000) 
12BD 753800    2505            mov y+2, #low (MAX_POWER / 0x10000) 
12C0 753900    2505            mov y+3, #high(MAX_POWER / 0x10000) 
12C3           2506   
12C3 C200      2507            clr mf
12C5 120136    2508            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
12C8 20000F    2509            jb mf, saturated_soak
12CB           2510            ; set power_output to calculated power if not saturated
12CB 856E5C    2511            mov power_output, proportional_gain_var
12CE 856F5D    2512            mov power_output+1, proportional_gain_var+1
12D1 85705E    2513            mov power_output+2, proportional_gain_var+2
12D4 85715F    2514            mov power_output+3, proportional_gain_var+3
12D7 02132B    2515            ljmp power_control_done
12DA           2516   
12DA           2517   saturated_soak:
12DA 755CDC    2518            mov power_output, #low(MAX_POWER)
12DD 755D05    2519            mov power_output+1, #high(MAX_POWER)
12E0 755E00    2520            mov power_output+2, #0
12E3 755F00    2521            mov power_output+3, #0
12E6 02132B    2522            ljmp power_control_done
12E9           2523   
12E9           2524   
12E9           2525   state4_power_control:
12E9           2526            ; ramp to reflow, max power
12E9 B4040F    2527            cjne a, #4, state5_power_control
12EC 755CDC    2528            mov power_output, #low(MAX_POWER)
12EF 755D05    2529            mov power_output+1, #high(MAX_POWER)
12F2 755E00    2530            mov power_output+2, #0
12F5 755F00    2531            mov power_output+3, #0
12F8 02132B    2532            ljmp power_control_done
12FB           2533   
12FB           2534   state5_power_control:
12FB           2535            ; reflow 20% base power
12FB B4050F    2536            cjne a, #5, state6_power_control
12FE 755C2C    2537            mov power_output, #low(BASE_POWER)  
1301 755D01    2538            mov power_output+1, #high(BASE_POWER)
1304 755E00    2539            mov power_output+2, #0
1307 755F00    2540            mov power_output+3, #0
130A 02132B    2541            ljmp power_control_done
130D           2542   
130D           2543   state6_power_control:
130D           2544            ; cooling 0% power
130D B4060F    2545            cjne a, #6, state_7_power_control
1310 755C00    2546            mov power_output, #low(NO_POWER)
1313 755D00    2547            mov power_output+1, #high(NO_POWER)
1316 755E00    2548            mov power_output+2, #0
1319 755F00    2549            mov power_output+3, #0
131C 02132B    2550            ljmp power_control_done
131F           2551   
131F           2552   state_7_power_control:
131F           2553            ; idle 0% power
131F 755C00    2554            mov power_output, #low(NO_POWER)
1322 755D00    2555            mov power_output+1, #high(NO_POWER)
1325 755E00    2556            mov power_output+2, #0
1328 755F00    2557            mov power_output+3, #0
132B           2558   
132B           2559   power_control_done:
132B 22        2560            ret
132C           2561   
132C           2562   ; ================================================================
132C           2563   ; SERIAL COMMUNICATION BLOCK (Paste before END)
132C           2564   ; ================================================================
132C           2565   
132C           2566   ; ----------------------------------------------------------------
132C           2567   ; ----------------------------------------------------------------
132C           2568   ; ISR: Catch incoming characters from Python
132C           2569   ; ----------------------------------------------------------------
132C           2570   Serial_ISR:
132C C0E0      2571       push acc
132E C0D0      2572       push psw
1330 C000      2573       push AR0
1332           2574       
1332           2575       ; --- CRITICAL FIX: Check & Clear Transmit Flag ---
1332 309904    2576       jnb TI, Check_RI      ; If TI is 0, check RX
1335 C299      2577       clr TI                ; CLEAR TI! (Stops the infinite loop)
1337 8031      2578       sjmp Serial_Done_Safe ; Exit immediately (We don't need to read anything for TX)
1339           2579   
1339           2580   Check_RI:
1339 30982E    2581       jnb RI, Serial_Done_Safe ; If RX is also 0, just exit
133C C298      2582       clr RI                   ; Clear RX flag
133E           2583   
133E E599      2584       mov a, SBUF              ; Read character
1340           2585       
1340           2586       ; Check for Newline (End of Command)
1340 B40A02    2587       cjne a, #10, Check_CR   
1343 8017      2588       sjmp End_Of_Command
1345           2589   Check_CR:
1345 B40D02    2590       cjne a, #13, Store_Char 
1348 8012      2591       sjmp End_Of_Command
134A           2592   
134A           2593   Store_Char:
134A           2594       ; Safety limit 7 chars
134A E580      2595       mov a, rx_index
134C B40702    2596       cjne a, #7, Save_It
134F 8019      2597       sjmp Serial_Done_Safe
1351           2598   Save_It:
1351 7878      2599       mov R0, #rx_buffer
1353 28        2600       add a, R0
1354 F8        2601       mov R0, a
1355 E599      2602       mov a, SBUF
1357 F6        2603       mov @R0, a
1358 0580      2604       inc rx_index
135A 800E      2605       sjmp Serial_Done_Safe
135C           2606   
135C           2607   End_Of_Command:
135C           2608       ; Null-terminate string
135C E580      2609       mov a, rx_index
135E 7878      2610       mov R0, #rx_buffer
1360 28        2611       add a, R0
1361 F8        2612       mov R0, a
1362 7600      2613       mov @R0, #0
1364           2614       
1364 758000    2615       mov rx_index, #0        ; Reset
1367 758101    2616       mov cmd_received, #1    ; Flag Main Loop
136A           2617   
136A           2618   Serial_Done_Safe:           ; <--- Renamed label to avoid "Redefine Symbol" errors
136A D000      2619       pop AR0
136C D0D0      2620       pop psw
136E D0E0      2621       pop acc
1370 32        2622       reti
1371           2623   
1371           2624   ; ----------------------------------------------------------------
1371           2625   ; PROCESSOR: Apply the command to variables
1371           2626   ; ----------------------------------------------------------------
1371           2627   Process_Serial_Command:
1371           2628       ; --- CHECK FLAG (BYTE SAFE) ---
1371 E581      2629       mov a, cmd_received
1373 6063      2630       jz Serial_Ret         ; If 0, exit
1375           2631       ; ------------------------------
1375           2632   
1375 758100    2633       mov cmd_received, #0  ; Clear flag
1378           2634   
1378 7878      2635       mov R0, #rx_buffer
137A E6        2636       mov a, @R0            ; Load Command Letter
137B           2637       
137B           2638       ; S = Soak Temp
137B B4530C    2639       cjne a, #'S', Check_K
137E 08        2640       inc R0 ; Skip S
137F 08        2641       inc R0 ; Skip :
1380 1213D9    2642       lcall Parse_Serial_Num
1383 8F43      2643       mov soak_temp+0, R7
1385 754400    2644       mov soak_temp+1, #0
1388 804E      2645       sjmp Serial_Ret
138A           2646   
138A           2647   Check_K: ; K = Soak Time
138A B44B0C    2648       cjne a, #'K', Check_R
138D 08        2649       inc R0 ; Skip K
138E 08        2650       inc R0 ; Skip :
138F 1213D9    2651       lcall Parse_Serial_Num
1392 8F54      2652       mov soak_time+0, R7
1394 755500    2653       mov soak_time+1, #0
1397 803F      2654       sjmp Serial_Ret
1399           2655   
1399           2656   Check_R: ; R = Reflow Temp
1399 B4520C    2657       cjne a, #'R', Check_L
139C 08        2658       inc R0 ; Skip R
139D 08        2659       inc R0 ; Skip :
139E 1213D9    2660       lcall Parse_Serial_Num
13A1 8F47      2661       mov reflow_temp+0, R7
13A3 754800    2662       mov reflow_temp+1, #0
13A6 8030      2663       sjmp Serial_Ret
13A8           2664   
13A8           2665   Check_L: ; L = Reflow Time
13A8 B44C0C    2666       cjne a, #'L', Check_Run
13AB 08        2667       inc R0 ; Skip L
13AC 08        2668       inc R0 ; Skip :
13AD 1213D9    2669       lcall Parse_Serial_Num
13B0 8F58      2670       mov reflow_time+0, R7
13B2 755900    2671       mov reflow_time+1, #0
13B5 8021      2672       sjmp Serial_Ret
13B7           2673   
13B7           2674   Check_Run: ; RUN:1 or RUN:0
13B7           2675       ; We check the character at index 4 (R, U, N, :, [1])
13B7 7878      2676       mov R0, #rx_buffer
13B9 08        2677       inc R0 ; R
13BA 08        2678       inc R0 ; U
13BB 08        2679       inc R0 ; N
13BC 08        2680       inc R0 ; :
13BD E6        2681       mov a, @R0 ; '1' or '0'
13BE           2682       
13BE B4310F    2683       cjne a, #'1', Stop_Oven
13C1           2684       
13C1           2685       ; START
13C1 756802    2686       mov Control_FSM_state, #2
13C4 753000    2687       mov current_time_sec, #0
13C7 753100    2688       mov current_time_minute, #0
13CA D20F      2689       setb tc_startup_window
13CC C20E      2690       clr tc_missing_abort
13CE 8008      2691       sjmp Serial_Ret
13D0           2692   
13D0           2693   Stop_Oven:
13D0 756800    2694       mov Control_FSM_state, #0
13D3 756900    2695       mov Current_State, #0
13D6 D20C      2696       setb state_change_signal
13D8           2697   
13D8           2698   Serial_Ret:
13D8 22        2699       ret
13D9           2700   
13D9           2701   ; ----------------------------------------------------------------
13D9           2702   ; HELPER: ASCII to Integer
13D9           2703   ; ----------------------------------------------------------------
13D9           2704   Parse_Serial_Num:
13D9 7F00      2705       mov R7, #0
13DB           2706   Parse_Next:
13DB E6        2707       mov A, @R0
13DC 6018      2708       jz Parse_Done           ; Null terminator = done
13DE B40A02    2709       cjne A, #10, Chk_13
13E1 8013      2710       sjmp Parse_Done
13E3           2711   Chk_13:
13E3 B40D02    2712       cjne A, #13, Do_Conv
13E6 800E      2713       sjmp Parse_Done
13E8           2714   
13E8           2715   Do_Conv:
13E8 C3        2716       clr C
13E9 9430      2717       subb A, #0x30           ; ASCII to Int
13EB FD        2718       mov R5, A
13EC           2719       
13EC EF        2720       mov A, R7
13ED 75F00A    2721       mov B, #10
13F0 A4        2722       mul AB
13F1 2D        2723       add A, R5
13F2 FF        2724       mov R7, A
13F3           2725       
13F3 08        2726       inc R0
13F4 80E5      2727       sjmp Parse_Next
13F6           2728   Parse_Done:
13F6 22        2729       ret
13F7           2730   
13F7           2731   END
=======
07D4            204   
07D4            772            ;-----------------------------------------------------------------------------------------------;
07D4            773   
07D4            774   ;-------------------------------------------------------------------------------
07D4            775   ; Display Function for 7-segment displays       
07D4            776   ;-------------------------------------------------------------------------------
07D4            777   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
07D4            778   T_7seg:
07D4 C0F9A4B0   779       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
07D9 9282F880   780       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
07DE 8883C6A1   781       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
07E4            782   
07E4            783   ; Displays a BCD number pased in R0 in HEX5-HEX0
07E4            784   Display_BCD_7_Seg_HEX10:
07E4 9007D4     785       mov dptr, #T_7seg
07E7 E8         786       mov a, R0
07E8 C4         787       swap a
07E9 540F       788       anl a, #0FH
07EB 93         789       movc a, @a+dptr
07EC F592       790       mov HEX1, a
07EE E8         791       mov a, R0
07EF 540F       792       anl a, #0FH
07F1 93         793       movc a, @a+dptr
07F2 F591       794       mov HEX0, a
07F4 22         795       ret
07F5            796   
07F5            797   Display_BCD_7_Seg_HEX32:
07F5 9007D4     798       mov dptr, #T_7seg
07F8 E8         799       mov a, R0
07F9 C4         800       swap a
07FA 540F       801       anl a, #0FH
07FC 93         802       movc a, @a+dptr
07FD F594       803       mov HEX3, a
07FF E8         804       mov a, R0
0800 540F       805       anl a, #0FH
0802 93         806       movc a, @a+dptr
0803 F593       807       mov HEX2, a
0805 22         808       ret
0806            809   
0806            810   Display_BCD_7_Seg_HEX54:
0806 9007D4     811       mov dptr, #T_7seg
0809 E8         812       mov a, R0
080A C4         813       swap a
080B 540F       814       anl a, #0FH
080D 93         815       movc a, @a+dptr
080E F58F       816       mov HEX5, a
0810 E8         817       mov a, R0
0811 540F       818       anl a, #0FH
0813 93         819       movc a, @a+dptr
0814 F58E       820       mov HEX4, a
0816 22         821       ret
0817            822   
0817            823   ; The 8-bit hex number passed in the accumulator is converted to
0817            824   ; BCD and stored in [R1, R0]
0817            825   Hex_to_bcd_8bit:
0817 75F064     826       mov b, #100
081A 84         827       div ab
081B F9         828       mov R1, a   ; After dividing, a has the 100s
081C E5F0       829       mov a, b    ; Remainder is in register b
081E 75F00A     830       mov b, #10
0821 84         831       div ab ; The tens are stored in a, the units are stored in b 
0822 C4         832       swap a
0823 54F0       833       anl a, #0xf0
0825 45F0       834       orl a, b
0827 F8         835       mov R0, a
0828 22         836       ret
0829            837   ;-------------------------------------------------------------------------------
0829            838   ; Display Function for LCD                      
0829            839   ;-------------------------------------------------------------------------------
0829            840   LCD_Print_2Digits:
0829 120817     841       lcall Hex_to_bcd_8bit
082C E8         842       mov a, R0
082D C4         843       swap a
082E 540F       844       anl a, #0x0F
0830 2430       845       add a, #0x30
0832 12076F     846       lcall ?WriteData
0835 E8         847       mov a, R0
0836 540F       848       anl a, #0x0F
0838 2430       849       add a, #0x30
083A 12076F     850       lcall ?WriteData
083D 22         851       ret
083E            852   
083E            853   LCD_Display_Update_func:
083E C0E0       854       push acc
0840            855       
0840            856       ; ==========================================
0840            857       ; PART 1: STATIC TEXT (Title)
0840            858       ; Runs ONLY when the state changes
0840            859       ; ==========================================
0840            860       
0840            861       ; [FIX] "Trampoline" logic for long distance jump
0840            862       ; If signal is SET (1), we stay here and update.
0840            863       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
0840 300F04     864       jnb state_change_signal, Do_Dynamic_Update
0843 C20F       865            clr state_change_signal
0845 8003       866            sjmp Do_Static_Update
0847            867   Do_Dynamic_Update:
0847 02097E     868            ljmp Check_Live_Update
084A            869   
084A            870   Do_Static_Update:
084A            871       ; State Changed: Clear Screen and Write Title
084A 120B11     872       lcall Clear_Screen_Func
084D E560       873       mov a, Control_FSM_state
084F            874       
084F            875       ; State 0: Welcome
084F B4003B     876       cjne a, #0, LCD_Check_1
0852 C0E0       877            push acc
0854 7401       877            mov a, #1
0856 14         877            dec a
0857 1207B9     877            lcall ?Set_Cursor_1 ; Select column and row
085A D0E0       877            pop acc
085C C083       878            push dph
085E C082       878            push dpl
0860 C0E0       878            push acc
0862 900330     878            mov dptr, #String_state0_1
0865 1207AC     878            lcall ?Send_Constant_String
0868 D0E0       878            pop acc
086A D082       878            pop dpl
086C D083       878            pop dph
086E C0E0       879            push acc
0870 7401       879            mov a, #1
0872 14         879            dec a
0873 1207B7     879            lcall ?Set_Cursor_2 ; Select column and row
0876 D0E0       879            pop acc
0878 C083       880            push dph
087A C082       880            push dpl
087C C0E0       880            push acc
087E 900340     880            mov dptr, #String_state0_2
0881 1207AC     880            lcall ?Send_Constant_String
0884 D0E0       880            pop acc
0886 D082       880            pop dpl
0888 D083       880            pop dph
088A 02097B     881       ljmp LCD_Done_Bridge ; Exit
088D            882   
088D            883   LCD_Check_1: ; Setup
088D B4011F     884       cjne a, #1, LCD_Check_2
0890 C0E0       885            push acc
0892 7401       885            mov a, #1
0894 14         885            dec a
0895 1207B9     885            lcall ?Set_Cursor_1 ; Select column and row
0898 D0E0       885            pop acc
089A C083       886            push dph
089C C082       886            push dpl
089E C0E0       886            push acc
08A0 9003A5     886            mov dptr, #String_state1
08A3 1207AC     886            lcall ?Send_Constant_String
08A6 D0E0       886            pop acc
08A8 D082       886            pop dpl
08AA D083       886            pop dph
08AC 02097B     887       ljmp LCD_Done_Bridge
08AF            888   
08AF            889   LCD_Check_2: ; Ramp to Soak
08AF B4021F     890       cjne a, #2, LCD_Check_3
08B2 C0E0       891            push acc
08B4 7401       891            mov a, #1
08B6 14         891            dec a
08B7 1207B9     891            lcall ?Set_Cursor_1 ; Select column and row
08BA D0E0       891            pop acc
08BC C083       892            push dph
08BE C082       892            push dpl
08C0 C0E0       892            push acc
08C2 9003EC     892            mov dptr, #String_state2
08C5 1207AC     892            lcall ?Send_Constant_String
08C8 D0E0       892            pop acc
08CA D082       892            pop dpl
08CC D083       892            pop dph
08CE 02099E     893       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
08D1            894   
08D1            895   LCD_Check_3: ; Soak
08D1 B4031F     896       cjne a, #3, LCD_Check_4
08D4 C0E0       897            push acc
08D6 7401       897            mov a, #1
08D8 14         897            dec a
08D9 1207B9     897            lcall ?Set_Cursor_1 ; Select column and row
08DC D0E0       897            pop acc
08DE C083       898            push dph
08E0 C082       898            push dpl
08E2 C0E0       898            push acc
08E4 9003FC     898            mov dptr, #String_state3
08E7 1207AC     898            lcall ?Send_Constant_String
08EA D0E0       898            pop acc
08EC D082       898            pop dpl
08EE D083       898            pop dph
08F0 02099E     899       ljmp LCD_Update_Temp_Value
08F3            900   
08F3            901   LCD_Check_4: ; Ramp to Peak
08F3 B4041F     902       cjne a, #4, LCD_Check_5
08F6 C0E0       903            push acc
08F8 7401       903            mov a, #1
08FA 14         903            dec a
08FB 1207B9     903            lcall ?Set_Cursor_1 ; Select column and row
08FE D0E0       903            pop acc
0900 C083       904            push dph
0902 C082       904            push dpl
0904 C0E0       904            push acc
0906 90040C     904            mov dptr, #String_state4
0909 1207AC     904            lcall ?Send_Constant_String
090C D0E0       904            pop acc
090E D082       904            pop dpl
0910 D083       904            pop dph
0912 02099E     905       ljmp LCD_Update_Temp_Value
0915            906   
0915            907   LCD_Check_5: ; Reflow
0915 B4051F     908       cjne a, #5, LCD_Check_6
0918 C0E0       909            push acc
091A 7401       909            mov a, #1
091C 14         909            dec a
091D 1207B9     909            lcall ?Set_Cursor_1 ; Select column and row
0920 D0E0       909            pop acc
0922 C083       910            push dph
0924 C082       910            push dpl
0926 C0E0       910            push acc
0928 90041C     910            mov dptr, #String_state5
092B 1207AC     910            lcall ?Send_Constant_String
092E D0E0       910            pop acc
0930 D082       910            pop dpl
0932 D083       910            pop dph
0934 02099E     911       ljmp LCD_Update_Temp_Value
0937            912   
0937            913   LCD_Check_6: ; Cooling
0937 B4061F     914       cjne a, #6, LCD_Check_7
093A C0E0       915            push acc
093C 7401       915            mov a, #1
093E 14         915            dec a
093F 1207B9     915            lcall ?Set_Cursor_1 ; Select column and row
0942 D0E0       915            pop acc
0944 C083       916            push dph
0946 C082       916            push dpl
0948 C0E0       916            push acc
094A 90042C     916            mov dptr, #String_state6
094D 1207AC     916            lcall ?Send_Constant_String
0950 D0E0       916            pop acc
0952 D082       916            pop dpl
0954 D083       916            pop dph
0956 02099E     917       ljmp LCD_Update_Temp_Value
0959            918   
0959            919   LCD_Check_7: ; Done
0959            920       ; [FIX] Check distance safe logic for State 7
0959 B4071F     921       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
095C C0E0       922            push acc
095E 7401       922            mov a, #1
0960 14         922            dec a
0961 1207B9     922            lcall ?Set_Cursor_1 ; Select column and row
0964 D0E0       922            pop acc
0966 C083       923            push dph
0968 C082       923            push dpl
096A C0E0       923            push acc
096C 90043C     923            mov dptr, #String_state7
096F 1207AC     923            lcall ?Send_Constant_String
0972 D0E0       923            pop acc
0974 D082       923            pop dpl
0976 D083       923            pop dph
0978 02097B     924       ljmp LCD_Done_Bridge
097B            925   
097B            926   ; Local bridge to reach the far-away LCD_Done
097B            927   LCD_Done_Bridge:
097B 0209FF     928       ljmp LCD_Done
097E            929   
097E            930   ; ==========================================
097E            931   ; PART 2: DYNAMIC VALUES (Temperature)
097E            932   ; Runs every time 'one_second_flag' is set
097E            933   ; ==========================================
097E            934   Check_Live_Update:
097E 3001FA     935       jnb one_second_flag, LCD_Done_Bridge
0981 C201       936       clr one_second_flag
0983            937       
0983            938       ; Only update temp for States 2, 3, 4, 5, 6
0983 E560       939       mov a, Control_FSM_state
0985 B40202     940       cjne a, #2, Check_St3
0988 8014       941       sjmp LCD_Update_Temp_Value
098A            942   Check_St3:
098A B40302     943       cjne a, #3, Check_St4
098D 800F       944       sjmp LCD_Update_Temp_Value
098F            945   Check_St4:
098F B40402     946       cjne a, #4, Check_St5
0992 800A       947       sjmp LCD_Update_Temp_Value
0994            948   Check_St5:
0994 B40502     949       cjne a, #5, Check_St6
0997 8005       950       sjmp LCD_Update_Temp_Value
0999            951   Check_St6:
0999 B40663     952       cjne a, #6, LCD_Done
099C 8000       953       sjmp LCD_Update_Temp_Value
099E            954   
099E            955   ; --- HELPER: Prints "XXX C" on Line 2 ---
099E            956   LCD_Update_Temp_Value:
099E C0E0       957            push acc
09A0 7401       957            mov a, #1
09A2 14         957            dec a
09A3 1207B7     957            lcall ?Set_Cursor_2 ; Select column and row
09A6 D0E0       957            pop acc
09A8            958       
09A8            959       ; Convert current_temp to BCD
09A8 85473A     960       mov x, current_temp
09AB 85483B     961       mov x+1, current_temp+1
09AE 85493C     962       mov x+2, current_temp+2
09B1 854A3D     963       mov x+3, current_temp+3
09B4 12002E     964       lcall hex2bcd
09B7            965   
09B7            966       ; Update HEX2-HEX0 with temperature
09B7 120B3C     967       lcall Update_HEX_Temp
09BA            968       
09BA            969       ; Print Hundreds
09BA E543       970       mov a, bcd+1
09BC 540F       971       anl a, #0x0F
09BE 2430       972       add a, #0x30
09C0 12076F     973       lcall ?WriteData
09C3            974       
09C3            975       ; Print Tens
09C3 E542       976       mov a, bcd+0
09C5 C4         977       swap a
09C6 540F       978       anl a, #0x0F
09C8 2430       979       add a, #0x30
09CA 12076F     980       lcall ?WriteData
09CD            981       
09CD            982       ; Print Ones
09CD E542       983       mov a, bcd+0
09CF 540F       984       anl a, #0x0F
09D1 2430       985       add a, #0x30
09D3 12076F     986       lcall ?WriteData
09D6            987       
09D6            988       ; Print 'C'
09D6 7443       989       mov a, #'C'
09D8 12076F     990       lcall ?WriteData
09DB            991       
09DB            992       ; Clear remaining line space (prevents garbage)
09DB 7420       993       mov a, #' '
09DD 12076F     994       lcall ?WriteData
09E0 12076F     995       lcall ?WriteData
09E3            996   
09E3            997       ; Print time MM:SS at bottom right
09E3 C0E0       998            push acc
09E5 740C       998            mov a, #12
09E7 14         998            dec a
09E8 1207B7     998            lcall ?Set_Cursor_2 ; Select column and row
09EB D0E0       998            pop acc
09ED E531       999       mov a, current_time_minute
09EF 120829    1000       lcall LCD_Print_2Digits
09F2 743A      1001       mov a, #':'
09F4 12076F    1002       lcall ?WriteData
09F7 E530      1003       mov a, current_time_sec
09F9 120829    1004       lcall LCD_Print_2Digits
09FC           1005   
09FC           1006       ; Mirror temp to serial (PuTTY/screen)
09FC 120653    1007       lcall Serial_Send_Temp_Line
09FF           1008   
09FF           1009   LCD_Done:
09FF D0E0      1010       pop acc
0A01 22        1011       ret
0A02           1012   
0A02           1013   ; ----------------------------------------------------------------
0A02           1014   ; MODULE: SCREEN UPDATE (Visual Logic)
0A02           1015   ; ----------------------------------------------------------------
0A02           1016   Update_Screen_Full:
0A02 E560      1017            mov a, Control_FSM_state
0A04 B40102    1018            cjne a, #1, Update_Screen_Full_ret
0A07 8001      1019            sjmp Update_Screen_Full_do
0A09           1020   Update_Screen_Full_ret:
0A09 22        1021            ret
0A0A           1022   Update_Screen_Full_do:
0A0A 3024FC    1023       jnb fullscreen_update_signal, Update_Screen_Full_ret
0A0D C224      1024       clr fullscreen_update_signal
0A0F           1025   
0A0F 120B11    1026       lcall Clear_Screen_Func
0A12 C0E0      1027            push acc
0A14 7401      1027            mov a, #1
0A16 14        1027            dec a
0A17 1207B9    1027            lcall ?Set_Cursor_1 ; Select column and row
0A1A D0E0      1027            pop acc
0A1C           1028       ; --- Draw Line 1 (Titles) ---
0A1C E561      1029       mov A, Current_State
0A1E B40013    1030       cjne A, #0, Update_State_1
0A21 C083      1031            push dph
0A23 C082      1031            push dpl
0A25 C0E0      1031            push acc
0A27 900350    1031            mov dptr, #Txt_Home
0A2A 1207AC    1031            lcall ?Send_Constant_String
0A2D D0E0      1031            pop acc
0A2F D082      1031            pop dpl
0A31 D083      1031            pop dph
0A33 22        1032       ret 
0A34           1033   Update_State_1:
0A34 B40114    1034       cjne A, #1, Update_State_2
0A37 C083      1035            push dph
0A39 C082      1035            push dpl
0A3B C0E0      1035            push acc
0A3D 900361    1035            mov dptr, #Txt_SoakT
0A40 1207AC    1035            lcall ?Send_Constant_String
0A43 D0E0      1035            pop acc
0A45 D082      1035            pop dpl
0A47 D083      1035            pop dph
0A49 8042      1036       sjmp Draw_Temp_Format
0A4B           1037   Update_State_2:
0A4B B40214    1038       cjne A, #2, Update_State_3
0A4E C083      1039            push dph
0A50 C082      1039            push dpl
0A52 C0E0      1039            push acc
0A54 900372    1039            mov dptr, #Txt_SoakTime
0A57 1207AC    1039            lcall ?Send_Constant_String
0A5A D0E0      1039            pop acc
0A5C D082      1039            pop dpl
0A5E D083      1039            pop dph
0A60 8046      1040       sjmp Draw_Time_Format
0A62           1041   Update_State_3:
0A62 B40314    1042       cjne A, #3, Update_State_4
0A65 C083      1043            push dph
0A67 C082      1043            push dpl
0A69 C0E0      1043            push acc
0A6B 900383    1043            mov dptr, #Txt_ReflT
0A6E 1207AC    1043            lcall ?Send_Constant_String
0A71 D0E0      1043            pop acc
0A73 D082      1043            pop dpl
0A75 D083      1043            pop dph
0A77 8014      1044       sjmp Draw_Temp_Format
0A79           1045   Update_State_4:
0A79 C083      1046            push dph
0A7B C082      1046            push dpl
0A7D C0E0      1046            push acc
0A7F 900394    1046            mov dptr, #Txt_ReflTime
0A82 1207AC    1046            lcall ?Send_Constant_String
0A85 D0E0      1046            pop acc
0A87 D082      1046            pop dpl
0A89 D083      1046            pop dph
0A8B 801B      1047       sjmp Draw_Time_Format
0A8D           1048   
0A8D           1049   ; --- Draw Line 2 (Values) ---
0A8D           1050   Draw_Temp_Format:
0A8D C0E0      1051            push acc
0A8F 7401      1051            mov a, #1
0A91 14        1051            dec a
0A92 1207B7    1051            lcall ?Set_Cursor_2 ; Select column and row
0A95 D0E0      1051            pop acc
0A97 120B25    1052       lcall Get_Current_Buffer_Addr
0A9A 120B07    1053       lcall Print_String_RAM
0A9D C0E0      1054            push acc
0A9F 7443      1054            mov a, #'C'
0AA1 12076F    1054            lcall ?WriteData
0AA4 D0E0      1054            pop acc
0AA6 8034      1055       sjmp Restore_Cursor
0AA8           1056   
0AA8           1057   Draw_Time_Format:
0AA8 C0E0      1058            push acc
0AAA 7401      1058            mov a, #1
0AAC 14        1058            dec a
0AAD 1207B7    1058            lcall ?Set_Cursor_2 ; Select column and row
0AB0 D0E0      1058            pop acc
0AB2 120B25    1059       lcall Get_Current_Buffer_Addr
0AB5           1060       ; MM
0AB5 E6        1061       mov A, @R0
0AB6 12076F    1062       lcall ?WriteData
0AB9 08        1063       inc R0
0ABA E6        1064       mov A, @R0
0ABB 12076F    1065       lcall ?WriteData
0ABE 08        1066       inc R0
0ABF           1067       ; Colon
0ABF C0E0      1068            push acc
0AC1 743A      1068            mov a, #':'
0AC3 12076F    1068            lcall ?WriteData
0AC6 D0E0      1068            pop acc
0AC8           1069       ; SS
0AC8 E6        1070       mov A, @R0
0AC9 12076F    1071       lcall ?WriteData
0ACC 08        1072       inc R0
0ACD E6        1073       mov A, @R0
0ACE 12076F    1074       lcall ?WriteData
0AD1           1075       ; Unit
0AD1 C0E0      1076            push acc
0AD3 7473      1076            mov a, #'s'
0AD5 12076F    1076            lcall ?WriteData
0AD8 D0E0      1076            pop acc
0ADA 8000      1077       sjmp Restore_Cursor
0ADC           1078   
0ADC           1079   ; --- Restore Cursor Position ---
0ADC           1080   Restore_Cursor:
0ADC E561      1081       mov A, Current_State
0ADE B40202    1082       cjne A, #2, RC_Check_State_4  
0AE1 800C      1083       sjmp Adjust_Cursor_Time
0AE3           1084   RC_Check_State_4:             
0AE3 B40402    1085       cjne A, #4, Normal_Cursor
0AE6 8007      1086       sjmp Adjust_Cursor_Time
0AE8           1087   
0AE8           1088   Normal_Cursor:
0AE8 E56A      1089       mov A, Cursor_Idx
0AEA 24C0      1090       add A, #0xC0
0AEC 120774    1091       lcall ?WriteCommand
0AEF           1092   
0AEF           1093   Adjust_Cursor_Time:
0AEF           1094       ; Skip the colon index (2)
0AEF E56A      1095       mov A, Cursor_Idx
0AF1 B40201    1096       cjne A, #2, No_Skip
0AF4 04        1097       inc A 
0AF5           1098   No_Skip:
0AF5           1099       ; Add 1 if past the colon
0AF5 C3        1100       clr C
0AF6 9402      1101       subb A, #2
0AF8 4005      1102       jc No_Add
0AFA E56A      1103       mov A, Cursor_Idx
0AFC 04        1104       inc A
0AFD 8002      1105       sjmp Final_Cursor_Set
0AFF           1106   No_Add:
0AFF E56A      1107       mov A, Cursor_Idx
0B01           1108   Final_Cursor_Set:
0B01 24C0      1109       add A, #0xC0
0B03 120774    1110       lcall ?WriteCommand
0B06 22        1111       ret
0B07           1112   
0B07           1113   Print_String_RAM:
0B07 E6        1114       mov A, @R0
0B08 6006      1115       jz Print_String_Done
0B0A 12076F    1116       lcall ?WriteData
0B0D 08        1117       inc R0
0B0E 80F7      1118       sjmp Print_String_RAM
0B10           1119   Print_String_Done:
0B10 22        1120       ret
0B11           1121   
0B11           1122   ; --- Clear Screen with hardware delay ---
0B11           1123   Clear_Screen_Func:
0B11 7401      1124            mov a, #0x01
0B13 120774    1124            lcall ?WriteCommand        ; Clear display command
0B16 C002      1125            push AR2
0B18 7A02      1125            mov R2, #2
0B1A 12072A    1125            lcall ?Wait_Milli_Seconds
0B1D D002      1125            pop AR2     ; LCD needs ~2ms to clear
0B1F 740C      1126            mov a, #0x0C
0B21 120774    1126            lcall ?WriteCommand        ; Display ON, Cursor OFF
0B24 22        1127       ret
0B25           1128   
0B25           1129   Get_Current_Buffer_Addr:
0B25 E561      1130       mov A, Current_State
0B27 B40103    1131       cjne A, #1, Get_Buf_2
0B2A 7880      1132       mov R0, #Buf_Soak_Temp
0B2C 22        1133       ret
0B2D           1134   Get_Buf_2:
0B2D B40203    1135       cjne A, #2, Get_Buf_3
0B30 7884      1136       mov R0, #Buf_Soak_Time
0B32 22        1137       ret
0B33           1138   Get_Buf_3:
0B33 B40303    1139       cjne A, #3, Get_Buf_4
0B36 7889      1140       mov R0, #Buf_Refl_Temp
0B38 22        1141       ret
0B39           1142   Get_Buf_4:
0B39 788D      1143       mov R0, #Buf_Refl_Time
0B3B 22        1144       ret
0B3C           1145   
0B3C           1146   ;-------------------------------------------------------------------------------
0B3C           1147   ; Update HEX2-HEX0 with temperature (3 digits)
0B3C           1148   ;-------------------------------------------------------------------------------
0B3C           1149   Update_HEX_Temp:
0B3C 9007D4    1150       mov dptr, #T_7seg
0B3F           1151       ; Hundreds -> HEX2
0B3F E543      1152       mov a, bcd+1
0B41 540F      1153       anl a, #0x0F
0B43 93        1154       movc a, @a+dptr
0B44 F593      1155       mov HEX2, a
0B46           1156       ; Tens -> HEX1
0B46 E542      1157       mov a, bcd+0
0B48 C4        1158       swap a
0B49 540F      1159       anl a, #0x0F
0B4B 93        1160       movc a, @a+dptr
0B4C F592      1161       mov HEX1, a
0B4E           1162       ; Ones -> HEX0
0B4E E542      1163       mov a, bcd+0
0B50 540F      1164       anl a, #0x0F
0B52 93        1165       movc a, @a+dptr
0B53 F591      1166       mov HEX0, a
0B55 22        1167       ret
0B56           1168       
0B56           1169   ;---------------------------------------------------------
0B56           1170   PB0_DEB:
0B56           1171   ;non-blocking state machine for PB0 debounce
0B56 E572      1172       mov a, PB0_DEB_state
0B58           1173   PB0_DEB_state0:
0B58 B4000A    1174       cjne a, #0, PB0_DEB_state1
0B5B 20902F    1175       jb PB0, PB0_DEB_done
0B5E 757100    1176       mov PB0_DEB_timer, #0
0B61 0572      1177       inc PB0_DEB_state
0B63 8028      1178       sjmp PB0_DEB_done
0B65           1179   PB0_DEB_state1:
0B65 B40109    1180       cjne a, #1, PB0_DEB_state2
0B68           1181       ; this is the debounce state
0B68 E571      1182       mov a, PB0_DEB_timer
0B6A B43220    1183       cjne a, #50, PB0_DEB_done ; 50 ms passed?
0B6D 0572      1184       inc PB0_DEB_state
0B6F 801C      1185       sjmp PB0_DEB_done  
0B71           1186   PB0_DEB_state2:
0B71 B4020C    1187       cjne a, #2, PB0_DEB_state3
0B74 209004    1188       jb PB0, PB0_DEB_state2b
0B77 0572      1189       inc PB0_DEB_state
0B79 8012      1190       sjmp PB0_DEB_done  
0B7B           1191   PB0_DEB_state2b:
0B7B 757200    1192       mov PB0_DEB_state, #0
0B7E 800D      1193       sjmp PB0_DEB_done
0B80           1194   PB0_DEB_state3:
0B80 B4030A    1195       cjne a, #3, PB0_DEB_done
0B83 309007    1196       jnb PB0, PB0_DEB_done
0B86 D215      1197       setb PB0_flag ; Suscesfully detected a valid PB0 press/release
0B88 B2ED      1198            cpl LEDRA.5
0B8A 757200    1199       mov PB0_DEB_state, #0  
0B8D           1200   PB0_DEB_done:
0B8D 22        1201       ret
0B8E           1202   
0B8E           1203   PB2_DEB:
0B8E           1204   ;non-blocking state machine for PB2 debounce
0B8E E574      1205       mov a, PB2_DEB_state
0B90           1206   PB2_DEB_state0:
0B90 B4000A    1207       cjne a, #0, PB2_DEB_state1
0B93 20B72D    1208       jb PB2, PB2_DEB_done
0B96 757300    1209       mov PB2_DEB_timer, #0
0B99 0574      1210       inc PB2_DEB_state
0B9B 8026      1211       sjmp PB2_DEB_done
0B9D           1212   PB2_DEB_state1:
0B9D B40109    1213       cjne a, #1, PB2_DEB_state2
0BA0           1214       ; this is the debounce state
0BA0 E573      1215       mov a, PB2_DEB_timer
0BA2 B4321E    1216       cjne a, #50, PB2_DEB_done ; 50 ms passed?
0BA5 0574      1217       inc PB2_DEB_state
0BA7 801A      1218       sjmp PB2_DEB_done  
0BA9           1219   PB2_DEB_state2:
0BA9 B4020C    1220       cjne a, #2, PB2_DEB_state3
0BAC 20B704    1221       jb PB2, PB2_DEB_state2b
0BAF 0574      1222       inc PB2_DEB_state
0BB1 8010      1223       sjmp PB2_DEB_done  
0BB3           1224   PB2_DEB_state2b:
0BB3 757400    1225       mov PB2_DEB_state, #0
0BB6 800B      1226       sjmp PB2_DEB_done
0BB8           1227   PB2_DEB_state3:
0BB8 B40308    1228       cjne a, #3, PB2_DEB_done
0BBB 30B705    1229       jnb PB2, PB2_DEB_done
0BBE D217      1230       setb PB2_flag ; Suscesfully detected a valid PB2 press/release
0BC0 757400    1231       mov PB2_DEB_state, #0  
0BC3           1232   PB2_DEB_done:
0BC3 22        1233       ret
0BC4           1234   
0BC4           1235   ; ------------------------------------------------------------------------------
0BC4           1236   ; Non-blocking FSM for the one second counter
0BC4           1237   ;-------------------------------------------------------------------------------
0BC4           1238   SEC_FSM:
0BC4 E570      1239       mov a, SEC_FSM_state
0BC6           1240   SEC_FSM_state0:
0BC6 B4000C    1241       cjne a, #0, SEC_FSM_state1
0BC9 E56F      1242       mov a, SEC_FSM_timer
0BCB B4FA51    1243       cjne a, #250, SEC_FSM_done
0BCE 756F00    1244       mov SEC_FSM_timer, #0
0BD1 0570      1245       inc SEC_FSM_state
0BD3 804A      1246       sjmp SEC_FSM_done
0BD5           1247   SEC_FSM_state1:  
0BD5 B4010E    1248       cjne a, #1, SEC_FSM_state2
0BD8 D2E9      1249       setb LEDRA.1
0BDA E56F      1250       mov a, SEC_FSM_timer
0BDC B4FA40    1251       cjne a, #250, SEC_FSM_done
0BDF 756F00    1252       mov SEC_FSM_timer, #0
0BE2 0570      1253       inc SEC_FSM_state
0BE4 8039      1254       sjmp SEC_FSM_done
0BE6           1255   SEC_FSM_state2:  
0BE6 B4020E    1256       cjne a, #2, SEC_FSM_state3
0BE9 D2EA      1257       setb LEDRA.2
0BEB E56F      1258       mov a, SEC_FSM_timer
0BED B4FA2F    1259       cjne a, #250, SEC_FSM_done
0BF0 756F00    1260       mov SEC_FSM_timer, #0
0BF3 0570      1261       inc SEC_FSM_state
0BF5 8028      1262       sjmp SEC_FSM_done
0BF7           1263   SEC_FSM_state3:  
0BF7 B40325    1264       cjne a, #3, SEC_FSM_done
0BFA D2EB      1265       setb LEDRA.3
0BFC E56F      1266       mov a, SEC_FSM_timer
0BFE B4FA1E    1267       cjne a, #250, SEC_FSM_done
0C01 756F00    1268       mov SEC_FSM_timer, #0
0C04 757000    1269       mov SEC_FSM_state, #0
0C07           1270       
0C07           1271       ; These flags are always set (global use)
0C07 D204      1272       setb one_second_lcd_flag
0C09 D201      1273       setb one_second_flag
0C0B           1274       
0C0B           1275       ; Heartbeat LED always toggles
0C0B B2E8      1276       cpl LEDRA.0
0C0D           1277       
0C0D           1278       ; Only update time if counting is enabled
0C0D 300D0F    1279       jnb time_count_doing_signal, SEC_FSM_done
0C10           1280       
0C10           1281       ; Update current time (only when counting)
0C10 E530      1282       mov a, current_time_sec
0C12 04        1283       inc a
0C13 B43C07    1284       cjne a, #60, SEC_NoMinuteCarry
0C16 753000    1285       mov current_time_sec, #0
0C19 0531      1286       inc current_time_minute
0C1B 8002      1287       sjmp SEC_FSM_done
0C1D           1288   SEC_NoMinuteCarry:
0C1D F530      1289       mov current_time_sec, a
0C1F           1290   SEC_FSM_done:
0C1F 22        1291       ret
0C20           1292   
0C20           1293   ; ------------------------------------------------------------------------------
0C20           1294   ; Counting the processing time 
0C20           1295   ;-------------------------------------------------------------------------------
0C20           1296   Time_Counter:
0C20 C0E0      1297       push ACC
0C22 C0D0      1298       push psw
0C24 E560      1299       mov a, Control_FSM_state
0C26           1300       
0C26           1301       ; State 2: Start counting
0C26 B4020F    1302       cjne a, #2, Time_Counter_Nstate2
0C29 101102    1303       jbc state_change_signal_Count, Time_Counter_Start
0C2C 800F      1304       sjmp Time_Counter_Done
0C2E           1305   
0C2E           1306   Time_Counter_Start:
0C2E 753000    1307       mov current_time_sec, #0
0C31 753100    1308       mov current_time_minute, #0
0C34 D20D      1309       setb time_count_doing_signal
0C36 8005      1310       sjmp Time_Counter_Done
0C38           1311   
0C38           1312   Time_Counter_Nstate2:
0C38           1313       ; State 6: Stop counting
0C38 B40602    1314       cjne a, #6, Time_Counter_Done
0C3B C20D      1315       clr time_count_doing_signal
0C3D           1316   
0C3D           1317   Time_Counter_Done:
0C3D D0D0      1318       pop psw
0C3F D0E0      1319       pop ACC
0C41 22        1320       ret
0C42           1321   
0C42           1322   
0C42           1323   ;-------------------------------------------------------------------------------
0C42           1324   ; Time_Compare_MMSS
0C42           1325   ;
0C42           1326   ; PURPOSE:
0C42           1327   ;   Compare elapsed time (current_time_minute:current_time_sec)
0C42           1328   ;   against soak and reflow setpoints (soak_time_*, reflow_time_*).
0C42           1329   ;
0C42           1330   ; BEHAVIOR:
0C42           1331   ;   - If current_time >= soak_end_time   then soak_time_reached = 1
0C42           1332   ;   - If current_time >= reflow_end_time then reflow_time_reached = 1
0C42           1333   ;
0C42           1334   ; NOTES:
0C42           1335   ;   Compare minutes first, then seconds.
0C42           1336   ;-------------------------------------------------------------------------------
0C42           1337   Time_Compare_MMSS:
0C42 C0E0      1338       push acc
0C44 C0D0      1339       push psw
0C46           1340   
0C46 E560      1341       mov a, Control_FSM_state
0C48 B4032E    1342       cjne a, #3, TC_Not_Soak
0C4B           1343   
0C4B           1344   ; ============================================================
0C4B           1345   ; STATE 3: SOAK TIME COMPARISON
0C4B           1346   ; ============================================================
0C4B 101002    1347       jbc state_change_signal_TC, TC_Soak_Start_Record
0C4E 8015      1348       sjmp TC_Soak_Comparing
0C50           1349   
0C50           1350   TC_Soak_Start_Record:
0C50           1351       ; Calculate end time = current_time + soak_time
0C50 E531      1352       mov a, current_time_minute
0C52 2533      1353       add a, soak_time_minute
0C54 F537      1354       mov soak_end_time_minute, a
0C56           1355   
0C56 E530      1356       mov a, current_time_sec
0C58 2532      1357       add a, soak_time_sec
0C5A F536      1358       mov soak_end_time_sec, a
0C5C           1359   
0C5C           1360       ; Check for seconds overflow (>= 60)
0C5C C3        1361       clr c
0C5D 943C      1362       subb a, #60
0C5F 4004      1363       jc TC_Soak_Comparing           ; No overflow, skip adjustment
0C61           1364   
0C61           1365       ; Overflow: adjust seconds and add 1 to minutes
0C61 F536      1366       mov soak_end_time_sec, a
0C63 0537      1367       inc soak_end_time_minute
0C65           1368   
0C65           1369   TC_Soak_Comparing:
0C65           1370       ; Compare minutes first
0C65 E531      1371       mov  a, current_time_minute
0C67 C3        1372       clr  c
0C68 9537      1373       subb a, soak_end_time_minute
0C6A 403E      1374       jc   TC_Done                   ; current_min < end_min -> not reached
0C6C 7007      1375       jnz  TC_Soak_Reached           ; current_min > end_min -> reached
0C6E           1376   
0C6E           1377       ; Minutes equal -> compare seconds
0C6E E530      1378       mov  a, current_time_sec
0C70 C3        1379       clr  c
0C71 9536      1380       subb a, soak_end_time_sec
0C73 4035      1381       jc   TC_Done                   ; current_sec < end_sec -> not reached
0C75           1382                                      ; current_sec >= end_sec -> fall through to reached
0C75           1383   
0C75           1384   TC_Soak_Reached:
0C75 D208      1385       setb soak_time_reached
0C77 8031      1386       sjmp TC_Done
0C79           1387   
0C79           1388   ; ============================================================
0C79           1389   ; STATE 5: REFLOW TIME COMPARISON
0C79           1390   ; ============================================================
0C79           1391   TC_Not_Soak:
0C79 E560      1392       mov a, Control_FSM_state
0C7B B4052C    1393       cjne a, #5, TC_Done
0C7E           1394   
0C7E 101002    1395       jbc state_change_signal_TC, TC_Reflow_Start_Record
0C81 8015      1396       sjmp TC_Reflow_Comparing
0C83           1397   
0C83           1398   TC_Reflow_Start_Record:
0C83           1399       ; Calculate end time = current_time + reflow_time
0C83 E531      1400       mov a, current_time_minute
0C85 2535      1401       add a, reflow_time_minute
0C87 F539      1402       mov reflow_end_time_minute, a
0C89           1403   
0C89 E530      1404       mov a, current_time_sec
0C8B 2534      1405       add a, reflow_time_sec
0C8D F538      1406       mov reflow_end_time_sec, a
0C8F           1407   
0C8F           1408       ; Check for seconds overflow (>= 60)
0C8F C3        1409       clr c
0C90 943C      1410       subb a, #60
0C92 4004      1411       jc TC_Reflow_Comparing         ; No overflow, skip adjustment
0C94           1412   
0C94           1413       ; Overflow: adjust seconds and add 1 to minutes
0C94 F538      1414       mov reflow_end_time_sec, a
0C96 0539      1415       inc reflow_end_time_minute
0C98           1416   
0C98           1417   TC_Reflow_Comparing:
0C98           1418       ; Compare minutes first
0C98 E531      1419       mov  a, current_time_minute
0C9A C3        1420       clr  c
0C9B 9539      1421       subb a, reflow_end_time_minute
0C9D 400B      1422       jc   TC_Done                   ; current_min < end_min -> not reached
0C9F 7007      1423       jnz  TC_Reflow_Reached         ; current_min > end_min -> reached
0CA1           1424   
0CA1           1425       ; Minutes equal -> compare seconds
0CA1 E530      1426       mov  a, current_time_sec
0CA3 C3        1427       clr  c
0CA4 9538      1428       subb a, reflow_end_time_sec
0CA6 4002      1429       jc   TC_Done                   ; current_sec < end_sec -> not reached
0CA8           1430                                      ; current_sec >= end_sec -> fall through to reached
0CA8           1431   
0CA8           1432   TC_Reflow_Reached:
0CA8 D209      1433       setb reflow_time_reached
0CAA           1434   
0CAA           1435   TC_Done:
0CAA D0D0      1436       pop  psw
0CAC D0E0      1437       pop  acc
0CAE 22        1438       ret
0CAF           1439   
0CAF           1440   ;-------------------------------------------------------------------------------;
0CAF           1441   ; Temp_Compare
0CAF           1442   ; Checks if we have reached the user's target temperatures.
0CAF           1443   ; Only compares relevant temperature based on current Control_FSM_state:
0CAF           1444   ;   State 2: Sets 'soak_temp_reached' if current_temp >= soak_temp
0CAF           1445   ;   State 4: Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0CAF           1446   ;   State 6: Sets 'cooling_temp_reached' if current_temp < 100C
0CAF           1447   ;-------------------------------------------------------------------------------;
0CAF           1448   Temp_Compare:
0CAF C0E0      1449       push acc
0CB1 C0D0      1450       push psw
0CB3 C000      1451       push AR0
0CB5 C001      1452       push AR1
0CB7 C002      1453       push AR2
0CB9           1454       
0CB9 E560      1455       mov a, Control_FSM_state
0CBB           1456       
0CBB           1457       ; --- CHECK STATE 2: SOAK TEMP ---
0CBB B40202    1458       cjne a, #2, Temp_Compare_Check_State4
0CBE 800A      1459       sjmp Check_Soak_Threshold
0CC0           1460       
0CC0           1461   Temp_Compare_Check_State4:
0CC0           1462       ; --- CHECK STATE 4: REFLOW TEMP ---
0CC0 B40402    1463       cjne a, #4, Temp_Compare_Check_State6
0CC3 801D      1464       sjmp Check_Reflow_Threshold
0CC5           1465       
0CC5           1466   Temp_Compare_Check_State6:
0CC5           1467       ; --- CHECK STATE 6: COOLING TEMP ---
0CC5 B4064D    1468       cjne a, #6, Temp_Compare_Done
0CC8 8030      1469       sjmp Check_Cooling_Threshold
0CCA           1470   
0CCA           1471   Check_Soak_Threshold:
0CCA           1472       ; Copy current_temp to X
0CCA 7847      1473       mov R0, #current_temp
0CCC 793A      1474       mov R1, #x
0CCE 120D20    1475       lcall Copy4_Bytes_R0_to_R1
0CD1           1476   
0CD1           1477       ; Copy soak_temp to Y
0CD1 784B      1478       mov R0, #soak_temp
0CD3 793E      1479       mov R1, #y
0CD5 120D20    1480       lcall Copy4_Bytes_R0_to_R1
0CD8           1481   
0CD8           1482       ; Compare: Is X (Current) < Y (Target)?
0CD8 12011A    1483       lcall x_lt_y
0CDB 200037    1484       jb mf, Temp_Compare_Done          ; If Current < Target, not reached yet
0CDE           1485       
0CDE           1486       ; If Current >= Target
0CDE D205      1487       setb soak_temp_reached
0CE0 8033      1488       sjmp Temp_Compare_Done
0CE2           1489   
0CE2           1490   Check_Reflow_Threshold:
0CE2           1491       ; Copy current_temp to X
0CE2 7847      1492       mov R0, #current_temp
0CE4 793A      1493       mov R1, #x
0CE6 120D20    1494       lcall Copy4_Bytes_R0_to_R1
0CE9           1495   
0CE9           1496       ; Copy reflow_temp to Y
0CE9 784F      1497       mov R0, #reflow_temp
0CEB 793E      1498       mov R1, #y
0CED 120D20    1499       lcall Copy4_Bytes_R0_to_R1
0CF0           1500   
0CF0           1501       ; Compare
0CF0 12011A    1502       lcall x_lt_y
0CF3 20001F    1503       jb mf, Temp_Compare_Done          ; If Current < Target, not reached yet
0CF6           1504       
0CF6           1505       ; If Current >= Target
0CF6 D206      1506       setb reflow_temp_reached
0CF8 801B      1507       sjmp Temp_Compare_Done
0CFA           1508   
0CFA           1509   Check_Cooling_Threshold:
0CFA           1510       ; Copy current_temp to X
0CFA 7847      1511       mov R0, #current_temp
0CFC 793A      1512       mov R1, #x
0CFE 120D20    1513       lcall Copy4_Bytes_R0_to_R1
0D01           1514       
0D01 753E64    1515            mov y+0, #low (100 % 0x10000) 
0D04 753F00    1515            mov y+1, #high(100 % 0x10000) 
0D07 754000    1515            mov y+2, #low (100 / 0x10000) 
0D0A 754100    1515            mov y+3, #high(100 / 0x10000)                         ; Cooling target = 100C
0D0D 12011A    1516       lcall x_lt_y
0D10 300002    1517       jnb mf, Temp_Compare_Done         ; If temp >= 100, not cooled yet
0D13           1518       
0D13           1519       ; If Current < 100C
0D13 D207      1520       setb cooling_temp_reached
0D15           1521   
0D15           1522   ; ---------------------------------------------------------
0D15           1523   Temp_Compare_Done:
0D15 D002      1524       pop AR2
0D17 D001      1525       pop AR1
0D19 D000      1526       pop AR0
0D1B D0D0      1527       pop psw
0D1D D0E0      1528       pop acc
0D1F 22        1529       ret
0D20           1530   
0D20           1531   ;-------------------------------------------------------------------------------;
0D20           1532   ; Copy4_Bytes_R0_to_R1
0D20           1533   ;
0D20           1534   ; PURPOSE:
0D20           1535   ;   Utility routine to copy a 32-bit value (4 bytes)
0D20           1536   ;   from one memory location to another.
0D20           1537   ;
0D20           1538   ; INPUTS:
0D20           1539   ;   R0 st source address
0D20           1540   ;   R1 at destination address
0D20           1541   ;
0D20           1542   ; USES:
0D20           1543   ;   R2 as loop counter
0D20           1544   ;
0D20           1545   ; EXAMPLE:
0D20           1546   ;   mov R0, #current_temp
0D20           1547   ;   mov R1, #x
0D20           1548   ;   lcall Copy4_Bytes_R0_to_R1
0D20           1549   ;-------------------------------------------------------------------------------;
0D20           1550   Copy4_Bytes_R0_to_R1:
0D20 7A04      1551       mov  R2, #4
0D22           1552   Copy4_Loop:
0D22 E6        1553       mov  a, @R0
0D23 F7        1554       mov  @R1, a
0D24 08        1555       inc  R0
0D25 09        1556       inc  R1
0D26 DAFA      1557       djnz R2, Copy4_Loop
0D28 22        1558       ret
0D29           1559   
0D29           1560   ;-------------------------------------------------------------------------------
0D29           1561   ; PWM
0D29           1562   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0D29           1563   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0D29           1564   ; ------------------------------------------------------------------------------
0D29           1565   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0D29 100202    1566       jbc one_ms_pwm_flag, pwm_wave_generator
0D2C 8071      1567       sjmp end_pwm_generator
0D2E           1568   
0D2E           1569   pwm_wave_generator:
0D2E C200      1570       clr mf
0D30           1571       ; move pwm counter value into x for comparison purpose
0D30 855C3A    1572       mov x, pwm_counter
0D33 855D3B    1573       mov x+1, pwm_counter+1
0D36 855E3C    1574       mov x+2, pwm_counter+2
0D39 855F3D    1575       mov x+3, pwm_counter+3
0D3C           1576   
0D3C 753EDB    1577            mov y+0, #low (PWM_PERIOD % 0x10000) 
0D3F 753F05    1577            mov y+1, #high(PWM_PERIOD % 0x10000) 
0D42 754000    1577            mov y+2, #low (PWM_PERIOD / 0x10000) 
0D45 754100    1577            mov y+3, #high(PWM_PERIOD / 0x10000) 
0D48           1578   
0D48           1579       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0D48           1580       ; increase x by 1
0D48 120152    1581       lcall x_eq_y 
0D4B 20001D    1582       jb mf, wrap_pwm_counter
0D4E           1583       ; x not equal 1499, increment by 1
0D4E 753E01    1584            mov y+0, #low (1 % 0x10000) 
0D51 753F00    1584            mov y+1, #high(1 % 0x10000) 
0D54 754000    1584            mov y+2, #low (1 / 0x10000) 
0D57 754100    1584            mov y+3, #high(1 / 0x10000) 
0D5A 1200D3    1585       lcall add32
0D5D           1586       ; update pwm_counter
0D5D 853A5C    1587       mov pwm_counter, x
0D60 853B5D    1588       mov pwm_counter+1, x+1
0D63 853C5E    1589       mov pwm_counter+2, x+2
0D66 853D5F    1590       mov pwm_counter+3, x+3
0D69 8018      1591       sjmp set_pwm
0D6B           1592   
0D6B           1593   wrap_pwm_counter:
0D6B           1594       ; x equal 1499, wrap to 0
0D6B 753A00    1595            mov x+0, #low (0 % 0x10000) 
0D6E 753B00    1595            mov x+1, #high(0 % 0x10000) 
0D71 753C00    1595            mov x+2, #low (0 / 0x10000) 
0D74 753D00    1595            mov x+3, #high(0 / 0x10000) 
0D77 853A5C    1596       mov pwm_counter, x
0D7A 853B5D    1597       mov pwm_counter+1, x+1
0D7D 853C5E    1598       mov pwm_counter+2, x+2
0D80 853D5F    1599       mov pwm_counter+3, x+3
0D83           1600   
0D83           1601   set_pwm:
0D83           1602       ; compare with power_output, if pwm counter smaller than power_output, 
0D83           1603       ; set pwm pin high; else set pwm pin low load y with power output value
0D83 85583E    1604       mov y, power_output
0D86 85593F    1605       mov y+1, power_output+1
0D89 855A40    1606       mov y+2, power_output+2
0D8C 855B41    1607       mov y+3, power_output+3
0D8F           1608   
0D8F           1609       ; compare x(pwm counter) with y(power output)
0D8F 12011A    1610       lcall x_lt_y
0D92 200006    1611       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
0D95           1612       ;output set pwm pin low if pwm counter greater than power output
0D95 C293      1613       clr PWM_OUT
0D97 C2EC      1614       clr LEDRA.4
0D99 8004      1615       sjmp end_pwm_generator
0D9B           1616   
0D9B           1617   set_pwm_high:
0D9B D293      1618       setb PWM_OUT
0D9D D2EC      1619       setb LEDRA.4
0D9F           1620   
0D9F           1621   end_pwm_generator:
0D9F 22        1622       ret
0DA0           1623   
0DA0           1624   ;-------------------------------------------------------------------------------
0DA0           1625   
0DA0           1626   ;-------------------------------------------------------------------------------;
0DA0           1627   ; Abort condition safety check Temperature time
0DA0           1628   ;
0DA0           1629   ; PURPOSE:
0DA0           1630   ;   Automatic cycle termination on error:
0DA0           1631   ;   Abort if oven fails to reach at least 50C in first 60s (1 minute).
0DA0           1632   ;
0DA0           1633   ; TRIP CONDITION:
0DA0           1634   ;   if (current_time_minute >= 1) AND (current_temp < 50C)
0DA0           1635   ;       -> set tc_missing_abort
0DA0           1636   ;       -> set stop_signal
0DA0           1637   ;
0DA0           1638   ; ASSUMPTIONS:
0DA0           1639   ;   - current_time_sec (byte): seconds 0-59
0DA0           1640   ;   - current_time_minute (byte): minutes counter
0DA0           1641   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0DA0           1642   ;-------------------------------------------------------------------------------;
0DA0           1643   Safety_Check_TC:
0DA0 C0E0      1644       push acc
0DA2 C0D0      1645       push psw
0DA4 C000      1646       push AR0
0DA6 C001      1647       push AR1
0DA8           1648   
0DA8           1649       ; ---------------------------------------------------------
0DA8           1650       ; GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0DA8           1651       ; ---------------------------------------------------------
0DA8 E560      1652       mov a, Control_FSM_state
0DAA B40202    1653       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0DAD 8003      1654       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0DAF           1655   
0DAF           1656   Safety_TC_Exit_Bridge:
0DAF 020DE8    1657       ljmp Safety_TC_Done               ; Jump to the end
0DB2           1658   
0DB2           1659   Safety_Logic_Proceed:
0DB2           1660       ; If already aborted or startup window closed, do nothing
0DB2 201333    1661       jb   tc_missing_abort, Safety_TC_Done
0DB5 301430    1662       jnb  tc_startup_window, Safety_TC_Done
0DB8           1663   
0DB8           1664       ; Check: current_time_minute >= 1 ? (has 1 minute passed?)
0DB8 E531      1665       mov  a, current_time_minute
0DBA 602C      1666       jz   Safety_TC_Done               ; minute == 0, still waiting
0DBC           1667   
0DBC           1668       ; We reached 1 minute: close the startup window so it won't re-check later
0DBC C214      1669       clr  tc_startup_window
0DBE           1670   
0DBE           1671       ; Now check: current_temp < 50 ?
0DBE 7847      1672       mov  R0, #current_temp
0DC0 793A      1673       mov  R1, #x
0DC2 120D20    1674       lcall Copy4_Bytes_R0_to_R1
0DC5           1675   
0DC5 753E32    1676            mov y+0, #low (50 % 0x10000) 
0DC8 753F00    1676            mov y+1, #high(50 % 0x10000) 
0DCB 754000    1676            mov y+2, #low (50 / 0x10000) 
0DCE 754100    1676            mov y+3, #high(50 / 0x10000) 
0DD1 12011A    1677       lcall x_lt_y
0DD4 300011    1678       jnb  mf, Safety_TC_Done           ; temp >= 50  pass
0DD7           1679   
0DD7           1680       ; FAIL: at 1 minute, still below 50C  abort
0DD7 C293      1681       clr  PWM_OUT
0DD9 D213      1682       setb tc_missing_abort
0DDB D20B      1683       setb stop_signal
0DDD 120E25    1684       lcall Beep_Ten
0DE0           1685       
0DE0           1686       ; Force FSM to State 0 (Welcome)
0DE0 756000    1687       mov Control_FSM_state, #0
0DE3           1688       
0DE3           1689       ; Force UI to State 0 (Home Screen)
0DE3 756100    1690       mov Current_State, #0
0DE6           1691       
0DE6           1692       ; Trigger Screen Refresh
0DE6 D20F      1693       setb state_change_signal          ; Tell loop to redraw "Welcome"
0DE8           1694   
0DE8           1695   Safety_TC_Done:
0DE8 D001      1696       pop  AR1
0DEA D000      1697       pop  AR0
0DEC D0D0      1698       pop  psw
0DEE D0E0      1699       pop  acc
0DF0 22        1700       ret
0DF1           1701   
0DF1           1702   ; ============================================================
0DF1           1703   ; BUZZER STARTUP FUNCTIONS
0DF1           1704   ; ============================================================
0DF1           1705   ;============================================================
0DF1           1706   ; Beep_Judge
0DF1           1707   ; Purpose: Trigger appropriate beep pattern based on events
0DF1           1708   ;   - Beep once when state changes
0DF1           1709   ;   - Beep five times when entering state 6 (cooling/finished)
0DF1           1710   ;   - Beep ten times if tc_missing_abort = 1 (error)
0DF1           1711   ;
0DF1           1712   ; Call this in main loop after Control_FSM
0DF1           1713   ;============================================================
0DF1           1714   Beep_Judge:
0DF1 C0E0      1715       push acc
0DF3 C0D0      1716       push psw
0DF5           1717   
0DF5           1718       ; --- Priority 1: Error condition (highest priority) ---
0DF5 30130A    1719       jnb tc_missing_abort, Beep_Judge_Check_State6
0DF8           1720       ; Error detected - beep 10 times (only once per error)
0DF8 20191B    1721       jb beep_error_done, Beep_Judge_Done   ; Already beeped for this error?
0DFB D219      1722       setb beep_error_done                   ; Mark as handled
0DFD 120E25    1723       lcall Beep_Ten
0E00 8014      1724       sjmp Beep_Judge_Done
0E02           1725   
0E02           1726   Beep_Judge_Check_State6:
0E02           1727       ; --- Priority 2: Entering State 6 (finished) ---
0E02 301211    1728       jnb state_change_beep_signal, Beep_Judge_Done  ; No state change? Exit
0E05           1729       
0E05 E560      1730       mov a, Control_FSM_state
0E07 B40607    1731       cjne a, #6, Beep_Judge_Normal_Change
0E0A           1732       ; Entering state 6 - beep 5 times
0E0A C212      1733       clr state_change_beep_signal               ; Consume the signal
0E0C 120E20    1734       lcall Beep_Five
0E0F 8005      1735       sjmp Beep_Judge_Done
0E11           1736   
0E11           1737   Beep_Judge_Normal_Change:
0E11           1738       ; --- Priority 3: Normal state change - beep once ---
0E11 C212      1739       clr state_change_beep_signal               ; Consume the signal
0E13 120E1B    1740       lcall Beep_Once
0E16           1741   
0E16           1742   Beep_Judge_Done:
0E16 D0D0      1743       pop psw
0E18 D0E0      1744       pop acc
0E1A 22        1745       ret
0E1B           1746   
0E1B           1747   Beep_Once:
0E1B 757501    1748       mov beep_count, #1
0E1E 800A      1749       sjmp Beep_Start
0E20           1750   
0E20           1751   Beep_Five:
0E20 757505    1752       mov beep_count, #5
0E23 8005      1753       sjmp Beep_Start
0E25           1754   
0E25           1755   Beep_Ten:
0E25 75750A    1756       mov beep_count, #10
0E28 8000      1757       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0E2A           1758   
0E2A           1759   Beep_Start:
0E2A C28C      1760       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0E2C 757601    1761       mov beep_state, #1   ; Set State to ON
0E2F 757700    1762       mov beep_tmr, #0     ; Reset Timer High Byte
0E32 757800    1763       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0E35 D2A9      1764       setb ET0             ; [FIX] Ensure Interrupt is enabled
0E37 D28C      1765       setb TR0             ; START the 2kHz tone
0E39 22        1766       ret
0E3A           1767   ;============================================================
0E3A           1768   
0E3A           1769   ;============================================================
0E3A           1770   ; Buzzer beep Task 
0E3A           1771   ; Purpose: beeps, holds, stop
0E3A           1772   ; Buzzer task:
0E3A           1773   ; Beep once when state changes
0E3A           1774   ; Beep five times if finished
0E3A           1775   ; Beep ten times if meets error
0E3A           1776   ;============================================================
0E3A           1777   Beep_Task:
0E3A 301835    1778       jnb one_ms_beep_flag, Beep_Done
0E3D C218      1779       clr one_ms_beep_flag
0E3F           1780   
0E3F E576      1781       mov a, beep_state
0E41 602F      1782       jz Beep_Done
0E43           1783   
0E43           1784   ; ---- increment 16-bit timer ----
0E43 0577      1785       inc beep_tmr
0E45 E577      1786       mov a, beep_tmr
0E47 7002      1787       jnz Beep_Check
0E49 0578      1788       inc beep_tmr+1
0E4B           1789   
0E4B           1790   Beep_Check:
0E4B           1791       ; [FIX] FUZZY TIMER CHECK
0E4B           1792       ; Check if High Byte is non-zero (Time >= 256ms)
0E4B E578      1793       mov a, beep_tmr+1
0E4D 6023      1794       jz Beep_Done        ; If 0, keep beeping
0E4F           1795   
0E4F           1796       ; --- Time Limit Reached ---
0E4F 757700    1797       mov beep_tmr, #0    ; Reset timer
0E52 757800    1798       mov beep_tmr+1, #0
0E55           1799   
0E55 E576      1800       mov a, beep_state
0E57 B40106    1801       cjne a, #1, Beep_Off_State
0E5A           1802   
0E5A           1803       ; State was 1 (ON) -> Turn OFF
0E5A C28C      1804       clr TR0             ; Hardware Silence
0E5C 757602    1805       mov beep_state, #2  ; Set State to OFF (Pause)
0E5F 22        1806       ret
0E60           1807   
0E60           1808   Beep_Off_State:
0E60           1809   ; ---- OFF finished -> decrement count / next ON ----
0E60 1575      1810       dec beep_count
0E62 E575      1811       mov a, beep_count
0E64 6006      1812       jz  Beep_Stop
0E66           1813   
0E66 757601    1814       mov beep_state, #1
0E69 D28C      1815       setb TR0
0E6B 22        1816       ret
0E6C           1817   
0E6C           1818   Beep_Stop:
0E6C C28C      1819       clr TR0
0E6E 757600    1820       mov beep_state, #0
0E71 22        1821       ret
0E72           1822   
0E72           1823   Beep_Done:
0E72 22        1824       ret
0E73           1825   ;==================================================================
0E73           1826   
0E73           1827   ;-------------------------------------------------------------------------------;
0E73           1828   ; Main Control FSM for the entire process
0E73           1829   ;-------------------------------------------------------------------------------;
0E73           1830   ;-------------------------------------------------------------------------------;
0E73           1831   ; FSM LOGIC (Button Logic Fixed)
0E73           1832   ;-------------------------------------------------------------------------------;
0E73           1833   Control_FSM:
0E73 E560      1834       mov a, Control_FSM_state
0E75 8008      1835       sjmp Control_FSM_state0
0E77           1836   
0E77           1837   Control_FSM_state0_a:
0E77 756000    1838            mov Control_FSM_state, #0
0E7A D20F      1839            setb state_change_signal
0E7C D210      1840            setb state_change_signal_TC
0E7E 22        1841            ret
0E7F           1842   Control_FSM_state0:
0E7F B40017    1843       cjne a, #0, Control_FSM_state1
0E82 C219      1844       clr beep_error_done
0E84 301504    1845       jnb PB0_flag, Control_FSM_state0_ret  ; Check flag
0E87 C215      1846       clr PB0_flag                 
0E89 8001      1847       sjmp Control_FSM_state1_a
0E8B           1848   Control_FSM_state0_ret:
0E8B 22        1849       ret
0E8C           1850   
0E8C           1851   Control_FSM_state1_a:
0E8C 756001    1852       mov Control_FSM_state, #1
0E8F 756100    1853       mov Current_State, #0
0E92 D20F      1854       setb state_change_signal
0E94 D210      1855            setb state_change_signal_TC
0E96 D212      1856       setb state_change_beep_signal
0E98 22        1857            ret
0E99           1858   Control_FSM_state1:
0E99 B40116    1859       cjne a, #1, Control_FSM_state2
0E9C 301504    1860       jnb PB0_flag, Control_FSM_state1_ret  ; Check flag
0E9F C215      1861       clr PB0_flag                    
0EA1 8001      1862       sjmp Control_FSM_state2_a
0EA3           1863   Control_FSM_state1_ret:
0EA3 22        1864       ret
0EA4           1865   
0EA4           1866   ; --- STATE 2: RAMP TO SOAK ---
0EA4           1867   Control_FSM_state2_a:
0EA4 756002    1868            mov Control_FSM_state, #2
0EA7 D20F      1869            setb state_change_signal
0EA9 D210      1870            setb state_change_signal_TC
0EAB D211      1871            setb state_change_signal_Count
0EAD D212      1872       setb state_change_beep_signal
0EAF C205      1873       clr soak_temp_reached
0EB1 22        1874            ret
0EB2           1875   Control_FSM_state2:
0EB2 B4021C    1876       cjne a, #2, Control_FSM_state3
0EB5 301705    1877       jnb PB2_flag, State2_Check
0EB8 C217      1878       clr PB2_flag
0EBA 020F1F    1879       ljmp Control_FSM_state6_a ; Pause
0EBD           1880   
0EBD           1881   State2_Check:
0EBD 300506    1882       jnb soak_temp_reached, State2_Ret
0EC0           1883       
0EC0           1884       ; --- We reached Temp! Move to State 3 ---
0EC0 C205      1885       clr soak_temp_reached
0EC2 C208      1886       clr soak_time_reached
0EC4 8001      1887            sjmp Control_FSM_state3_a
0EC6           1888   State2_Ret:
0EC6 22        1889       ret
0EC7           1890   
0EC7           1891   ; --- STATE 3: SOAK PHASE ---
0EC7           1892   Control_FSM_state3_a:
0EC7 756003    1893            mov Control_FSM_state, #3
0ECA D20F      1894            setb state_change_signal
0ECC D210      1895            setb state_change_signal_TC
0ECE D212      1896       setb state_change_beep_signal
0ED0 22        1897            ret
0ED1           1898   Control_FSM_state3:
0ED1 B4031A    1899       cjne a, #3, Control_FSM_state4
0ED4 301705    1900       jnb PB2_flag, State3_Check
0ED7 C217      1901       clr PB2_flag
0ED9 020F1F    1902       ljmp Control_FSM_state6_a
0EDC           1903   State3_Check:
0EDC 300804    1904       jnb soak_time_reached, State3_Ret
0EDF C208      1905       clr soak_time_reached
0EE1 8001      1906       sjmp Control_FSM_state4_a
0EE3           1907   State3_Ret:
0EE3 22        1908       ret
0EE4           1909   
0EE4           1910   ; --- STATE 4: RAMP TO PEAK ---
0EE4           1911   Control_FSM_state4_a:
0EE4 756004    1912            mov Control_FSM_state, #4
0EE7 D20F      1913            setb state_change_signal
0EE9 D210      1914            setb state_change_signal_TC
0EEB D212      1915       setb state_change_beep_signal
0EED 22        1916            ret
0EEE           1917   Control_FSM_state4:
0EEE B4041C    1918       cjne a, #4, Control_FSM_state5
0EF1 301705    1919       jnb PB2_flag, State4_Check
0EF4 C217      1920       clr PB2_flag
0EF6 020F1F    1921       ljmp Control_FSM_state6_a
0EF9           1922   State4_Check:
0EF9 300606    1923       jnb reflow_temp_reached, State4_Ret
0EFC C206      1924       clr reflow_temp_reached
0EFE C209      1925       clr reflow_time_reached
0F00 8001      1926            sjmp Control_FSM_state5_a
0F02           1927   State4_Ret:
0F02 22        1928       ret
0F03           1929   
0F03           1930   ; --- STATE 5: REFLOW PHASE ---
0F03           1931   Control_FSM_state5_a:
0F03 756005    1932            mov Control_FSM_state, #5
0F06 D20F      1933            setb state_change_signal
0F08 D210      1934            setb state_change_signal_TC
0F0A D212      1935       setb state_change_beep_signal
0F0C 22        1936            ret
0F0D           1937   Control_FSM_state5:
0F0D B4051D    1938       cjne a, #5, Control_FSM_state6
0F10 301704    1939       jnb PB2_flag, State5_Check
0F13 C217      1940       clr PB2_flag
0F15 8008      1941       sjmp Control_FSM_state6_a
0F17           1942   State5_Check:
0F17 300904    1943       jnb reflow_time_reached, State5_Ret
0F1A C209      1944       clr reflow_time_reached
0F1C 8001      1945       sjmp Control_FSM_state6_a
0F1E           1946   State5_Ret:
0F1E 22        1947       ret
0F1F           1948   
0F1F           1949   ; --- STATE 6: COOLING ---
0F1F           1950   Control_FSM_state6_a:
0F1F 756006    1951            mov Control_FSM_state, #6
0F22 D20F      1952            setb state_change_signal
0F24 D210      1953            setb state_change_signal_TC
0F26 D211      1954            setb state_change_signal_Count
0F28 D212      1955       setb state_change_beep_signal
0F2A C207      1956       clr cooling_temp_reached
0F2C 22        1957            ret
0F2D           1958   Control_FSM_state6:
0F2D B40612    1959       cjne a, #6, Control_FSM_state7
0F30           1960       ; Wait for Cooling Temp Reached
0F30 300704    1961       jnb cooling_temp_reached, State6_Ret
0F33 C207      1962       clr cooling_temp_reached
0F35 8001      1963       sjmp Control_FSM_state7_a
0F37           1964   State6_Ret:
0F37 22        1965       ret
0F38           1966   
0F38           1967   ; --- STATE 7: DONE ---
0F38           1968   Control_FSM_state7_a:
0F38 756007    1969            mov Control_FSM_state, #7
0F3B D20F      1970            setb state_change_signal
0F3D D210      1971            setb state_change_signal_TC
0F3F D212      1972       setb state_change_beep_signal
0F41 22        1973            ret
0F42           1974   Control_FSM_state7:
0F42 B40708    1975       cjne a, #7, Control_FSM_done
0F45           1976       ; Let's assume you meant the physical button P1.0 like State 0
0F45 101502    1977       jbc PB0_flag, Control_FSM_state7_pressed
0F48 8003      1978            sjmp Control_FSM_done
0F4A           1979   Control_FSM_state7_pressed:
0F4A 020E77    1980       ljmp Control_FSM_state0_a
0F4D           1981   
0F4D           1982   Control_FSM_done:
0F4D 22        1983       ret
0F4E           1984   
0F4E           1985   ; ================================================================
0F4E           1986   ; UI & HELPER SUBROUTINES
0F4E           1987   ; ================================================================
0F4E           1988   
0F4E           1989   ; ----------------------------------------------------------------
0F4E           1990   ; MODULE: BRIDGE (Text to Integer Conversion)
0F4E           1991   ; ----------------------------------------------------------------
0F4E           1992   
0F4E           1993   ;--------------------------
0F4E           1994   ;keep updating varaibles
0F4E           1995   Update_FSM_Variables:
0F4E C0E0      1996            push ACC
0F50 C006      1997            push AR6
0F52 C007      1998            push AR7
0F54 E560      1999            mov a, Control_FSM_state
0F56 B40132    2000            cjne a, #1, Update_FSM_Variables_done
0F59           2001   
0F59           2002       ; --- 1. SOAK TEMP ---
0F59 7880      2003       mov R0, #Buf_Soak_Temp
0F5B 120F92    2004       lcall Parse_Temp_String
0F5E 8F4B      2005       mov soak_temp+0, R7
0F60 754C00    2006       mov soak_temp+1, #0
0F63 754D00    2007       mov soak_temp+2, #0
0F66 754E00    2008       mov soak_temp+3, #0
0F69           2009   
0F69           2010       ; --- 2. REFLOW TEMP ---
0F69 7889      2011       mov R0, #Buf_Refl_Temp
0F6B 120F92    2012       lcall Parse_Temp_String
0F6E 8F4F      2013       mov reflow_temp+0, R7
0F70 755000    2014       mov reflow_temp+1, #0
0F73 755100    2015       mov reflow_temp+2, #0
0F76 755200    2016       mov reflow_temp+3, #0
0F79           2017   
0F79           2018       ; --- 3. SOAK TIME ---
0F79 7884      2019       mov R0, #Buf_Soak_Time
0F7B 120FA6    2020       lcall Parse_Time_String
0F7E 8F33      2021       mov soak_time_minute, R7
0F80 8E32      2022       mov soak_time_sec, R6
0F82           2023   
0F82           2024       ; --- 4. REFLOW TIME ---
0F82 788D      2025       mov R0, #Buf_Refl_Time
0F84 120FA6    2026       lcall Parse_Time_String
0F87 8F35      2027       mov reflow_time_minute, R7
0F89 8E34      2028       mov reflow_time_sec, R6
0F8B           2029   
0F8B           2030   Update_FSM_Variables_done:
0F8B D007      2031            pop AR7
0F8D D006      2032            pop AR6
0F8F D0E0      2033            pop ACC
0F91 22        2034       ret
0F92           2035   ;--------------------------
0F92           2036   
0F92           2037   ; --- Helper: Parse "123" to Integer ---
0F92           2038   Parse_Temp_String:
0F92 7F00      2039       mov R7, #0              ; Clear Result
0F94           2040   Parse_Temp_Loop:
0F94 E6        2041       mov A, @R0
0F95 600E      2042       jz Parse_Temp_Done      ; If Null, we are done
0F97           2043       
0F97           2044       ; Convert ASCII to Digit
0F97 C3        2045       clr C
0F98 9430      2046       subb A, #0x30
0F9A FD        2047       mov R5, A               ; R5 = New Digit
0F9B           2048       
0F9B           2049       ; Result = (Result * 10) + New Digit
0F9B EF        2050       mov A, R7
0F9C 75F00A    2051       mov B, #10
0F9F A4        2052       mul AB
0FA0 2D        2053       add A, R5
0FA1 FF        2054       mov R7, A
0FA2           2055       
0FA2 08        2056       inc R0
0FA3 80EF      2057       sjmp Parse_Temp_Loop
0FA5           2058   Parse_Temp_Done:
0FA5 22        2059       ret
0FA6           2060   
0FA6           2061   ; --- Helper: Parse "MMSS" to Seconds ---
0FA6           2062   Parse_Time_String:
0FA6           2063       ; Minutes tens
0FA6 E6        2064       mov A, @R0
0FA7 C3        2065       clr C
0FA8 9430      2066       subb A, #0x30
0FAA 75F00A    2067       mov B, #10
0FAD A4        2068       mul AB
0FAE FD        2069       mov R5, A
0FAF 08        2070       inc R0
0FB0           2071   
0FB0           2072       ; Minutes ones
0FB0 E6        2073       mov A, @R0
0FB1 C3        2074       clr C
0FB2 9430      2075       subb A, #0x30
0FB4 2D        2076       add A, R5
0FB5 FD        2077       mov R5, A
0FB6 08        2078       inc R0
0FB7           2079   
0FB7           2080       ; Seconds tens
0FB7 E6        2081       mov A, @R0
0FB8 C3        2082       clr C
0FB9 9430      2083       subb A, #0x30
0FBB 75F00A    2084       mov B, #10
0FBE A4        2085       mul AB
0FBF FC        2086       mov R4, A
0FC0 08        2087       inc R0
0FC1           2088   
0FC1           2089       ; Seconds ones
0FC1 E6        2090       mov A, @R0
0FC2 C3        2091       clr C
0FC3 9430      2092       subb A, #0x30
0FC5 2C        2093       add A, R4
0FC6 FC        2094       mov R4, A
0FC7           2095   
0FC7           2096       ; Return minutes/seconds
0FC7 ED        2097            mov a, R5
0FC8 FF        2098       mov R7, a     ; minutes
0FC9 EC        2099            mov a, R4
0FCA FE        2100       mov R6, a     ; seconds
0FCB 22        2101       ret
0FCC           2102   
0FCC           2103   ; ----------------------------------------------------------------
0FCC           2104   ; MODULE: BUTTON HANDLER (Mode Selection)
0FCC           2105   ; ----------------------------------------------------------------
0FCC           2106   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0FCC           2107   Wait_25ms_BLOCKING:
0FCC 1211AA    2108       lcall Wait_25ms
0FCF 50FB      2109       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0FD1 22        2110       ret
0FD2           2111   
0FD2           2112   ; ----------------------------------------------------------------
0FD2           2113   ; MODULE: BUTTON HANDLER (Non-Blocking Debounce)
0FD2           2114   ; ----------------------------------------------------------------
0FD2           2115   ; Variables needed:
0FD2           2116   ;   BTN_DEB_state   - state machine state (0-3)
0FD2           2117   ;   BTN_DEB_timer   - debounce timer (incremented by ISR every 1ms)
0FD2           2118   ;   BTN_DEB_id      - which button was pressed (1-4)
0FD2           2119   ; ----------------------------------------------------------------
0FD2           2120   
0FD2           2121   Check_Buttons:
0FD2 C0E0      2122       push ACC
0FD4 C0D0      2123       push PSW
0FD6           2124       
0FD6           2125       ; Only process in Control_FSM_state 1
0FD6 E560      2126       mov a, Control_FSM_state
0FD8 B40107    2127       cjne a, #1, Check_Buttons_Done_bridge
0FDB           2128       
0FDB           2129       ; --- FORCE INPUT MODE ---
0FDB 438055    2130       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, P0.6 to '1' (Input Mode)
0FDE           2131       
0FDE E57A      2132       mov a, BTN_DEB_state
0FE0 8003      2133       sjmp BTN_DEB_state0
0FE2           2134   
0FE2           2135   Check_Buttons_Done_bridge:
0FE2 02108C    2136       ljmp Check_Buttons_Done
0FE5           2137   
0FE5           2138   ; ============================================================
0FE5           2139   ; State 0: Wait for any button press
0FE5           2140   ; ============================================================
0FE5           2141   BTN_DEB_state0:
0FE5 B4002A    2142       cjne a, #0, BTN_DEB_state1
0FE8           2143       
0FE8           2144       ; Check each button, record which one was pressed
0FE8 30800C    2145       jnb BTN_SOAK_TEMP, BTN_Detect_SoakTemp
0FEB 30820E    2146       jnb BTN_SOAK_TIME, BTN_Detect_SoakTime
0FEE 308410    2147       jnb BTN_REFL_TEMP, BTN_Detect_ReflTemp
0FF1 308612    2148       jnb BTN_REFL_TIME, BTN_Detect_ReflTime
0FF4 02108C    2149       ljmp Check_Buttons_Done     ; No button pressed
0FF7           2150   
0FF7           2151   BTN_Detect_SoakTemp:
0FF7 757C01    2152       mov BTN_DEB_id, #1
0FFA 800F      2153       sjmp BTN_Start_Debounce
0FFC           2154   BTN_Detect_SoakTime:
0FFC 757C02    2155       mov BTN_DEB_id, #2
0FFF 800A      2156       sjmp BTN_Start_Debounce
1001           2157   BTN_Detect_ReflTemp:
1001 757C03    2158       mov BTN_DEB_id, #3
1004 8005      2159       sjmp BTN_Start_Debounce
1006           2160   BTN_Detect_ReflTime:
1006 757C04    2161       mov BTN_DEB_id, #4
1009 8000      2162       sjmp BTN_Start_Debounce
100B           2163   
100B           2164   BTN_Start_Debounce:
100B 757B00    2165       mov BTN_DEB_timer, #0
100E 057A      2166       inc BTN_DEB_state
1010 807A      2167       sjmp Check_Buttons_Done
1012           2168   
1012           2169   ; ============================================================
1012           2170   ; State 1: Debounce delay (wait 50ms)
1012           2171   ; ============================================================
1012           2172   BTN_DEB_state1:
1012 B40109    2173       cjne a, #1, BTN_DEB_state2
1015 E57B      2174       mov a, BTN_DEB_timer
1017 B43272    2175       cjne a, #50, Check_Buttons_Done   ; Wait 50ms
101A 057A      2176       inc BTN_DEB_state
101C 806E      2177       sjmp Check_Buttons_Done
101E           2178   
101E           2179   ; ============================================================
101E           2180   ; State 2: Verify button still pressed
101E           2181   ; ============================================================
101E           2182   BTN_DEB_state2:
101E B40226    2183       cjne a, #2, BTN_DEB_state3
1021           2184       
1021           2185       ; Check if the same button is still pressed
1021 E57C      2186       mov a, BTN_DEB_id
1023 B40105    2187       cjne a, #1, BTN_Verify_Check2
1026 30801A    2188       jnb BTN_SOAK_TEMP, BTN_Verify_OK
1029 8013      2189       sjmp BTN_Verify_Fail
102B           2190   BTN_Verify_Check2:
102B B40205    2191       cjne a, #2, BTN_Verify_Check3
102E 308212    2192       jnb BTN_SOAK_TIME, BTN_Verify_OK
1031 800B      2193       sjmp BTN_Verify_Fail
1033           2194   BTN_Verify_Check3:
1033 B40305    2195       cjne a, #3, BTN_Verify_Check4
1036 30840A    2196       jnb BTN_REFL_TEMP, BTN_Verify_OK
1039 8003      2197       sjmp BTN_Verify_Fail
103B           2198   BTN_Verify_Check4:
103B 308605    2199       jnb BTN_REFL_TIME, BTN_Verify_OK
103E           2200       ; Fall through to fail
103E           2201   
103E           2202   BTN_Verify_Fail:
103E 757A00    2203       mov BTN_DEB_state, #0           ; Was noise, reset
1041 8049      2204       sjmp Check_Buttons_Done
1043           2205   
1043           2206   BTN_Verify_OK:
1043 057A      2207       inc BTN_DEB_state               ; Confirmed, wait for release
1045 8045      2208       sjmp Check_Buttons_Done
1047           2209   
1047           2210   ; ============================================================
1047           2211   ; State 3: Wait for button release, then trigger action
1047           2212   ; ============================================================
1047           2213   BTN_DEB_state3:
1047 B40342    2214       cjne a, #3, Check_Buttons_Done
104A           2215       
104A           2216       ; Check if the button is released
104A E57C      2217       mov a, BTN_DEB_id
104C B40105    2218       cjne a, #1, BTN_Release_Check2
104F 30803A    2219       jnb BTN_SOAK_TEMP, Check_Buttons_Done   ; Still pressed, wait
1052 8013      2220       sjmp BTN_Do_Action
1054           2221   BTN_Release_Check2:
1054 B40205    2222       cjne a, #2, BTN_Release_Check3
1057 308232    2223       jnb BTN_SOAK_TIME, Check_Buttons_Done
105A 800B      2224       sjmp BTN_Do_Action
105C           2225   BTN_Release_Check3:
105C B40305    2226       cjne a, #3, BTN_Release_Check4
105F 30842A    2227       jnb BTN_REFL_TEMP, Check_Buttons_Done
1062 8003      2228       sjmp BTN_Do_Action
1064           2229   BTN_Release_Check4:
1064 308625    2230       jnb BTN_REFL_TIME, Check_Buttons_Done
1067           2231       ; Fall through to action
1067           2232   
1067           2233   ; ============================================================
1067           2234   ; Button Released - Execute Action
1067           2235   ; ============================================================
1067           2236   BTN_Do_Action:
1067 E57C      2237       mov a, BTN_DEB_id
1069           2238       
1069 B40105    2239       cjne a, #1, BTN_Action_2
106C 756101    2240       mov Current_State, #1           ; Soak Temp
106F 8013      2241       sjmp BTN_Action_Complete
1071           2242   BTN_Action_2:
1071 B40205    2243       cjne a, #2, BTN_Action_3
1074 756102    2244       mov Current_State, #2           ; Soak Time
1077 800B      2245       sjmp BTN_Action_Complete
1079           2246   BTN_Action_3:
1079 B40305    2247       cjne a, #3, BTN_Action_4
107C 756103    2248       mov Current_State, #3           ; Refl Temp
107F 8003      2249       sjmp BTN_Action_Complete
1081           2250   BTN_Action_4:
1081 756104    2251       mov Current_State, #4           ; Refl Time
1084           2252   
1084           2253   BTN_Action_Complete:
1084 756A00    2254       mov Cursor_Idx, #0
1087 D224      2255       setb fullscreen_update_signal   ; Trigger screen redraw
1089 757A00    2256       mov BTN_DEB_state, #0           ; Reset state machine
108C           2257   
108C           2258   Check_Buttons_Done:
108C D0D0      2259       pop PSW
108E D0E0      2260       pop ACC
1090 22        2261       ret
1091           2262   
1091           2263   ; ----------------------------------------------------------------
1091           2264   ; MODULE: KEYPAD HANDLER (Input Logic)
1091           2265   ; ----------------------------------------------------------------
1091           2266   Check_Keypad:
1091 E560      2267       mov a, Control_FSM_state
1093 B40152    2268       cjne a, #1, Keypad_Exit
1096           2269   
1096           2270       ; If State is 0 (Home), ignore keypad
1096 E561      2271       mov A, Current_State
1098 604E      2272       jz Keypad_Exit
109A           2273       
109A 1210E9    2274       lcall Keypad_Scan
109D 5049      2275       jnc Keypad_Exit         ; Carry = 0 means no key pressed
109F           2276   
109F           2277       ; --- Check Special Keys ---
109F EF        2278       mov A, R7
10A0 B40E09    2279       cjne A, #14, Check_Hash ; 14 is Star (*)
10A3           2280       
10A3           2281       ; Star Key Pressed: Reset Buffer
10A3 1211ED    2282       lcall Reset_Current_Buffer
10A6 D224      2283       setb fullscreen_update_signal
10A8 756A00    2284       mov Cursor_Idx, #0
10AB 22        2285       ret
10AC           2286   
10AC           2287   Check_Hash:
10AC EF        2288       mov A, R7
10AD B40C01    2289       cjne A, #12, Check_Numeric ; 12 is Hash (#)
10B0 22        2290       ret                     ; Ignore Hash key
10B1           2291   
10B1           2292   Check_Numeric:
10B1           2293       ; Ensure key is 0-9
10B1 EF        2294       mov A, R7
10B2 C3        2295       clr C
10B3 940A      2296       subb A, #10
10B5 5030      2297       jnc Symbol_Key_Ignored
10B7           2298       
10B7           2299       ; Convert to ASCII
10B7 EF        2300       mov A, R7
10B8 2430      2301       add A, #0x30
10BA FD        2302       mov R5, A
10BB           2303   
10BB           2304       ; Save to Buffer
10BB 120B25    2305       lcall Get_Current_Buffer_Addr
10BE E56A      2306       mov A, Cursor_Idx
10C0 28        2307       add A, R0
10C1 F8        2308       mov R0, A
10C2 ED        2309       mov A, R5
10C3 F6        2310       mov @R0, A
10C4 056A      2311       inc Cursor_Idx
10C6           2312   
10C6           2313       ; --- Check Cursor Limits ---
10C6 E561      2314       mov A, Current_State
10C8 B40102    2315       cjne A, #1, Check_Limit_Time_1
10CB 8005      2316       sjmp Limit_Temp_3
10CD           2317   
10CD           2318   Check_Limit_Time_1:
10CD B4030B    2319       cjne A, #3, Limit_Time_4
10D0 8000      2320       sjmp Limit_Temp_3
10D2           2321   
10D2           2322   Limit_Temp_3:
10D2 E56A      2323       mov A, Cursor_Idx
10D4 B4030D    2324       cjne A, #3, Do_Refresh
10D7 156A      2325       dec Cursor_Idx          ; Stay at last digit
10D9 8009      2326       sjmp Do_Refresh
10DB           2327   
10DB           2328   Limit_Time_4:
10DB E56A      2329       mov A, Cursor_Idx
10DD B40404    2330       cjne A, #4, Do_Refresh
10E0 156A      2331       dec Cursor_Idx          ; Stay at last digit
10E2 8000      2332       sjmp Do_Refresh
10E4           2333   
10E4           2334   Do_Refresh:
10E4 D224      2335       setb fullscreen_update_signal
10E6 22        2336       ret
10E7           2337   
10E7           2338   Symbol_Key_Ignored:
10E7 22        2339       ret
10E8           2340   Keypad_Exit:
10E8 22        2341       ret
10E9           2342   
10E9           2343   ; ----------------------------------------------------------------
10E9           2344   ; MODULE: HARDWARE SCANNER (Matrix Logic)
10E9           2345   ; ----------------------------------------------------------------
10E9           2346   Keypad_Scan:
10E9           2347       ; Step 1: Check if ANY key is pressed (All Rows Low)
10E9 C292      2348       clr ROW1
10EB C294      2349       clr ROW2
10ED C296      2350       clr ROW3
10EF C2A0      2351       clr ROW4
10F1 A2A2      2352       mov C, COL1
10F3 82A4      2353       anl C, COL2
10F5 82A6      2354       anl C, COL3
10F7 82B0      2355       anl C, COL4
10F9 5002      2356       jnc Keypad_Debounce
10FB C3        2357       clr C
10FC 22        2358       ret
10FD           2359   
10FD           2360   Keypad_Debounce:
10FD 120FCC    2361       lcall Wait_25ms_BLOCKING
1100 A2A2      2362       mov C, COL1
1102 82A4      2363       anl C, COL2
1104 82A6      2364       anl C, COL3
1106 82B0      2365       anl C, COL4
1108 5002      2366       jnc Keypad_Find_Row
110A C3        2367       clr C
110B 22        2368       ret
110C           2369   
110C           2370   Keypad_Find_Row:
110C D292      2371       setb ROW1
110E D294      2372       setb ROW2
1110 D296      2373       setb ROW3
1112 D2A0      2374       setb ROW4
1114           2375   
1114           2376       ; Row 1
1114 C292      2377       clr ROW1
1116 30A23D    2378       jnb COL1, Keypad_Key_1
1119 30A43E    2379       jnb COL2, Keypad_Key_2
111C 30A63F    2380       jnb COL3, Keypad_Key_3
111F 30B040    2381       jnb COL4, Keypad_Key_A
1122 D292      2382       setb ROW1
1124           2383   
1124           2384       ; Row 2
1124 C294      2385       clr ROW2
1126 30A23D    2386       jnb COL1, Keypad_Key_4
1129 30A43E    2387       jnb COL2, Keypad_Key_5
112C 30A63F    2388       jnb COL3, Keypad_Key_6
112F 30B040    2389       jnb COL4, Keypad_Key_B
1132 D294      2390       setb ROW2
1134           2391   
1134           2392       ; Row 3
1134 C296      2393       clr ROW3
1136 30A23D    2394       jnb COL1, Keypad_Key_7
1139 30A43E    2395       jnb COL2, Keypad_Key_8
113C 30A63F    2396       jnb COL3, Keypad_Key_9
113F 30B040    2397       jnb COL4, Keypad_Key_C
1142 D296      2398       setb ROW3
1144           2399   
1144           2400       ; Row 4
1144 C2A0      2401       clr ROW4
1146 30A23D    2402       jnb COL1, Keypad_Key_Star
1149 30A43E    2403       jnb COL2, Keypad_Key_0
114C 30A63F    2404       jnb COL3, Keypad_Key_Hash
114F 30B040    2405       jnb COL4, Keypad_Key_D
1152 D2A0      2406       setb ROW4
1154 C3        2407       clr C
1155 22        2408       ret
1156           2409   
1156           2410   ; Key Mapping (Renamed to avoid conflicts)
1156 7F01      2411   Keypad_Key_1: mov R7, #1
1158 803C      2412          sjmp Wait_Release
115A 7F02      2413   Keypad_Key_2: mov R7, #2
115C 8038      2414          sjmp Wait_Release
115E 7F03      2415   Keypad_Key_3: mov R7, #3
1160 8034      2416          sjmp Wait_Release
1162 7F0A      2417   Keypad_Key_A: mov R7, #10
1164 8030      2418          sjmp Wait_Release
1166 7F04      2419   Keypad_Key_4: mov R7, #4
1168 802C      2420          sjmp Wait_Release
116A 7F05      2421   Keypad_Key_5: mov R7, #5
116C 8028      2422          sjmp Wait_Release
116E 7F06      2423   Keypad_Key_6: mov R7, #6
1170 8024      2424          sjmp Wait_Release
1172 7F0B      2425   Keypad_Key_B: mov R7, #11
1174 8020      2426          sjmp Wait_Release
1176 7F07      2427   Keypad_Key_7: mov R7, #7
1178 801C      2428          sjmp Wait_Release
117A 7F08      2429   Keypad_Key_8: mov R7, #8
117C 8018      2430          sjmp Wait_Release
117E 7F09      2431   Keypad_Key_9: mov R7, #9
1180 8014      2432          sjmp Wait_Release
1182 7F0D      2433   Keypad_Key_C: mov R7, #13
1184 8010      2434          sjmp Wait_Release
1186 7F0E      2435   Keypad_Key_Star: mov R7, #14
1188 800C      2436          sjmp Wait_Release
118A 7F00      2437   Keypad_Key_0: mov R7, #0
118C 8008      2438          sjmp Wait_Release
118E 7F0C      2439   Keypad_Key_Hash: mov R7, #12
1190 8004      2440          sjmp Wait_Release
1192 7F0F      2441   Keypad_Key_D: mov R7, #15
1194 8000      2442          sjmp Wait_Release
1196           2443   
1196           2444   Wait_Release:
1196 A2A2      2445       mov C, COL1
1198 82A4      2446       anl C, COL2
119A 82A6      2447       anl C, COL3
119C 82B0      2448       anl C, COL4
119E 50F6      2449       jnc Wait_Release
11A0 D3        2450       setb C
11A1 D292      2451       setb ROW1
11A3 D294      2452       setb ROW2
11A5 D296      2453       setb ROW3
11A7 D2A0      2454       setb ROW4
11A9 22        2455       ret
11AA           2456   
11AA           2457   Wait_25ms:
11AA           2458       ; 1. Check if we are already waiting
11AA 201A0E    2459       jb wait25_active, Check_Timer_Status
11AD           2460       
11AD           2461       ; 2. Check if we just finished
11AD 301B04    2462       jnb wait25_done, Start_New_Timer
11B0           2463       
11B0           2464       ; 3. Timer is DONE! Reset flags and return True
11B0 C21B      2465       clr wait25_done
11B2 D3        2466       setb C          ; Carry = 1 means "Done"
11B3 22        2467       ret
11B4           2468   
11B4           2469   Start_New_Timer:
11B4           2470       ; 4. Start a new 25ms wait
11B4 755700    2471       mov wait25_count, #0
11B7 D21A      2472       setb wait25_active
11B9 C3        2473       clr C           ; Carry = 0 means "Not Done Yet"
11BA 22        2474       ret
11BB           2475   
11BB           2476   Check_Timer_Status:
11BB           2477       ; 5. Still waiting... return False immediately
11BB C3        2478       clr C           ; Carry = 0 means "Not Done Yet"
11BC 22        2479       ret
11BD           2480   
11BD           2481   ; ----------------------------------------------------------------
11BD           2482   ; MODULE: BUFFER INIT (Reset Logic)
11BD           2483   ; ----------------------------------------------------------------
11BD           2484   Init_All_Buffers:
11BD 7880      2485       mov R0, #Buf_Soak_Temp
11BF 1211D2    2486       lcall Init_Temp_Template
11C2 7889      2487       mov R0, #Buf_Refl_Temp
11C4 1211D2    2488       lcall Init_Temp_Template
11C7 7884      2489       mov R0, #Buf_Soak_Time
11C9 1211DE    2490       lcall Init_Time_Template
11CC 788D      2491       mov R0, #Buf_Refl_Time
11CE 1211DE    2492       lcall Init_Time_Template
11D1 22        2493       ret
11D2           2494   
11D2           2495   Init_Temp_Template:
11D2 7630      2496       mov @R0, #'0'
11D4 08        2497       inc R0
11D5 7630      2498       mov @R0, #'0'
11D7 08        2499       inc R0
11D8 7630      2500       mov @R0, #'0'
11DA 08        2501       inc R0
11DB 7600      2502       mov @R0, #0
11DD 22        2503       ret
11DE           2504   
11DE           2505   Init_Time_Template:
11DE 7630      2506       mov @R0, #'0'
11E0 08        2507       inc R0
11E1 7630      2508       mov @R0, #'0'
11E3 08        2509       inc R0
11E4 7630      2510       mov @R0, #'0'
11E6 08        2511       inc R0
11E7 7630      2512       mov @R0, #'0'
11E9 08        2513       inc R0
11EA 7600      2514       mov @R0, #0
11EC 22        2515       ret
11ED           2516   
11ED           2517   Reset_Current_Buffer:
11ED E561      2518       mov A, Current_State
11EF B40106    2519       cjne A, #1, Reset_Chk_2
11F2 7880      2520       mov R0, #Buf_Soak_Temp
11F4 1211D2    2521       lcall Init_Temp_Template
11F7 22        2522       ret
11F8           2523   Reset_Chk_2:
11F8 B40206    2524       cjne A, #2, Reset_Chk_3
11FB 7884      2525       mov R0, #Buf_Soak_Time
11FD 1211DE    2526       lcall Init_Time_Template
1200 22        2527       ret
1201           2528   Reset_Chk_3:
1201 B40306    2529       cjne A, #3, Reset_Chk_4
1204 7889      2530       mov R0, #Buf_Refl_Temp
1206 1211D2    2531       lcall Init_Temp_Template
1209 22        2532       ret
120A           2533   Reset_Chk_4:
120A 788D      2534       mov R0, #Buf_Refl_Time
120C 1211DE    2535       lcall Init_Time_Template
120F 22        2536       ret 
1210           2537       
1210           2538   ; ================================================================
1210           2539   ; MODULE: THERMOCOUPLE ADC DRIVER (WITH NOISE SUPPRESSION & JUMP FIX)
1210           2540   ; ================================================================
1210           2541   Read_Thermocouple:
1210           2542       ; 1. Check Non-Blocking Timer
1210 1211AA    2543       lcall Wait_25ms
1213           2544       
1213           2545       ; [FIX] TRAMPOLINE JUMP
1213           2546       ; "jnc" cannot jump to the end because the code is too long.
1213           2547       ; We invert logic: If Carry=1 (Time is up), Jump NEARBY.
1213 4001      2548       jc Proceed_Reading
1215 22        2549       ret  ; If Carry=0, Return immediately.
1216           2550   
1216           2551   Proceed_Reading:
1216           2552       ; --- 25ms Passed! Time to Read ---
1216           2553   
1216           2554       ; [FIX] SILENCE THE BUZZER (Noise Suppression)
1216           2555       ; Save buzzer state and force it OFF during the sensitive read
1216 E588      2556       mov A, TCON      
1218 5410      2557       anl A, #0x10     ; Isolate TR0 bit
121A C0E0      2558       push acc         ; Save it
121C C28C      2559       clr TR0          ; STOP NOISE
121E           2560   
121E           2561       ; 2. Initialize / Trigger ADC
121E 75A180    2562       mov ADC_C, #0x80    ; Reset
1221 00        2563       nop
1222 00        2564       nop
1223 75A101    2565       mov ADC_C, #0x01    ; Start Channel 0
1226           2566       
1226           2567       ; 3. Settle Delay
1226 7DFA      2568       mov R5, #250
1228           2569   ADC_Settle_Loop:
1228 00        2570       nop
1229 00        2571       nop
122A DDFC      2572       djnz R5, ADC_Settle_Loop
122C           2573       
122C           2574       ; 4. Read Raw Data
122C 85A23A    2575       mov x+0, ADC_L
122F 85A33B    2576       mov x+1, ADC_H
1232 753C00    2577       mov x+2, #0
1235 753D00    2578       mov x+3, #0
1238           2579       
1238           2580       ; 5. Mask Data
1238 E53B      2581       mov a, x+1
123A 540F      2582       anl a, #0x0F
123C F53B      2583       mov x+1, a
123E           2584       
123E           2585       ; [FIX] RESTORE THE BUZZER
123E D0E0      2586       pop acc          ; Get previous state
1240 6002      2587       jz Skip_Restore  ; If it was OFF, keep it OFF
1242 D28C      2588       setb TR0         ; If it was ON, turn it back ON
1244           2589   Skip_Restore:
1244           2590   
1244           2591       ; 6. Math Conversions
1244 753E16    2592            mov y+0, #low (4118 % 0x10000) 
1247 753F10    2592            mov y+1, #high(4118 % 0x10000) 
124A 754000    2592            mov y+2, #low (4118 / 0x10000) 
124D 754100    2592            mov y+3, #high(4118 / 0x10000) 
1250 12018C    2593       lcall mul32       
1253           2594   
1253 75A104    2595       mov ADC_C, #0x04    ; Read LM4040
1256 85A23E    2596       mov y+0, ADC_L      
1259 85A33F    2597       mov y+1, ADC_H      
125C 754000    2598       mov y+2, #0
125F 754100    2599       mov y+3, #0
1262 75A100    2600       mov ADC_C, #0x00    ; Reset
1265           2601       
1265 120280    2602       lcall div32         
1268 753E64    2603            mov y+0, #low (100 % 0x10000) 
126B 753F00    2603            mov y+1, #high(100 % 0x10000) 
126E 754000    2603            mov y+2, #low (100 / 0x10000) 
1271 754100    2603            mov y+3, #high(100 / 0x10000) 
1274 12018C    2604       lcall mul32
1277 753E2B    2605            mov y+0, #low (1323 % 0x10000) 
127A 753F05    2605            mov y+1, #high(1323 % 0x10000) 
127D 754000    2605            mov y+2, #low (1323 / 0x10000) 
1280 754100    2605            mov y+3, #high(1323 / 0x10000)         
1283 120280    2606       lcall div32    
1286 753E14    2607            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
1289 753F00    2607            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
128C 754000    2607            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
128F 754100    2607            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
1292 1200D3    2608       lcall add32     
1295           2609       
1295           2610       ; 8. Store Result
1295 853A47    2611       mov current_temp+0, x+0
1298 853B48    2612       mov current_temp+1, x+1
129B 853C49    2613       mov current_temp+2, x+2
129E 853D4A    2614       mov current_temp+3, x+3
12A1           2615   
12A1 22        2616       ret
12A2           2617       
12A2           2618   ; ================================================================
12A2           2619   ; MODULE: POWER CONTROLLER (The Brain)
12A2           2620   ; ================================================================
12A2           2621   Power_Control:
12A2           2622       ; Default: Turn Heat OFF (Safety)
12A2 755800    2623       mov power_output+0, #0
12A5 755900    2624       mov power_output+1, #0
12A8 755A00    2625       mov power_output+2, #0
12AB 755B00    2626       mov power_output+3, #0
12AE           2627   
12AE E560      2628       mov a, Control_FSM_state
12B0           2629   
12B0           2630       ; --- State 2: RAMP TO SOAK ---
12B0 B40202    2631       cjne a, #2, PC_Check_Soak
12B3           2632       ; Mode: Full Speed Ahead
12B3 8016      2633       sjmp Set_Max_Power
12B5           2634   
12B5           2635   PC_Check_Soak:
12B5           2636       ; --- State 3: SOAK PHASE ---
12B5 B40305    2637       cjne a, #3, PC_Check_Ramp_Reflow
12B8           2638       ; Mode: Maintenance (Low Power)
12B8           2639       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
12B8 20050F    2640       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
12BB 801B      2641       sjmp Set_20_Percent_Power     ; If cold, use 20%
12BD           2642   
12BD           2643   PC_Check_Ramp_Reflow:
12BD           2644       ; --- State 4: RAMP TO REFLOW ---
12BD B40402    2645       cjne a, #4, PC_Check_Reflow
12C0           2646       ; Mode: Full Speed Ahead
12C0 8009      2647       sjmp Set_Max_Power
12C2           2648   
12C2           2649   PC_Check_Reflow:
12C2           2650       ; --- State 5: REFLOW PHASE ---
12C2 B40505    2651       cjne a, #5, PC_Done
12C5           2652       ; Mode: Maintenance (Low Power)
12C5 200602    2653       jb reflow_temp_reached, PC_Done
12C8 800E      2654       sjmp Set_20_Percent_Power
12CA           2655   
12CA           2656   PC_Done:
12CA 22        2657       ret
12CB           2658   
12CB           2659   ; --- Power Helpers ---
12CB           2660   
12CB           2661   Set_Max_Power:
12CB           2662       ; Load 1500 (0x05DC) = 100% Duty Cycle
12CB 7558DC    2663       mov power_output+0, #0xDC
12CE 755905    2664       mov power_output+1, #0x05
12D1 755A00    2665       mov power_output+2, #0
12D4 755B00    2666       mov power_output+3, #0
12D7 22        2667       ret
12D8           2668   
12D8           2669   Set_20_Percent_Power:
12D8           2670       ; Load 300 (0x012C) = 20% Duty Cycle
12D8 75582C    2671       mov power_output+0, #0x2C
12DB 755901    2672       mov power_output+1, #0x01
12DE 755A00    2673       mov power_output+2, #0
12E1 755B00    2674       mov power_output+3, #0
12E4 22        2675       ret
12E5           2676   
12E5           2677   ;--------------------------------------------------------------
12E5           2678   ; set servo angle according to the state
12E5           2679   ; call servo control function every 1ms
12E5           2680   ;--------------------------------------------------------------
12E5           2681   call_servo_control:
12E5           2682            ; check current state and change servo angle
12E5 E560      2683            mov a, Control_FSM_state
12E7           2684            
12E7           2685            ; handle state 0
12E7 B40004    2686            cjne a, #0, servo_state1
12EA C227      2687            clr servo_angle_zero ; close door at state 0
12EC 802C      2688            sjmp check_servo_flag
12EE           2689   
12EE           2690            ; handle state 1
12EE           2691            servo_state1:
12EE B40104    2692            cjne a, #1, servo_state2
12F1 D227      2693            setb servo_angle_zero ; open door at state 1
12F3 8025      2694            sjmp check_servo_flag
12F5           2695   
12F5           2696            ; handle state 2
12F5           2697            servo_state2:
12F5 B40204    2698            cjne a, #2, servo_state3
12F8 C227      2699            clr servo_angle_zero ; close door at state 2
12FA 801E      2700            sjmp check_servo_flag
12FC           2701   
12FC           2702            ; handle state 3
12FC           2703            servo_state3:
12FC B40304    2704            cjne a, #3, servo_state4
12FF C227      2705            clr servo_angle_zero ; close door at state 3
1301 8017      2706            sjmp check_servo_flag
1303           2707   
1303           2708            ; handle state 4
1303           2709            servo_state4:
1303 B40404    2710            cjne a, #4, servo_state5
1306 C227      2711            clr servo_angle_zero ; close door at state 4
1308 8010      2712            sjmp check_servo_flag
130A           2713   
130A           2714            ; handle state 5
130A           2715            servo_state5:
130A B40504    2716            cjne a, #5, servo_state6
130D C227      2717            clr servo_angle_zero ; close door at state 5
130F 8009      2718            sjmp check_servo_flag
1311           2719   
1311           2720            ; handle state 6
1311           2721            servo_state6:
1311 B40604    2722            cjne a, #6, servo_state7
1314 C227      2723            clr servo_angle_zero ; close door at state 6
1316 8002      2724            sjmp check_servo_flag
1318           2725   
1318           2726            ; handle state 7
1318           2727            servo_state7:
1318 D227      2728            setb servo_angle_zero ; open door at state 7
131A           2729   
131A           2730   check_servo_flag:
131A           2731            ; check 1 ms flag
131A 102601    2732            jbc one_millisecond_flag_servo, run_servo_control
131D 22        2733            ret
131E           2734   
131E           2735   run_servo_control:
131E 121322    2736            lcall servo_control
1321 22        2737            ret
1322           2738   
1322           2739   
1322           2740   ;---------------------------------------------------------------
1322           2741   ; servo control
1322           2742   ; generate a 20 ms period pwm signal to control the servo motor
1322           2743   ; able to make the servo motor stay at 0 degree and 180 degree
1322           2744   ;---------------------------------------------------------------
1322           2745   servo_control:
1322 D2ED      2746       setb LEDRA.5
1324 C0E0      2747            push acc
1326 C0D0      2748            push psw
1328 E579      2749            mov a, servo_pwm_counter ; move servo counter to accumulator
132A 04        2750            inc A ; a += 1
132B B41402    2751            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
132E 7400      2752            mov a, #0
1330           2753   
1330           2754   servo_pwm_angle_compare: ; read target angle
1330 F579      2755            mov servo_pwm_counter, A
1332 202709    2756            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
1335           2757            ; set servo motor to 180 degrees
1335 E579      2758            mov a, servo_pwm_counter
1337 C3        2759            clr c
1338 9402      2760            subb a, #SERVO_180
133A 400B      2761            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
133C 800D      2762            sjmp servo_pwm_set_low ; set low if greater
133E           2763   
133E           2764   set_zero_degree:
133E           2765            ; set servo motor to 0 degree
133E E579      2766            mov a, servo_pwm_counter
1340 C3        2767            clr c
1341 9401      2768            subb a, #SERVO_0
1343 4002      2769            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
1345 8004      2770            sjmp servo_pwm_set_low ; set low if greater
1347           2771   
1347           2772   servo_pwm_set_high:
1347           2773            ; set pwm pin high
1347 D2B6      2774            setb SERVO_OUT
1349 8002      2775            sjmp servo_control_done
134B           2776   
134B           2777   servo_pwm_set_low:
134B           2778            ; set pwm pin low
134B C2B6      2779            clr SERVO_OUT
134D           2780   
134D           2781   servo_control_done:
134D D0D0      2782            pop psw
134F D0E0      2783            pop acc
1351 22        2784            ret
1352           2785   
1352           2786   ;-------------------------------------------------------------------------------
1352           2787   ; power_control
1352           2788   ;-------------------------------------------------------------------------------
1352           2789   ; Determine the power output based on current state and current temperature 
1352           2790   ; input parameter: Control_FSM_state
1352           2791   ;-------------------------------------------------------------------------------
1352           2792   
1352           2793   proportional_power_control:
1352 E560      2794            mov a, Control_FSM_state
1354           2795   
1354           2796   state0_power_control:
1354           2797            ; idle
1354           2798            ; 0% power
1354 B4000F    2799            cjne a, #0, state1_power_control
1357 755800    2800            mov power_output, #low(NO_POWER)
135A 755900    2801            mov power_output+1, #low(NO_POWER)
135D 755A00    2802            mov power_output+2, #0
1360 755B00    2803            mov power_output+3, #0
1363 0214FE    2804            ljmp power_control_done
1366           2805   
1366           2806   state1_power_control:
1366           2807            ; idle
1366           2808            ; 0% power
1366 B4010F    2809            cjne a, #1, state2_power_control
1369 755800    2810            mov power_output, #low(NO_POWER)
136C 755900    2811            mov power_output+1, #low(NO_POWER)
136F 755A00    2812            mov power_output+2, #0
1372 755B00    2813            mov power_output+3, #0
1375 0214FE    2814            ljmp power_control_done
1378           2815            
1378           2816   state2_power_control:
1378           2817            ; ramp to soak, ramp to ~150C
1378           2818            ; 100% power
1378 B4020F    2819            cjne a, #2, state3_power_control
137B 7558DC    2820            mov power_output, #low(MAX_POWER)
137E 755905    2821            mov power_output+1, #high(MAX_POWER)
1381 755A00    2822            mov power_output+2, #0
1384 755B00    2823            mov power_output+3, #0
1387 0214FE    2824            ljmp power_control_done
138A           2825   
138A           2826   state3_power_control:
138A           2827            ; soak period, hold at 150C
138A           2828            ; 20% base power + proportional calculated power
138A B40302    2829            cjne a, #3, jump_state4_power_control
138D 8003      2830            sjmp state3_power_control_calculation
138F           2831   
138F           2832   jump_state4_power_control:
138F 0214BC    2833            ljmp state4_power_control
1392           2834   
1392           2835   state3_power_control_calculation:
1392           2836            ; move soak_temp to x
1392 854B3A    2837            mov x, soak_temp
1395 854C3B    2838            mov x+1, soak_temp+1
1398 854D3C    2839            mov x+2, soak_temp+2
139B 854E3D    2840            mov x+3, soak_temp+3
139E           2841            ; move current_temp to y
139E 85473E    2842            mov y, current_temp
13A1 85483F    2843            mov y+1, current_temp+1
13A4 854940    2844            mov y+2, current_temp+2
13A7 854A41    2845            mov y+3, current_temp+3
13AA           2846   
13AA           2847            ; compare between soak_temp and current_temp
13AA C200      2848            clr mf
13AC 120178    2849            lcall x_gteq_y
13AF 10002B    2850            jbc mf, st_sub_ct
13B2           2851            ; current_temp - soak_temp if st < ct
13B2 C228      2852            clr soak_temp_greater
13B4           2853            ; move current_temp to y
13B4 854B3E    2854            mov y, soak_temp
13B7 854C3F    2855            mov y+1, soak_temp+1
13BA 854D40    2856            mov y+2, soak_temp+2
13BD 854E41    2857            mov y+3, soak_temp+3
13C0           2858            ; move current_temp to x
13C0 85473A    2859            mov x, current_temp
13C3 85483B    2860            mov x+1, current_temp+1
13C6 85493C    2861            mov x+2, current_temp+2
13C9 854A3D    2862            mov x+3, current_temp+3
13CC 1200F6    2863            lcall sub32
13CF 853A62    2864            mov soak_temp_diff, x
13D2 853B63    2865            mov soak_temp_diff+1, x+1
13D5 853C64    2866            mov soak_temp_diff+2, x+2
13D8 853D65    2867            mov soak_temp_diff+3, x+3
13DB 8011      2868            sjmp proportional_input_soak
13DD           2869   
13DD           2870   st_sub_ct:
13DD           2871            ; soak_temp - current_temp
13DD D228      2872            setb soak_temp_greater
13DF 1200F6    2873            lcall sub32
13E2 853A62    2874            mov soak_temp_diff, x
13E5 853B63    2875            mov soak_temp_diff+1, x+1
13E8 853C64    2876            mov soak_temp_diff+2, x+2
13EB 853D65    2877            mov soak_temp_diff+3, x+3
13EE           2878   
13EE           2879   proportional_input_soak:
13EE           2880            ; proportaional block calculation       
13EE           2881            ; move soak_temp_diff to x
13EE 85623A    2882            mov x, soak_temp_diff
13F1 85633B    2883            mov x+1, soak_temp_diff+1
13F4 85643C    2884            mov x+2, soak_temp_diff+2
13F7 85653D    2885            mov x+3, soak_temp_diff+3
13FA           2886            ; move proportional gain to y
13FA 753E05    2887            mov y+0, #low (KP % 0x10000) 
13FD 753F00    2887            mov y+1, #high(KP % 0x10000) 
1400 754000    2887            mov y+2, #low (KP / 0x10000) 
1403 754100    2887            mov y+3, #high(KP / 0x10000) 
1406 12018C    2888            lcall mul32 ; proportional_output = proportional_gain * difference
1409           2889            
1409 853A66    2890            mov proportional_gain_var, x
140C 853B67    2891            mov proportional_gain_var+1, x+1
140F 853C68    2892            mov proportional_gain_var+2, x+2
1412 853D69    2893            mov proportional_gain_var+3, x+3
1415           2894   
1415           2895            ; base_power + soak_power when soak_temp > current_temp
1415 302829    2896            jnb soak_temp_greater, sub_proportional_soak
1418 85663A    2897            mov x, proportional_gain_var
141B 85673B    2898            mov x+1, proportional_gain_var+1
141E 85683C    2899            mov x+2, proportional_gain_var+2
1421 85693D    2900            mov x+3, proportional_gain_var+3
1424 753E2C    2901            mov y+0, #low (BASE_POWER % 0x10000) 
1427 753F01    2901            mov y+1, #high(BASE_POWER % 0x10000) 
142A 754000    2901            mov y+2, #low (BASE_POWER / 0x10000) 
142D 754100    2901            mov y+3, #high(BASE_POWER / 0x10000) 
1430 1200D3    2902            lcall add32
1433           2903            ; x now holds the power output before the saturator
1433 853A66    2904            mov proportional_gain_var, x
1436 853B67    2905            mov proportional_gain_var+1, x+1
1439 853C68    2906            mov proportional_gain_var+2, x+2
143C 853D69    2907            mov proportional_gain_var+3, x+3
143F 803D      2908            sjmp saturator_soak
1441           2909   
1441           2910   sub_proportional_soak:
1441           2911            ; base_power - soak_power when soak_temp <= current_temp
1441 753A2C    2912            mov x+0, #low (BASE_POWER % 0x10000) 
1444 753B01    2912            mov x+1, #high(BASE_POWER % 0x10000) 
1447 753C00    2912            mov x+2, #low (BASE_POWER / 0x10000) 
144A 753D00    2912            mov x+3, #high(BASE_POWER / 0x10000) 
144D 85663E    2913            mov y, proportional_gain_var
1450 85673F    2914            mov y+1, proportional_gain_var+1
1453 856840    2915            mov y+2, proportional_gain_var+2
1456 856941    2916            mov y+3, proportional_gain_var+3
1459           2917   
1459           2918            ; compare whether base_power < proportional_gain_var
1459 C200      2919            clr mf
145B 12011A    2920            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
145E 30000E    2921            jnb mf, bp_gteq_pgv
1461 756600    2922            mov proportional_gain_var, #low(NO_POWER)
1464 756700    2923            mov proportional_gain_var+1, #high(NO_POWER)
1467 756800    2924            mov proportional_gain_var+2, #0
146A 756900    2925            mov proportional_gain_var+3, #0
146D 800F      2926            sjmp saturator_soak
146F           2927   
146F           2928   bp_gteq_pgv:
146F           2929            ; calculate subtracted gain
146F 1200F6    2930            lcall sub32
1472           2931            ; x now holds the power output before the saturator
1472 853A66    2932            mov proportional_gain_var, x
1475 853B67    2933            mov proportional_gain_var+1, x+1
1478 853C68    2934            mov proportional_gain_var+2, x+2
147B 853D69    2935            mov proportional_gain_var+3, x+3
147E           2936   
147E           2937   saturator_soak:
147E           2938            ; proportional_gain_var now holds the power output before the saturator
147E           2939            ; saturate power output to max power
147E 85663A    2940            mov x, proportional_gain_var
1481 85673B    2941            mov x+1, proportional_gain_var+1
1484 85683C    2942            mov x+2, proportional_gain_var+2
1487 85693D    2943            mov x+3, proportional_gain_var+3
148A           2944   
148A 753EDC    2945            mov y+0, #low (MAX_POWER % 0x10000) 
148D 753F05    2945            mov y+1, #high(MAX_POWER % 0x10000) 
1490 754000    2945            mov y+2, #low (MAX_POWER / 0x10000) 
1493 754100    2945            mov y+3, #high(MAX_POWER / 0x10000) 
1496           2946   
1496 C200      2947            clr mf
1498 120136    2948            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
149B 20000F    2949            jb mf, saturated_soak
149E           2950            ; set power_output to calculated power if not saturated
149E 856658    2951            mov power_output, proportional_gain_var
14A1 856759    2952            mov power_output+1, proportional_gain_var+1
14A4 85685A    2953            mov power_output+2, proportional_gain_var+2
14A7 85695B    2954            mov power_output+3, proportional_gain_var+3
14AA 0214FE    2955            ljmp power_control_done
14AD           2956   
14AD           2957   saturated_soak:
14AD 7558DC    2958            mov power_output, #low(MAX_POWER)
14B0 755905    2959            mov power_output+1, #high(MAX_POWER)
14B3 755A00    2960            mov power_output+2, #0
14B6 755B00    2961            mov power_output+3, #0
14B9 0214FE    2962            ljmp power_control_done
14BC           2963   
14BC           2964   
14BC           2965   state4_power_control:
14BC           2966            ; ramp to reflow, max power
14BC B4040F    2967            cjne a, #4, state5_power_control
14BF 7558DC    2968            mov power_output, #low(MAX_POWER)
14C2 755905    2969            mov power_output+1, #high(MAX_POWER)
14C5 755A00    2970            mov power_output+2, #0
14C8 755B00    2971            mov power_output+3, #0
14CB 0214FE    2972            ljmp power_control_done
14CE           2973   
14CE           2974   state5_power_control:
14CE           2975            ; reflow 20% base power
14CE B4050F    2976            cjne a, #5, state6_power_control
14D1 75582C    2977            mov power_output, #low(BASE_POWER)  
14D4 755901    2978            mov power_output+1, #high(BASE_POWER)
14D7 755A00    2979            mov power_output+2, #0
14DA 755B00    2980            mov power_output+3, #0
14DD 0214FE    2981            ljmp power_control_done
14E0           2982   
14E0           2983   state6_power_control:
14E0           2984            ; cooling 0% power
14E0 B4060F    2985            cjne a, #6, state_7_power_control
14E3 755800    2986            mov power_output, #low(NO_POWER)
14E6 755900    2987            mov power_output+1, #high(NO_POWER)
14E9 755A00    2988            mov power_output+2, #0
14EC 755B00    2989            mov power_output+3, #0
14EF 0214FE    2990            ljmp power_control_done
14F2           2991   
14F2           2992   state_7_power_control:
14F2           2993            ; idle 0% power
14F2 755800    2994            mov power_output, #low(NO_POWER)
14F5 755900    2995            mov power_output+1, #high(NO_POWER)
14F8 755A00    2996            mov power_output+2, #0
14FB 755B00    2997            mov power_output+3, #0
14FE           2998   
14FE           2999   power_control_done:
14FE 22        3000            ret
14FF           3001   
14FF           3002   ;-------------------------------------------------------------------------------;
14FF           3003   ;         Main program.          
14FF           3004   ;-------------------------------------------------------------------------------;
14FF           3005   main:
14FF           3006   
14FF           3007       ; --------------------------------------------------------
14FF           3008       ; 1. SAFETY SHUTDOWN
14FF           3009       ; --------------------------------------------------------
14FF C2AF      3010       clr EA              ; FORCE Interrupts OFF immediately
1501 7581C0    3011       mov SP, #0xC0       ; Reset Stack Pointer to safe location
1504           3012       
1504           3013       ; --------------------------------------------------------
1504           3014       ; THE "DIRTY DELAY" (Fixes Reset Garbage)
1504           3015       ; We burn ~100ms here using a raw loop. 
1504           3016       ; We cannot use timers yet because they aren't initialized.
1504           3017       ; --------------------------------------------------------
1504 78FA      3018       mov R0, #250
1506           3019   Reset_Delay_Outer:
1506 79FF      3020       mov R1, #255
1508           3021   Reset_Delay_Inner:
1508 D9FE      3022       djnz R1, Reset_Delay_Inner
150A D8FA      3023       djnz R0, Reset_Delay_Outer
150C           3024       
150C           3025       ; --- PORT CONFIGURATION ---
150C 759AAA    3026       mov P0MOD, #0xAA
150F           3027       ; P1: Mixed usage 
150F           3028       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
150F           3029       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
150F           3030       ; P1.0 (Unused/RX) -> Input
150F           3031       ; Binary: 11111110 -> Hex: 0xFE
150F 759BFE    3032       mov P1MOD, #0xFE
1512           3033   
1512           3034       ; P2: Row4(Out), Cols(In)
1512           3035       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
1512           3036       ; Binary: 00000001 -> Hex: 0x01
1512 759C01    3037       mov P2MOD, #0x01
1515           3038   
1515           3039       ; P3: Col4(In)
1515           3040       ; P3.0 (Col4) is In (0).
1515 759D00    3041       mov P3MOD, #0x00
1518           3042       ; Turn off all the LEDs
1518 75E800    3043       mov LEDRA, #0 ; LEDRA is bit addressable
151B 759500    3044       mov LEDRB, #0 ; LEDRB is NOT bit addresable
151E           3045   
151E           3046       ; Enable Global interrupts
151E D2AF      3047       setb EA  
1520           3048   
1520           3049            ; FSM initial states
1520 757000    3050            mov SEC_FSM_state, #0
1523 756000    3051            mov Control_FSM_state, #0
1526 756100    3052            mov Current_State, #0
1529           3053            ; FSM timers initialization
1529 756F00    3054            mov SEC_FSM_timer, #0
152C           3055            ; time counters initialization
152C 753000    3056            mov current_time_sec, #0
152F 753100    3057            mov current_time_minute, #0
1532 753200    3058            mov soak_time_sec, #0
1535 753300    3059            mov soak_time_minute, #0
1538 753400    3060            mov reflow_time_sec, #0
153B 753500    3061            mov reflow_time_minute, #0
153E 753600    3062            mov soak_end_time_sec, #0
1541 753700    3063            mov soak_end_time_minute, #0
1544 753800    3064            mov reflow_end_time_sec, #0
1547 753900    3065            mov reflow_end_time_minute, #0
154A           3066       ; Initialize counter to zero
154A 755C00    3067       mov pwm_counter, #0
154D 755D00    3068       mov pwm_counter+1, #0
1550 755E00    3069       mov pwm_counter+2, #0
1553 755F00    3070       mov pwm_counter+3, #0
1556           3071       ; Initialize power output
1556 755B00    3072       mov power_output+3, #0
1559 755A00    3073       mov power_output+2, #0
155C 755902    3074       mov power_output+1, #02H
155F 7558EE    3075       mov power_output, #0EEH ; (initilize to 750 for testing)
1562           3076            ; FSM Buttons push button init
1562 757200    3077            mov     PB0_DEB_state, #0
1565 757400    3078            mov     PB2_DEB_state, #0
1568 757100    3079            mov     PB0_DEB_timer, #0
156B 757300    3080            mov     PB2_DEB_timer, #0
156E           3081       ; [FIX] ADD THIS BLOCK TO STOP STARTUP BEEP
156E 757600    3082       mov beep_state, #0
1571 757500    3083       mov beep_count, #0
1574 757700    3084       mov beep_tmr, #0
1577 757800    3085       mov beep_tmr+1, #0
157A           3086       ; Buttons 
157A 757A00    3087       mov BTN_DEB_state, #0
157D 757B00    3088       mov BTN_DEB_timer, #0
1580 757C00    3089       mov BTN_DEB_id, #0
1583 757900    3090       mov servo_pwm_counter, #0
1586 757D00    3091       mov rx_idx, #0
1589 757E00    3092       mov rx_ready, #0
158C C218      3093       clr one_ms_beep_flag
158E C28C      3094       clr TR0 ; Force buzzer hardware OFF
1590           3095   
1590           3096            ; Clear all the flags
1590 C295      3097            clr SOUND_OUT
1592 C219      3098       clr beep_error_done
1594 C213      3099            clr tc_missing_abort
1596 C20B      3100            clr stop_signal
1598 C215      3101            clr PB0_flag
159A C216      3102            clr PB1_flag
159C C217      3103            clr PB2_flag
159E C201      3104            clr one_second_flag
15A0 C204      3105            clr one_second_lcd_flag
15A2 C20E      3106            clr config_finish_signal
15A4 C20D      3107       clr time_count_doing_signal
15A6 C224      3108       clr fullscreen_update_signal
15A8 C205      3109            clr soak_temp_reached
15AA C208      3110            clr soak_time_reached
15AC C206      3111            clr reflow_temp_reached
15AE C209      3112            clr reflow_time_reached
15B0 C207      3113            clr cooling_temp_reached
15B2 C210      3114       clr state_change_signal_TC
15B4 C211      3115            clr state_change_signal_Count
15B6 C212      3116       clr state_change_beep_signal
15B8 C226      3117       clr one_millisecond_flag_servo
15BA C229      3118       clr remote_config_mode
15BC           3119       ; Set bit
15BC D20F      3120            setb state_change_signal
15BE D214      3121       setb tc_startup_window
15C0           3122   
15C0 12045D    3123       lcall Timer0_Init
15C3 1206A6    3124       lcall Timer2_Init
15C6 120779    3125       lcall ELCD_4BIT
15C9           3126       ;----- Two new lines I added to initialize the UI
15C9 1211BD    3127       lcall Init_All_Buffers
15CC 120477    3128       lcall Initialize_Serial_Port
15CF           3129   ;-------------------------------------------------------------------------------;
15CF           3130   ; while(1) loop
15CF           3131   ;-------------------------------------------------------------------------------;
15CF           3132   loop:
15CF           3133   
15CF 120BC4    3134            lcall SEC_FSM
15D2           3135   
15D2           3136            ; Check the FSM for the overall control flow of the reflow process
15D2 120E73    3137       lcall Control_FSM
15D5           3138   
15D5           3139       ; Check the FSM for PB01 debounce
15D5 120B56    3140       lcall PB0_DEB
15D8 120B8E    3141            lcall PB2_DEB
15DB           3142       
15DB           3143       ; Added to take temp readings
15DB 121210    3144       lcall Read_Thermocouple
15DE           3145       
15DE           3146       ; 1. Check if we reached temp (Observer)
15DE 120CAF    3147       lcall Temp_Compare
15E1           3148       
15E1           3149       ; 2. Decide heater power based on flags (Driver)
15E1           3150       ;lcall Power_Control
15E1 121352    3151       lcall proportional_power_control
15E4           3152       
15E4 120DA0    3153       lcall Safety_Check_TC
15E7           3154   
15E7 120C20    3155            lcall Time_Counter
15EA           3156   
15EA           3157            ; Update Variables (times and temp)
15EA 120F4E    3158            lcall Update_FSM_Variables
15ED           3159   
15ED           3160       ; GUI Interface polling uart port
15ED 1204AC    3161       lcall Serial_RX_Pump
15F0 120505    3162       lcall Serial_Process_Line
15F3           3163   
15F3           3164            ; Update while at state 1
15F3           3165            ; LCD
15F3 120A02    3166            lcall Update_Screen_Full 
15F6           3167            ; Buttons
15F6 120FD2    3168            lcall Check_Buttons 
15F9           3169            ; PB0pad
15F9 121091    3170       lcall Check_Keypad
15FC           3171   
15FC           3172       ; Update the LCD display based on the current state
15FC 12083E    3173       lcall LCD_Display_Update_func
15FF           3174   
15FF 120C42    3175            lcall Time_Compare_MMSS
1602           3176   
1602           3177       ; Update the pwm output for the ssr
1602 120D29    3178       lcall PWM_Wave 
1605           3179            ; Update the Buzzer 
1605 120E3A    3180            lcall Beep_Task
1608           3181       ; Update the pwm output for the servo
1608 1212E5    3182       lcall call_servo_control
160B           3183   
160B 120DF1    3184       lcall Beep_Judge
160E           3185   
160E           3186       ; After initialization the program stays in this 'forever' loop
160E 0215CF    3187       ljmp loop
1611           3188   ;-------------------------------------------------------------------------------;
1611           3189   EN
>>>>>>> main
