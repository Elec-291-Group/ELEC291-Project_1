0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 021742       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 02048E      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 0206DC      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   ; time buffer 
0030             38   current_time_sec:     ds 1
0031             39   current_time_minute:  ds 1
0032             40   soak_time_sec:        ds 1
0033             41   soak_time_minute:     ds 1
0034             42   reflow_time_sec:      ds 1
0035             43   reflow_time_minute:   ds 1
0036             44   soak_end_time_sec:      ds 1
0037             45   soak_end_time_minute:   ds 1
0038             46   reflow_end_time_sec:    ds 1
0039             47   reflow_end_time_minute: ds 1
003A             48   
003A             49   ; math32 buffer variables
003A             50   x:      ds  4
003E             51   y:      ds  4
0042             52   bcd:    ds  5
0047             53   
0047             54   current_temp: ds 4 ;
004B             55   soak_temp:    ds 4 ;
004F             56   reflow_temp:  ds 4 ;
0053             57   
0053             58   wait25_btn_cnt:    ds 1
0054             59   wait25_keypad_cnt: ds 1
0055             60   wait25_adc_cnt:    ds 1
0056             61   wait25_lcd_cnt:    ds 1
0057             62   wait25_count:      ds 1
0058             63   
0058             64   power_output:  ds 4 ;
005C             65   pwm_counter:   ds 4 ; counter for pwm (0-1500_timer: ds 1
0060             66   
0060             67   Control_FSM_state: ds 1 
0061             68   Current_State:     ds 1
0062             69   
0062             70   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
0066             71   proportional_gain_var: ds 4 ; power gain calculated from the proportional block
006A             72   
006A             73   ;-- UI buffers I added (ayaan)
006A             74   Cursor_Idx: ds 1
006B             75   
006B             76   ; Buzzer module variables
006B             77   buzz_state:      ds 1   ; 0=IDLE, 1=ON, 2=OFF
006C             78   buzz_timer:      ds 1   ; counts ms within ON/OFF window
006D             79   buzz_beeps_left: ds 1   ; how many beeps remaining
006E             80   buzz_priority:   ds 1   ; 0 none, 1=state, 2=done, 3=error
006F             81   
006F             82   SEC_FSM_timer: ds 1
0070             83   SEC_FSM_state: ds 1
0071             84   ; Push buttons for globel interrupt 
0071             85   PB0_DEB_timer:  ds 1
0072             86   PB0_DEB_state:  ds 1
0073             87   PB2_DEB_timer:  ds 1
0074             88   PB2_DEB_state:  ds 1
0075             89   
0075             90   ; Buzzer state
0075             91   beep_count:  ds 1      ; remaining beeps
0076             92   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
0077             93   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
0079             94   
0079             95   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
007A             96   ; In your data section
007A             97   BTN_DEB_state: ds 1
007B             98   BTN_DEB_timer: ds 1
007C             99   BTN_DEB_id:    ds 1
007D            100   
007D            101   ; UART RX state (polling)
007D            102   rx_idx:    ds 1
007E            103   rx_ready:  ds 1
007F            104   ; 79
007F            105   
0080            106   iseg at 0x80
0080            107   Buf_Soak_Temp: ds 4   
0084            108   Buf_Soak_Time: ds 5   
0089            109   Buf_Refl_Temp: ds 4   
008D            110   Buf_Refl_Time: ds 5
0092            111   
0092            112   ; UART RX line buffer (polling) in upper RAM
0092            113   rx_buf:        ds 40    ; null-terminated command line
00BA            114   ; 
00BA            115   ;-------------------------------------------------------------------------------
00BA            116   ; bit operation setb, clr, jb, and jnb
0000            117   bseg
0000            118   mf:     dbit 1 ; math32 sign
0001            119   one_second_flag: dbit 1
0002            120   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003            121   one_ms_buzz_flag: dbit 1 ; one_millisecond_flag for buzz
0004            122   one_second_lcd_flag: dbit 1
0005            123   
0005            124   soak_temp_reached: dbit 1
0006            125   reflow_temp_reached: dbit 1
0007            126   cooling_temp_reached: dbit 1
0008            127   
0008            128   soak_time_reached: dbit 1
0009            129   reflow_time_reached: dbit 1
000A            130   
000A            131   reset_signal: dbit 1
000B            132   stop_signal: dbit 1
000C            133   start_signal_count: dbit 1
000D            134   time_count_doing_signal: dbit 1
000E            135   config_finish_signal: dbit 1
000F            136   
000F            137   state_change_signal: dbit 1
0010            138   state_change_signal_TC: dbit 1
0011            139   state_change_signal_Count: dbit 1
0012            140   state_change_beep_signal: dbit 1
0013            141   
0013            142   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
0014            143   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0015            144   
0015            145   PB0_flag: dbit 1 ; start entire program
0016            146   PB1_flag: dbit 1 ; start soak
0017            147   PB2_flag: dbit 1 ; pause process
0018            148   
0018            149   ;buzzer beep
0018            150   one_ms_beep_flag: dbit 1
0019            151   beep_error_done: dbit 1
001A            152   
001A            153   ; BSEG (Bit Segment)
001A            154   wait25_active: dbit 1 ; 1 = We are currently waiting
001B            155   wait25_done:   dbit 1 ; 1 = The 25ms has finished
001C            156   wait25_btn_active:    dbit 1
001D            157   wait25_btn_done:      dbit 1
001E            158   wait25_keypad_active: dbit 1
001F            159   wait25_keypad_done:   dbit 1
0020            160   wait25_adc_active:    dbit 1
0021            161   wait25_adc_done:      dbit 1
0022            162   wait25_lcd_active:    dbit 1
0023            163   wait25_lcd_done:      dbit 1
0024            164   
0024            165   fullscreen_update_signal: dbit 1
0025            166   
0025            167   one_second_flag_test: dbit 1
0026            168   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
0027            169   
0027            170   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0028            171   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0029            172   
0029            173   remote_config_mode: dbit 1
002A            174   ; 40 bits used
002A            175   
002A            176   ;-------------------------------------------------------------------------------
0320            177   cseg
0320            178   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            179   BAUD           EQU 57600
0320            180   
0320            181   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            182   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            183   ; is always 12 unlike the N76E003 where is selectable.
0320            184   
0320            185   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            186   
0320            187   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            188   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            189   
0320            190   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            191   
0320            192   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            193   BEEP_ON_MS          EQU 100  ; 100ms
0320            194   BEEP_OFF_MS    EQU 100  ; 100ms
0320            195   
0320            196   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            197   
0320            198   ; These 'equ' must match the wiring between the DE10Lite board and the LCD
0320            199   ; P0 is in connector JPIO.
0320            200   ;Added correct I/O definitions
0320            201   ;-- LCD Pins ---
0320            202   ELCD_RS equ P1.7
0320            203   ELCD_E  equ P1.1
0320            204   ELCD_D4 equ P0.7
0320            205   ELCD_D5 equ P0.5
0320            206   ELCD_D6 equ P0.3
0320            207   ELCD_D7 equ P0.1
0320            208   
0320            209   ; -- Buttons --
0320            210   BTN_SOAK_TEMP equ P0.0
0320            211   BTN_SOAK_TIME equ P0.2
0320            212   BTN_REFL_TEMP equ P0.4
0320            213   BTN_REFL_TIME equ P0.6
0320            214   PB0                equ P1.0
0320            215   PB2                equ P3.7
0320            216   
0320            217   ; --- PB0PAD ---
0320            218   ROW1 equ P1.2
0320            219   ROW2 equ P1.4
0320            220   ROW3 equ P1.6
0320            221   ROW4 equ P2.0
0320            222   COL1 equ P2.2
0320            223   COL2 equ P2.4
0320            224   COL3 equ P2.6
0320            225   COL4 equ P3.0
0320            226   
0320            227   DC_OUT         EQU P4.0
0320            228   SERVO_OUT      EQU p3.6 ; servo pin
0320            229   LED_LEFT       EQU P3.4 ; left LED (PB3.4)
0320            230   LED_MID        EQU P3.3 ; middle LED (PB3.3)
0320            231   LED_RIGHT      EQU P3.2 ; right LED (PB3.2)
0320            232   
0320            233   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            234   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            235   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            236   
0320            237   COLD_JUNCTION_TEMP equ 20
0320            238   MAX_POWER           EQU 1500 ; max oven power
0320            239   NO_POWER            EQU 0    ; no power
0320            240   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
0320            241   HALF_POWER     EQU (MAX_POWER/2) ; 50% power indicator
0320            242   KP                          EQU 5 ; proportional gain
0320            243   
0320            244   ;1234567890123456 <-- 16 characters per line LCD
0320 696E6974   245   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   246   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   247   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            248   
0350            249   ; --- UI STRINGS (REQUIRED FOR PB0PAD LOGIC), <- I can fix if duplicates
0350 53656C65   250   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   251   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   252   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   253   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   254   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            255   
03A5            256   ; 1234567890123456
03A5 53657420   257   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   258   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   259   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   260   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   261   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            262   
03E5 54656D70   263   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            264   
03EC            265   ; 1234567890123456
03EC 52616D70   266   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   267   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   268   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   269   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   270   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   271   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C 42696E67   272   String_boot_Line1: db'Bing Bing Bing ', 0
     2042696E
     67204269
     6E672000
045C 57656C63   273   String_boot_Line2: db'Welcome to Use ', 0
     6F6D6520
     746F2055
     73652000
046C            274   
046C 20202020   275   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
047D            276   
047D            277   ;-------------------------------------------------------------------------------
047D            278   ; Timers Setting:
047D            279   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
047D            280   ;   Timer 1: Serial port baud rate 57600 generator
047D            281   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
047D            282   ;-------------------------------------------------------------------------------
047D            283   ; Routine to initialize the ISR for Timer 0 ;
047D            284   Timer0_Init:
047D E589       285       mov a, TMOD
047F 54F0       286       anl a, #0xf0 ; Clear the bits for timer 0
0481 4401       287       orl a, #0x01 ; Configure timer 0 as 16-timer
0483 F589       288       mov TMOD, a
0485 758CFD     289       mov TH0, #high(TIMER0_RELOAD)
0488 758A5A     290       mov TL0, #low(TIMER0_RELOAD)
048B            291       ; Enable the timer and interrupts
048B D2A9       292       setb ET0  ; Enable timer 0 interrupt
048D            293       ; setb TR0  (no need to open at first)
048D 22         294       ret
048E            295   ; ISR for timer 0.  Set to execute every 1/4096Hz 
048E            296   ; to generate a 2048 Hz square wave at pin P1.5 
048E            297   Timer0_ISR:
048E            298       ;clr TF0  ; According to the data sheet this is done for us already.
048E 758CFD     299       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0491 758A5A     300       mov TL0, #low(TIMER0_RELOAD)
0494 B295       301       cpl SOUND_OUT ; Connect speaker to P1.5
0496 32         302       reti
0497            303   ; -----------------------------------------------------------------------------------------------;
0497            304   
0497            305   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0497            306   Initialize_Serial_Port:
0497            307       ; Configure serial port and baud rate
0497 C28E       308       clr TR1 ; Disable timer 1
0499 53890F     309       anl TMOD, #0x0f ; Mask the bits for timer 1
049C 438920     310       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
049F 438780     311       orl PCON, #80H ; Set SMOD to 1
04A2 758DFD     312       mov TH1, #low(TIMER_1_RELOAD)
04A5 758BFD     313       mov TL1, #low(TIMER_1_RELOAD) 
04A8 D28E       314       setb TR1 ; Enable timer 1
04AA 759852     315       mov SCON, #52H
04AD 22         316       ret
04AE            317   
04AE            318   ; uart sending functions
04AE            319   putchar:
04AE 109902     320       jbc TI, putchar_L1
04B1 80FB       321       sjmp putchar
04B3            322   putchar_L1:
04B3 F599       323       mov SBUF,a
04B5 22         324       ret
04B6            325   
04B6            326   SendString:
04B6 E4         327       clr a
04B7 93         328       movc a, @a+dptr
04B8 6006       329       jz SendString_L1
04BA 1204AE     330       lcall putchar
04BD A3         331       inc dptr
04BE 80F6       332       sjmp SendString  
04C0            333   SendString_L1:
04C0 22         334       ret
04C1            335   
04C1            336   ;------------------------------------------------------------
04C1            337   ; getchar_nb (non-blocking)
04C1            338   ; OUT: C=1 if got byte, A=byte
04C1            339   ;      C=0 if none
04C1            340   ;------------------------------------------------------------
04C1            341   getchar_nb:
04C1 309806     342       jnb RI, rx_none
04C4 E599       343       mov A, SBUF
04C6 C298       344       clr RI
04C8 D3         345       setb C
04C9 22         346       ret
04CA            347   rx_none:
04CA C3         348       clr C
04CB 22         349       ret
04CC            350   ;------------------------------------------------------------
04CC            351   ; Serial_RX_Pump
04CC            352   ; Builds a null-terminated line in rx_buf.
04CC            353   ; Sets rx_ready=1 when a full line received.
04CC            354   ;------------------------------------------------------------
04CC            355   Serial_RX_Pump:
04CC E57E       356       mov A, rx_ready
04CE 7034       357       jnz rxp_done          ; don't overwrite unprocessed line
04D0            358   
04D0            359   rxp_more:
04D0 1204C1     360       lcall getchar_nb
04D3 502F       361       jnc rxp_done          ; no new byte
04D5 F5F0       362       mov B, A              ; save received byte
04D7            363   
04D7            364       ; ignore CR
04D7 B40D02     365       cjne A, #0DH, rxp_not_cr
04DA 80F4       366       sjmp rxp_more
04DC            367   
04DC            368   rxp_not_cr:
04DC            369       ; if LF -> finish line
04DC B40A0F     370       cjne A, #0AH, rxp_store
04DF            371   
04DF            372       ; terminate string
04DF E57D       373       mov A, rx_idx
04E1 2492       374       add A, #rx_buf
04E3 F8         375       mov R0, A
04E4 7600       376       mov @R0, #0
04E6 757E01     377       mov rx_ready, #1
04E9 757D00     378       mov rx_idx, #0
04EC 8016       379       sjmp rxp_done
04EE            380   
04EE            381   rxp_store:
04EE            382       ; store char if room (max 39 chars)
04EE E57D       383       mov A, rx_idx
04F0 B42705     384       cjne A, #39, rxp_ok
04F3 757D00     385       mov rx_idx, #0        ; overflow: reset
04F6 800C       386       sjmp rxp_done
04F8            387   
04F8            388   rxp_ok:
04F8 E57D       389       mov A, rx_idx
04FA 2492       390       add A, #rx_buf
04FC F8         391       mov R0, A
04FD E5F0       392       mov A, B
04FF F6         393       mov @R0, A
0500 057D       394       inc rx_idx
0502 80CC       395       sjmp rxp_more
0504            396   
0504            397   rxp_done:
0504 22         398       ret
0505            399   ; copies 3 ASCII digits to buffer at R1, null terminates
0505            400   ; R0 = src (first digit), R1 = dst
0505            401   Copy3DigitsToBuf:
0505 E6         402       mov A, @R0
0506 F7         403       mov @R1, A
0507 08         404       inc R0
0508 09         405       inc R1
0509 E6         406       mov A, @R0
050A F7         407       mov @R1, A
050B 08         408       inc R0
050C 09         409       inc R1
050D E6         410       mov A, @R0
050E F7         411       mov @R1, A
050F 09         412       inc R1
0510 7700       413       mov @R1, #0
0512 22         414       ret
0513            415   
0513            416   ; copies 4 ASCII digits to buffer at R1, null terminates
0513            417   Copy4DigitsToBuf:
0513 E6         418       mov A, @R0
0514 F7         419       mov @R1, A
0515 08         420       inc R0
0516 09         421       inc R1
0517 E6         422       mov A, @R0
0518 F7         423       mov @R1, A
0519 08         424       inc R0
051A 09         425       inc R1
051B E6         426       mov A, @R0
051C F7         427       mov @R1, A
051D 08         428       inc R0
051E 09         429       inc R1
051F E6         430       mov A, @R0
0520 F7         431       mov @R1, A
0521 09         432       inc R1
0522 7700       433       mov @R1, #0
0524 22         434       ret
0525            435   
0525            436   ;------------------------------------------------------------
0525            437   ; Serial_Process_Line
0525            438   ; Handles: UI:REMOTE, RUN:0/1, S:TTT, K:MMSS, R:TTT, L:MMSS, 
0525            439   ;          CFG:APPLY, CFG {json}, SAVE:1
0525            440   ;------------------------------------------------------------
0525            441   Serial_Process_Line:
0525 E57E       442       mov A, rx_ready
0527 7001       443       jnz SPL_HAVE
0529 22         444       ret
052A            445   SPL_HAVE:
052A 757E00     446       mov rx_ready, #0
052D 7892       447       mov R0, #rx_buf
052F E6         448       mov A, @R0
0530            449   
0530            450       ; Branch by first character (with trampolines for distance)
0530 B45502     451       cjne A, #'U', SPL_not_U
0533 801C       452       sjmp do_chk_UI_REMOTE
0535            453   SPL_not_U:
0535 B45202     454       cjne A, #'R', SPL_not_R
0538 801A       455       sjmp do_chk_R_commands
053A            456   SPL_not_R:
053A B45302     457       cjne A, #'S', SPL_not_S
053D 8018       458       sjmp do_chk_S_commands
053F            459   SPL_not_S:
053F B44B02     460       cjne A, #'K', SPL_not_K
0542 8016       461       sjmp do_chk_K
0544            462   SPL_not_K:
0544 B44C02     463       cjne A, #'L', SPL_not_L
0547 8014       464       sjmp do_chk_L
0549            465   SPL_not_L:
0549 B44302     466       cjne A, #'C', SPL_not_C
054C 8012       467       sjmp do_chk_CFG_commands
054E            468   SPL_not_C:
054E 02064E     469       ljmp spl_done
0551            470   
0551            471   ; --- Trampolines ---
0551            472   do_chk_UI_REMOTE:
0551 020563     473       ljmp chk_UI_REMOTE
0554            474   do_chk_R_commands:
0554 02057D     475       ljmp chk_R_commands
0557            476   do_chk_S_commands:
0557 0205B7     477       ljmp chk_S_commands
055A            478   do_chk_K:
055A 0205EB     479       ljmp chk_K
055D            480   do_chk_L:
055D 0205FD     481       ljmp chk_L
0560            482   do_chk_CFG_commands:
0560 02060F     483       ljmp chk_CFG_commands
0563            484   
0563            485   ;------------------------------------------------------------
0563            486   ; UI:REMOTE - Switch to remote control mode
0563            487   ;------------------------------------------------------------
0563            488   chk_UI_REMOTE:
0563 7892       489       mov R0, #rx_buf
0565 E6         490       mov A, @R0
0566 B45511     491       cjne A, #'U', spl_done_bridge1
0569 08         492       inc R0
056A E6         493       mov A, @R0
056B B4490C     494       cjne A, #'I', spl_done_bridge1
056E 08         495       inc R0
056F E6         496       mov A, @R0
0570 B43A07     497       cjne A, #':', spl_done_bridge1
0573 08         498       inc R0
0574 E6         499       mov A, @R0
0575 B45202     500       cjne A, #'R', spl_done_bridge1
0578            501       ; Good enough - it's UI:R...
0578 8000       502       sjmp spl_done_bridge1
057A            503   
057A            504   spl_done_bridge1:
057A 02064E     505       ljmp spl_done
057D            506   
057D            507   ;------------------------------------------------------------
057D            508   ; R commands: R:TTT (reflow temp) or RUN:0/1
057D            509   ;------------------------------------------------------------
057D            510   chk_R_commands:
057D 7892       511       mov R0, #rx_buf
057F 08         512       inc R0                     ; Point to second char
0580 E6         513       mov A, @R0
0581 B43A08     514       cjne A, #':', chk_RUN_jump ; If not ':', check for RUN
0584            515       ; It's "R:" - Reflow temperature
0584 08         516       inc R0
0585 7989       517       mov R1, #Buf_Refl_Temp
0587 120505     518       lcall Copy3DigitsToBuf
058A 8002       519       sjmp spl_done_bridge2
058C            520   
058C            521   chk_RUN_jump:
058C 8003       522       sjmp chk_RUN
058E            523   
058E            524   spl_done_bridge2:
058E 02064E     525       ljmp spl_done
0591            526   
0591            527   chk_RUN:
0591            528       ; Check for "RUN:"
0591 7892       529       mov R0, #rx_buf
0593 08         530       inc R0
0594 E6         531       mov A, @R0
0595 B4551C     532       cjne A, #'U', spl_done_bridge3
0598 08         533       inc R0
0599 E6         534       mov A, @R0
059A B44E17     535       cjne A, #'N', spl_done_bridge3
059D 08         536       inc R0
059E E6         537       mov A, @R0
059F B43A12     538       cjne A, #':', spl_done_bridge3
05A2 08         539       inc R0
05A3 E6         540       mov A, @R0
05A4            541       
05A4            542       ; Check for '1' or '0'
05A4 B43105     543       cjne A, #'1', chk_RUN_zero
05A7            544       
05A7            545       ; RUN:1 - Start the process
05A7 020ECD     546       ljmp Control_FSM_state2_a
05AA 8008       547       sjmp spl_done_bridge3
05AC            548   
05AC            549   chk_RUN_zero:
05AC B43005     550       cjne A, #'0', spl_done_bridge3
05AF            551       ; RUN:0 - Stop the process
05AF 020EA0     552       ljmp Control_FSM_state0_a
05B2 8000       553       sjmp spl_done_bridge3
05B4            554   
05B4            555   spl_done_bridge3:
05B4 02064E     556       ljmp spl_done
05B7            557   
05B7            558   ;------------------------------------------------------------
05B7            559   ; S commands: S:TTT (soak temp) or SAVE:1
05B7            560   ;------------------------------------------------------------
05B7            561   chk_S_commands:
05B7 7892       562       mov R0, #rx_buf
05B9 08         563       inc R0                     ; Point to second char
05BA E6         564       mov A, @R0
05BB B43A08     565       cjne A, #':', chk_SAVE_jump
05BE            566       ; It's "S:" - Soak temperature
05BE 08         567       inc R0
05BF 7980       568       mov R1, #Buf_Soak_Temp
05C1 120505     569       lcall Copy3DigitsToBuf
05C4 8002       570       sjmp spl_done_bridge4
05C6            571   
05C6            572   chk_SAVE_jump:
05C6 8003       573       sjmp chk_SAVE
05C8            574   
05C8            575   spl_done_bridge4:
05C8 02064E     576       ljmp spl_done
05CB            577   
05CB            578   chk_SAVE:
05CB            579       ; Check for "SAVE:"
05CB 7892       580       mov R0, #rx_buf
05CD 08         581       inc R0
05CE E6         582       mov A, @R0
05CF B44116     583       cjne A, #'A', spl_done_bridge5
05D2 08         584       inc R0
05D3 E6         585       mov A, @R0
05D4 B45611     586       cjne A, #'V', spl_done_bridge5
05D7 08         587       inc R0
05D8 E6         588       mov A, @R0
05D9 B4450C     589       cjne A, #'E', spl_done_bridge5
05DC 08         590       inc R0
05DD E6         591       mov A, @R0
05DE B43A07     592       cjne A, #':', spl_done_bridge5
05E1 08         593       inc R0
05E2 E6         594       mov A, @R0
05E3 B43102     595       cjne A, #'1', spl_done_bridge5
05E6            596       
05E6            597       ; SAVE:1 - Save to non-volatile memory (stub)
05E6 8000       598       sjmp spl_done_bridge5
05E8            599   
05E8            600   spl_done_bridge5:
05E8 02064E     601       ljmp spl_done
05EB            602   
05EB            603   ;------------------------------------------------------------
05EB            604   ; K:MMSS - Soak time
05EB            605   ;------------------------------------------------------------
05EB            606   chk_K:
05EB 7892       607       mov R0, #rx_buf
05ED 08         608       inc R0
05EE E6         609       mov A, @R0
05EF B43A08     610       cjne A, #':', spl_done_bridge6
05F2 08         611       inc R0
05F3 7984       612       mov R1, #Buf_Soak_Time
05F5 120513     613       lcall Copy4DigitsToBuf
05F8 8000       614       sjmp spl_done_bridge6
05FA            615   
05FA            616   spl_done_bridge6:
05FA 02064E     617       ljmp spl_done
05FD            618   
05FD            619   ;------------------------------------------------------------
05FD            620   ; L:MMSS - Reflow time
05FD            621   ;------------------------------------------------------------
05FD            622   chk_L:
05FD 7892       623       mov R0, #rx_buf
05FF 08         624       inc R0
0600 E6         625       mov A, @R0
0601 B43A08     626       cjne A, #':', spl_done_bridge7
0604 08         627       inc R0
0605 798D       628       mov R1, #Buf_Refl_Time
0607 120513     629       lcall Copy4DigitsToBuf
060A 8000       630       sjmp spl_done_bridge7
060C            631   
060C            632   spl_done_bridge7:
060C 02064E     633       ljmp spl_done
060F            634   
060F            635   ;------------------------------------------------------------
060F            636   ; CFG commands: CFG:APPLY or CFG {json}
060F            637   ;------------------------------------------------------------
060F            638   chk_CFG_commands:
060F 7892       639       mov R0, #rx_buf
0611 E6         640       mov A, @R0
0612 B44336     641       cjne A, #'C', spl_done_bridge8
0615 08         642       inc R0
0616 E6         643       mov A, @R0
0617 B44631     644       cjne A, #'F', spl_done_bridge8
061A 08         645       inc R0
061B E6         646       mov A, @R0
061C B4472C     647       cjne A, #'G', spl_done_bridge8
061F 08         648       inc R0
0620 E6         649       mov A, @R0
0621            650       
0621            651       ; Check if ':' (CFG:APPLY) or ' ' (CFG {json})
0621 B43A22     652       cjne A, #':', chk_CFG_json
0624            653       
0624            654       ; It's "CFG:" - check for APPLY
0624 08         655       inc R0
0625 E6         656       mov A, @R0
0626 B44122     657       cjne A, #'A', spl_done_bridge8
0629 08         658       inc R0
062A E6         659       mov A, @R0
062B B4501D     660       cjne A, #'P', spl_done_bridge8
062E 08         661       inc R0
062F E6         662       mov A, @R0
0630 B45018     663       cjne A, #'P', spl_done_bridge8
0633 08         664       inc R0
0634 E6         665       mov A, @R0
0635 B44C13     666       cjne A, #'L', spl_done_bridge8
0638 08         667       inc R0
0639 E6         668       mov A, @R0
063A B4590E     669       cjne A, #'Y', spl_done_bridge8
063D            670       
063D            671       ; CFG:APPLY - Apply configuration
063D 120F77     672       lcall Update_FSM_Variables
0640 D20F       673       setb state_change_signal
0642 D224       674       setb fullscreen_update_signal
0644 8005       675       sjmp spl_done_bridge8
0646            676   
0646            677   chk_CFG_json:
0646            678       ; Check for space (CFG {json})
0646 B42002     679       cjne A, #' ', spl_done_bridge8
0649            680       ; It's "CFG {...}" - JSON config (ignored)
0649 8000       681       sjmp spl_done_bridge8
064B            682   
064B            683   spl_done_bridge8:
064B 02064E     684       ljmp spl_done
064E            685   
064E            686   ;------------------------------------------------------------
064E            687   spl_done:
064E 22         688       ret
064F            689   
064F            690   
064F            691   ;-------------------------------------------------------------------------------
064F            692   ; serial debugging
064F            693   ; send a four byte number via serial to laptop
064F            694   ; need to be used with python script
064F            695   ; content needed to be sent should be stored in the varaible x
064F            696   ;-------------------------------------------------------------------------------
064F            697   Send32:
064F            698       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
064F 74AA       699       mov A, #0AAH
0651 1204AE     700       lcall putchar
0654 7455       701       mov A, #055H
0656 1204AE     702       lcall putchar
0659            703   
0659 E53D       704       mov A, x+3
065B 1204AE     705       lcall putchar
065E E53C       706       mov A, x+2
0660 1204AE     707       lcall putchar
0663 E53B       708       mov A, x+1
0665 1204AE     709       lcall putchar
0668 E53A       710       mov A, x+0
066A 1204AE     711       lcall putchar
066D            712   
066D 740A       713       mov A, #0AH
066F 1204AE     714       lcall putchar
0672 22         715       ret
0673            716   ;-------------------------------------------------------------------------------
0673            717   ; Serial temperature line for PuTTY/screen
0673            718   ; Outputs: "Temp: XXXC\r\n"
0673            719   ;-------------------------------------------------------------------------------
0673            720   Serial_Send_Temp_Line:
0673 9003E5     721       mov dptr, #String_temp_line
0676 1204B6     722       lcall SendString
0679            723   
0679            724       ; Convert current_temp to BCD (same as LCD)
0679 85473A     725       mov x, current_temp
067C 85483B     726       mov x+1, current_temp+1
067F 85493C     727       mov x+2, current_temp+2
0682 854A3D     728       mov x+3, current_temp+3
0685 12002E     729       lcall hex2bcd
0688            730   
0688 7F00       731       mov R7, #0          ; printed_flag = 0
068A            732   
068A            733       ; Print Hundreds (if non-zero)
068A E543       734       mov a, bcd+1
068C 540F       735       anl a, #0x0F
068E 6007       736       jz Serial_Skip_Hundreds
0690 2430       737       add a, #0x30
0692 1204AE     738       lcall putchar
0695 7F01       739       mov R7, #1
0697            740   Serial_Skip_Hundreds:
0697            741   
0697            742       ; Print Tens (if non-zero or if hundreds already printed)
0697 E542       743       mov a, bcd+0
0699 C4         744       swap a
069A 540F       745       anl a, #0x0F
069C 7003       746       jnz Serial_Print_Tens
069E EF         747       mov a, R7
069F 600C       748       jz Serial_Skip_Tens
06A1            749   Serial_Print_Tens:
06A1 E542       750       mov a, bcd+0
06A3 C4         751       swap a
06A4 540F       752       anl a, #0x0F
06A6 2430       753       add a, #0x30
06A8 1204AE     754       lcall putchar
06AB 7F01       755       mov R7, #1
06AD            756   Serial_Skip_Tens:
06AD            757   
06AD            758       ; Print Ones (always)
06AD E542       759       mov a, bcd+0
06AF 540F       760       anl a, #0x0F
06B1 2430       761       add a, #0x30
06B3 1204AE     762       lcall putchar
06B6            763   
06B6            764       ; Print 'C' and newline
06B6 7443       765       mov a, #'C'
06B8 1204AE     766       lcall putchar
06BB 740D       767       mov a, #0DH     ; CR
06BD 1204AE     768       lcall putchar
06C0 740A       769       mov a, #0AH     ; LF
06C2 1204AE     770       lcall putchar
06C5 22         771       ret
06C6            772   ;-------------------------------------------------------------------------------
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
06C6              1   ;-------------------------------------------------------------------------------
06C6              2   ; Timer2_ISR.inc
06C6              3   ; Contains Initialization and ISR for the 1ms System Timer
06C6              4   ;-------------------------------------------------------------------------------
06C6              5   
06C6              6   ;-------------------------------------------------------------------------------
06C6              7   ; Routine to initialize the ISR for timer 2
06C6              8   ;-------------------------------------------------------------------------------
06C6              9   Timer2_Init:
06C6 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
06C9 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
06CC 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
06CF             13       ; Set the reload value
06CF 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
06D2 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
06D5             16       
06D5 C2CF        17       clr TF2       ; Clear flag just in case
06D7             18       ; Enable the timer and interrupts
06D7 D2AD        19       setb ET2      ; Enable timer 2 interrupt
06D9 D2CA        20       setb TR2      ; Enable timer 2
06DB 22          21       ret
06DC             22   
06DC             23   ;-------------------------------------------------------------------------------
06DC             24   ; ISR for timer 2.  Runs every 1 ms
06DC             25   ;-------------------------------------------------------------------------------
06DC             26   Timer2_ISR:
06DC C0E0        27       push acc
06DE C0D0        28       push psw
06E0             29       
06E0 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
06E2             31   
06E2             32       ; --- 1. Existing Non-Blocking Seconds Increment and Periphals Debounce Timers ---
06E2 056F        33       inc SEC_FSM_timer
06E4 D202        34       setb one_ms_pwm_flag 
06E6 D203        35            setb one_ms_buzz_flag
06E8 D218        36       setb one_ms_beep_flag
06EA D226        37       setb one_millisecond_flag_servo
06EC             38     
06EC 0571        39       inc PB0_DEB_timer
06EE 0573        40       inc PB2_DEB_timer
06F0 057B        41       inc BTN_DEB_timer
06F2             42   
06F2             43       ; --- 2. NEW: Non-Blocking Delay Counters ---
06F2             44       ; A. BUTTON DELAY
06F2 301C0B      45       jnb wait25_btn_active, T2_Check_Keypad
06F5 0553        46       inc wait25_btn_cnt
06F7 E553        47       mov a, wait25_btn_cnt
06F9 B41904      48       cjne a, #25, T2_Check_Keypad
06FC D21D        49       setb wait25_btn_done
06FE C21C        50       clr wait25_btn_active
0700             51       
0700             52       ; B. KEYPAD DELAY
0700             53   T2_Check_Keypad:
0700 301E0B      54       jnb wait25_keypad_active, T2_Check_ADC
0703 0554        55       inc wait25_keypad_cnt
0705 E554        56       mov a, wait25_keypad_cnt
0707 B41904      57       cjne a, #25, T2_Check_ADC
070A D21F        58       setb wait25_keypad_done
070C C21E        59       clr wait25_keypad_active
070E             60   
070E             61       ; C. ADC DELAY (Thermocouple)
070E             62   T2_Check_ADC:
070E 30200B      63       jnb wait25_adc_active, T2_Check_LCD
0711 0555        64       inc wait25_adc_cnt
0713 E555        65       mov a, wait25_adc_cnt
0715 B41904      66       cjne a, #25, T2_Check_LCD
0718 D221        67       setb wait25_adc_done
071A C220        68       clr wait25_adc_active
071C             69   
071C             70       ; D. LCD DELAY
071C             71   T2_Check_LCD:
071C 30220B      72       jnb wait25_lcd_active, T2_Check_Generic
071F 0556        73       inc wait25_lcd_cnt
0721 E556        74       mov a, wait25_lcd_cnt
0723 B41904      75       cjne a, #25, T2_Check_Generic
0726 D223        76       setb wait25_lcd_done
0728 C222        77       clr wait25_lcd_active
072A             78   
072A             79       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
072A             80   T2_Check_Generic:
072A 301A0B      81       jnb wait25_active, Timer2_ISR_done
072D 0557        82       inc wait25_count
072F E557        83       mov a, wait25_count
0731 B41904      84       cjne a, #25, Timer2_ISR_done
0734 D21B        85       setb wait25_done      ; Tells Wait_25ms that we are finished
0736 C21A        86       clr wait25_active     ; Stop counting
0738             87   
0738             88   Timer2_ISR_done:
0738 D0D0        89       pop psw
073A D0E0        90       pop acc
073C 32          91       reti
073D             92            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
073D              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
073D              2   cseg
073D              3   
073D              4   ; When using a 33.333333MHz crystal clock
073D              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
073D              6   
073D              7   ;---------------------------------;
073D              8   ; Wait 40 microseconds            ;
073D              9   ;---------------------------------;
073D             10   Wait40uSec:
073D C000        11            push AR0
073F 78BE        12            mov R0, #190
0741             13   L0: 
0741 00          14            nop
0742 00          15            nop
0743 00          16            nop
0744 00          17            nop
0745 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0747 D000        19            pop AR0
0749 22          20       ret
074A             21   
074A             22   ;---------------------------------;
074A             23   ; Wait 'R2' milliseconds          ;
074A             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
074A             31   
074A             32   ?Wait_Milli_Seconds:
074A C000        33            push AR0
074C C001        34            push AR1
074E 7932        35   L3: mov R1, #50
0750 78DF        36   L2: mov R0, #223
0752 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
0754 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
0756 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
0758 D001        40       pop AR1
075A D000        41       pop AR0
075C 22          42       ret
075D             43            
075D             44   ;---------------------------------;
075D             45   ; Toggles the 'E' pin in the LCD  ;
075D             46   ;---------------------------------;
075D             47   ELCD_pulse:
075D D291        48            setb ELCD_E
075F 12073D      49            lcall Wait40uSec
0762 C291        50            clr ELCD_E
0764 12073D      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
0767 22          52       ret
0768             53   
0768             54   ;---------------------------------;
0768             55   ; Writes acc to LCD in 4-bit mode ;
0768             56   ;---------------------------------;
0768             57   ELCD_byte:
0768             58            ; Write high 4 bits first
0768 A2E7        59            mov c, ACC.7
076A 9281        60            mov ELCD_D7, c
076C A2E6        61            mov c, ACC.6
076E 9283        62            mov ELCD_D6, c
0770 A2E5        63            mov c, ACC.5
0772 9285        64            mov ELCD_D5, c
0774 A2E4        65            mov c, ACC.4
0776 9287        66            mov ELCD_D4, c
0778 12075D      67       lcall ELCD_pulse
077B             68            ; Write low 4 bits next
077B A2E3        69            mov c, ACC.3
077D 9281        70            mov ELCD_D7, c
077F A2E2        71            mov c, ACC.2
0781 9283        72            mov ELCD_D6, c
0783 A2E1        73            mov c, ACC.1
0785 9285        74            mov ELCD_D5, c
0787 A2E0        75            mov c, ACC.0
0789 9287        76            mov ELCD_D4, c
078B 12075D      77       lcall ELCD_pulse
078E 22          78            ret
078F             79   
078F             80   ;---------------------------------;
078F             81   ; Write data to LCD               ;
078F             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
078F             87            
078F             88   ?WriteData:
078F D297        89            setb ELCD_RS
0791 020768      90            ljmp ELCD_byte
0794             91   
0794             92   ;---------------------------------;
0794             93   ; Write command to LCD            ;
0794             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
0794             99   
0794            100   ?WriteCommand:
0794 C297       101            clr ELCD_RS
0796 020768     102            ljmp ELCD_byte
0799            103   
0799            104   ;---------------------------------;
0799            105   ; Configure LCD in 4-bit mode     ;
0799            106   ;---------------------------------;
0799            107   ELCD_4BIT:
0799 C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
079B            109            ;clr ELCD_RW  ; RW forced to zero
079B            110            
079B            111            ; After power on, let the LCD start up before initializing
079B C002       112            push AR2
079D 7A28       112            mov R2, #40
079F 12074A     112            lcall ?Wait_Milli_Seconds
07A2 D002       112            pop AR2
07A4            112   
07A4            113            
07A4            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
07A4 7433       115            mov a, #0x33
07A6 120794     115            lcall ?WriteCommand
07A9 7433       116            mov a, #0x33
07AB 120794     116            lcall ?WriteCommand
07AE 7432       117            mov a, #0x32
07B0 120794     117            lcall ?WriteCommand ; change to 4-bit mode
07B3            118   
07B3            119            ; Configure the LCD
07B3 7428       120            mov a, #0x28
07B5 120794     120            lcall ?WriteCommand
07B8 740C       121            mov a, #0x0c
07BA 120794     121            lcall ?WriteCommand
07BD 7401       122            mov a, #0x01
07BF 120794     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
07C2            123   
07C2            124       ;Wait for the clear screen command to finish.
07C2 C002       125            push AR2
07C4 7A02       125            mov R2, #2
07C6 12074A     125            lcall ?Wait_Milli_Seconds
07C9 D002       125            pop AR2
07CB            125   
07CB 22         126       ret
07CC            127   
07CC            128   ;---------------------------------;
07CC            129   ; Send a constant string to LCD   ;
07CC            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
07CC            141   
07CC            142   ?Send_Constant_String:
07CC E4         143       clr a
07CD 93         144       movc a, @a+dptr
07CE 6006       145       jz ?Send_Constant_String_Done
07D0 12078F     146       lcall ?WriteData
07D3 A3         147       inc dptr
07D4 80F6       148       sjmp ?Send_Constant_String
07D6            149   ?Send_Constant_String_Done:
07D6 22         150       ret  
07D7            151   
07D7            152   ;---------------------------------;
07D7            153   ; Set LCD cursor at row, column   ;
07D7            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
07D7            162   
07D7            163   ?Set_Cursor_2:
07D7 4440       164            orl a, #01000000B
07D9            165   ?Set_Cursor_1:
07D9 4480       166            orl a, #10000000B
07DB 020794     167            ljmp ?WriteCommand ; Select column and row
07DE            168   
07DE            169   ;---------------------------------;
07DE            170   ; Display a BCD number in the LCD ;
07DE            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
07DE            178   
07DE            179   ?Display_BCD:
07DE C0E0       180            push acc
07E0            181            ; Write most significant digit
07E0 E8         182            mov a, r0
07E1 C4         183            swap a
07E2 540F       184            anl a, #0fh
07E4 4430       185            orl a, #30h
07E6 12078F     186            lcall ?WriteData
07E9            187            ; write least significant digit
07E9 E8         188            mov a, r0
07EA 540F       189            anl a, #0fh
07EC 4430       190            orl a, #30h
07EE 12078F     191            lcall ?WriteData
07F1 D0E0       192            pop acc
07F3 22         193            ret
07F4            194   
07F4            195   ;------------------------------------;
07F4            196   ; Display a char in the LCD          ;
07F4            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
07F4            204   
07F4            775            ;-------------------------------------------------------------------------------
07F4            776   ; Display Function for 7-segment displays       
07F4            777   ;-------------------------------------------------------------------------------
07F4            778   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
07F4            779   T_7seg:
07F4 C0F9A4B0   780       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
07F9 9282F880   781       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
07FE 8883C6A1   782       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0804            783   
0804            784   ; Displays a BCD number pased in R0 in HEX5-HEX0
0804            785   Display_BCD_7_Seg_HEX10:
0804 9007F4     786       mov dptr, #T_7seg
0807 E8         787       mov a, R0
0808 C4         788       swap a
0809 540F       789       anl a, #0FH
080B 93         790       movc a, @a+dptr
080C F592       791       mov HEX1, a
080E E8         792       mov a, R0
080F 540F       793       anl a, #0FH
0811 93         794       movc a, @a+dptr
0812 F591       795       mov HEX0, a
0814 22         796       ret
0815            797   
0815            798   Display_BCD_7_Seg_HEX32:
0815 9007F4     799       mov dptr, #T_7seg
0818 E8         800       mov a, R0
0819 C4         801       swap a
081A 540F       802       anl a, #0FH
081C 93         803       movc a, @a+dptr
081D F594       804       mov HEX3, a
081F E8         805       mov a, R0
0820 540F       806       anl a, #0FH
0822 93         807       movc a, @a+dptr
0823 F593       808       mov HEX2, a
0825 22         809       ret
0826            810   
0826            811   Display_BCD_7_Seg_HEX54:
0826 9007F4     812       mov dptr, #T_7seg
0829 E8         813       mov a, R0
082A C4         814       swap a
082B 540F       815       anl a, #0FH
082D 93         816       movc a, @a+dptr
082E F58F       817       mov HEX5, a
0830 E8         818       mov a, R0
0831 540F       819       anl a, #0FH
0833 93         820       movc a, @a+dptr
0834 F58E       821       mov HEX4, a
0836 22         822       ret
0837            823   
0837            824   ; The 8-bit hex number passed in the accumulator is converted to
0837            825   ; BCD and stored in [R1, R0]
0837            826   Hex_to_bcd_8bit:
0837 75F064     827       mov b, #100
083A 84         828       div ab
083B F9         829       mov R1, a   ; After dividing, a has the 100s
083C E5F0       830       mov a, b    ; Remainder is in register b
083E 75F00A     831       mov b, #10
0841 84         832       div ab ; The tens are stored in a, the units are stored in b 
0842 C4         833       swap a
0843 54F0       834       anl a, #0xf0
0845 45F0       835       orl a, b
0847 F8         836       mov R0, a
0848 22         837       ret
0849            838   ;-------------------------------------------------------------------------------
0849            839   ; Display Function for LCD                      
0849            840   ;-------------------------------------------------------------------------------
0849            841   LCD_Print_2Digits:
0849 120837     842       lcall Hex_to_bcd_8bit
084C E8         843       mov a, R0
084D C4         844       swap a
084E 540F       845       anl a, #0x0F
0850 2430       846       add a, #0x30
0852 12078F     847       lcall ?WriteData
0855 E8         848       mov a, R0
0856 540F       849       anl a, #0x0F
0858 2430       850       add a, #0x30
085A 12078F     851       lcall ?WriteData
085D 22         852       ret
085E            853   
085E            854   LCD_Display_Update_func:
085E C0E0       855       push acc
0860            856       
0860            857       ; ==========================================
0860            858       ; PART 1: STATIC TEXT (Title)
0860            859       ; Runs ONLY when the state changes
0860            860       ; ==========================================
0860            861       
0860            862       ; [FIX] "Trampoline" logic for long distance jump
0860            863       ; If signal is SET (1), we stay here and update.
0860            864       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
0860 300F04     865       jnb state_change_signal, Do_Dynamic_Update
0863 C20F       866            clr state_change_signal
0865 8003       867            sjmp Do_Static_Update
0867            868   Do_Dynamic_Update:
0867 02099E     869            ljmp Check_Live_Update
086A            870   
086A            871   Do_Static_Update:
086A            872       ; State Changed: Clear Screen and Write Title
086A 120B3D     873       lcall Clear_Screen_Func
086D E560       874       mov a, Control_FSM_state
086F            875       
086F            876       ; State 0: Welcome
086F B4003B     877       cjne a, #0, LCD_Check_1
0872 C0E0       878            push acc
0874 7401       878            mov a, #1
0876 14         878            dec a
0877 1207D9     878            lcall ?Set_Cursor_1 ; Select column and row
087A D0E0       878            pop acc
087C C083       879            push dph
087E C082       879            push dpl
0880 C0E0       879            push acc
0882 900330     879            mov dptr, #String_state0_1
0885 1207CC     879            lcall ?Send_Constant_String
0888 D0E0       879            pop acc
088A D082       879            pop dpl
088C D083       879            pop dph
088E C0E0       880            push acc
0890 7401       880            mov a, #1
0892 14         880            dec a
0893 1207D7     880            lcall ?Set_Cursor_2 ; Select column and row
0896 D0E0       880            pop acc
0898 C083       881            push dph
089A C082       881            push dpl
089C C0E0       881            push acc
089E 900340     881            mov dptr, #String_state0_2
08A1 1207CC     881            lcall ?Send_Constant_String
08A4 D0E0       881            pop acc
08A6 D082       881            pop dpl
08A8 D083       881            pop dph
08AA 02099B     882       ljmp LCD_Done_Bridge ; Exit
08AD            883   
08AD            884   LCD_Check_1: ; Setup
08AD B4011F     885       cjne a, #1, LCD_Check_2
08B0 C0E0       886            push acc
08B2 7401       886            mov a, #1
08B4 14         886            dec a
08B5 1207D9     886            lcall ?Set_Cursor_1 ; Select column and row
08B8 D0E0       886            pop acc
08BA C083       887            push dph
08BC C082       887            push dpl
08BE C0E0       887            push acc
08C0 9003A5     887            mov dptr, #String_state1
08C3 1207CC     887            lcall ?Send_Constant_String
08C6 D0E0       887            pop acc
08C8 D082       887            pop dpl
08CA D083       887            pop dph
08CC 02099B     888       ljmp LCD_Done_Bridge
08CF            889   
08CF            890   LCD_Check_2: ; Ramp to Soak
08CF B4021F     891       cjne a, #2, LCD_Check_3
08D2 C0E0       892            push acc
08D4 7401       892            mov a, #1
08D6 14         892            dec a
08D7 1207D9     892            lcall ?Set_Cursor_1 ; Select column and row
08DA D0E0       892            pop acc
08DC C083       893            push dph
08DE C082       893            push dpl
08E0 C0E0       893            push acc
08E2 9003EC     893            mov dptr, #String_state2
08E5 1207CC     893            lcall ?Send_Constant_String
08E8 D0E0       893            pop acc
08EA D082       893            pop dpl
08EC D083       893            pop dph
08EE 0209D0     894       ljmp LCD_Update_Temp_Value
08F1            895   
08F1            896   LCD_Check_3: ; Soak
08F1 B4031F     897       cjne a, #3, LCD_Check_4
08F4 C0E0       898            push acc
08F6 7401       898            mov a, #1
08F8 14         898            dec a
08F9 1207D9     898            lcall ?Set_Cursor_1 ; Select column and row
08FC D0E0       898            pop acc
08FE C083       899            push dph
0900 C082       899            push dpl
0902 C0E0       899            push acc
0904 9003FC     899            mov dptr, #String_state3
0907 1207CC     899            lcall ?Send_Constant_String
090A D0E0       899            pop acc
090C D082       899            pop dpl
090E D083       899            pop dph
0910 0209D0     900       ljmp LCD_Update_Temp_Value
0913            901   
0913            902   LCD_Check_4: ; Ramp to Peak
0913 B4041F     903       cjne a, #4, LCD_Check_5
0916 C0E0       904            push acc
0918 7401       904            mov a, #1
091A 14         904            dec a
091B 1207D9     904            lcall ?Set_Cursor_1 ; Select column and row
091E D0E0       904            pop acc
0920 C083       905            push dph
0922 C082       905            push dpl
0924 C0E0       905            push acc
0926 90040C     905            mov dptr, #String_state4
0929 1207CC     905            lcall ?Send_Constant_String
092C D0E0       905            pop acc
092E D082       905            pop dpl
0930 D083       905            pop dph
0932 0209D0     906       ljmp LCD_Update_Temp_Value
0935            907   
0935            908   LCD_Check_5: ; Reflow
0935 B4051F     909       cjne a, #5, LCD_Check_6
0938 C0E0       910            push acc
093A 7401       910            mov a, #1
093C 14         910            dec a
093D 1207D9     910            lcall ?Set_Cursor_1 ; Select column and row
0940 D0E0       910            pop acc
0942 C083       911            push dph
0944 C082       911            push dpl
0946 C0E0       911            push acc
0948 90041C     911            mov dptr, #String_state5
094B 1207CC     911            lcall ?Send_Constant_String
094E D0E0       911            pop acc
0950 D082       911            pop dpl
0952 D083       911            pop dph
0954 0209D0     912       ljmp LCD_Update_Temp_Value
0957            913   
0957            914   LCD_Check_6: ; Cooling
0957 B4061F     915       cjne a, #6, LCD_Check_7
095A C0E0       916            push acc
095C 7401       916            mov a, #1
095E 14         916            dec a
095F 1207D9     916            lcall ?Set_Cursor_1 ; Select column and row
0962 D0E0       916            pop acc
0964 C083       917            push dph
0966 C082       917            push dpl
0968 C0E0       917            push acc
096A 90042C     917            mov dptr, #String_state6
096D 1207CC     917            lcall ?Send_Constant_String
0970 D0E0       917            pop acc
0972 D082       917            pop dpl
0974 D083       917            pop dph
0976 0209D0     918       ljmp LCD_Update_Temp_Value
0979            919   
0979            920   LCD_Check_7: ; Done
0979 B4071F     921       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
097C C0E0       922            push acc
097E 7401       922            mov a, #1
0980 14         922            dec a
0981 1207D9     922            lcall ?Set_Cursor_1 ; Select column and row
0984 D0E0       922            pop acc
0986 C083       923            push dph
0988 C082       923            push dpl
098A C0E0       923            push acc
098C 90043C     923            mov dptr, #String_state7
098F 1207CC     923            lcall ?Send_Constant_String
0992 D0E0       923            pop acc
0994 D082       923            pop dpl
0996 D083       923            pop dph
0998 02099B     924       ljmp LCD_Done_Bridge
099B            925   
099B            926   ; Local bridge to reach the far-away LCD_Done
099B            927   LCD_Done_Bridge:
099B 020A2B     928       ljmp LCD_Done
099E            929   
099E            930   ;-------------------------------------------------------------------------------
099E            931   ; PART 2: dyanmic for temp
099E            932   ; runs every time 'one_second_flag' is set
099E            933   ;-------------------------------------------------------------------------------
099E            934   Check_Live_Update:
099E 3001FA     935       jnb one_second_flag, LCD_Done_Bridge
09A1 C201       936       clr one_second_flag
09A3            937   
09A3            938       ; Update 7 seg Temp Update for all time
09A3 85473A     939       mov x, current_temp
09A6 85483B     940       mov x+1, current_temp+1
09A9 85493C     941       mov x+2, current_temp+2
09AC 854A3D     942       mov x+3, current_temp+3
09AF 12002E     943       lcall hex2bcd
09B2 120B68     944       lcall Update_HEX_Temp 
09B5            945       
09B5            946       ; Only update temp for States 2, 3, 4, 5, 6 on LCD
09B5 E560       947       mov a, Control_FSM_state
09B7 B40202     948       cjne a, #2, Check_St3
09BA 8014       949       sjmp LCD_Update_Temp_Value
09BC            950   Check_St3:
09BC B40302     951       cjne a, #3, Check_St4
09BF 800F       952       sjmp LCD_Update_Temp_Value
09C1            953   Check_St4:
09C1 B40402     954       cjne a, #4, Check_St5
09C4 800A       955       sjmp LCD_Update_Temp_Value
09C6            956   Check_St5:
09C6 B40502     957       cjne a, #5, Check_St6
09C9 8005       958       sjmp LCD_Update_Temp_Value
09CB            959   Check_St6:
09CB B4065D     960       cjne a, #6, LCD_Done
09CE 8000       961       sjmp LCD_Update_Temp_Value
09D0            962   
09D0            963   LCD_Update_Temp_Value:
09D0 C0E0       964            push acc
09D2 7401       964            mov a, #1
09D4 14         964            dec a
09D5 1207D7     964            lcall ?Set_Cursor_2 ; Select column and row
09D8 D0E0       964            pop acc
09DA 85473A     965       mov x, current_temp
09DD 85483B     966       mov x+1, current_temp+1
09E0 85493C     967       mov x+2, current_temp+2
09E3 854A3D     968       mov x+3, current_temp+3
09E6            969   
09E6 E543       970       mov a, bcd+1
09E8 540F       971       anl a, #0x0F
09EA 2430       972       add a, #0x30
09EC 12078F     973       lcall ?WriteData
09EF E542       974       mov a, bcd+0
09F1 C4         975       swap a
09F2 540F       976       anl a, #0x0F
09F4 2430       977       add a, #0x30
09F6 12078F     978       lcall ?WriteData
09F9 E542       979       mov a, bcd+0
09FB 540F       980       anl a, #0x0F
09FD 2430       981       add a, #0x30
09FF 12078F     982       lcall ?WriteData
0A02 7443       983       mov a, #'C'
0A04 12078F     984       lcall ?WriteData
0A07 7420       985       mov a, #' '
0A09 12078F     986       lcall ?WriteData
0A0C 12078F     987       lcall ?WriteData
0A0F C0E0       988            push acc
0A11 740C       988            mov a, #12
0A13 14         988            dec a
0A14 1207D7     988            lcall ?Set_Cursor_2 ; Select column and row
0A17 D0E0       988            pop acc
0A19 E531       989       mov a, current_time_minute
0A1B 120849     990       lcall LCD_Print_2Digits
0A1E 743A       991       mov a, #':'
0A20 12078F     992       lcall ?WriteData
0A23 E530       993       mov a, current_time_sec
0A25 120849     994       lcall LCD_Print_2Digits
0A28 120673     995       lcall Serial_Send_Temp_Line
0A2B            996   
0A2B            997   LCD_Done:
0A2B D0E0       998       pop acc
0A2D 22         999       ret
0A2E           1000   
0A2E           1001   ; ----------------------------------------------------------------
0A2E           1002   ; MODULE: SCREEN UPDATE (Visual Logic)
0A2E           1003   ; ----------------------------------------------------------------
0A2E           1004   Update_Screen_Full:
0A2E E560      1005            mov a, Control_FSM_state
0A30 B40102    1006            cjne a, #1, Update_Screen_Full_ret
0A33 8001      1007            sjmp Update_Screen_Full_do
0A35           1008   Update_Screen_Full_ret:
0A35 22        1009            ret
0A36           1010   Update_Screen_Full_do:
0A36 3024FC    1011       jnb fullscreen_update_signal, Update_Screen_Full_ret
0A39 C224      1012       clr fullscreen_update_signal
0A3B           1013   
0A3B 120B3D    1014       lcall Clear_Screen_Func
0A3E C0E0      1015            push acc
0A40 7401      1015            mov a, #1
0A42 14        1015            dec a
0A43 1207D9    1015            lcall ?Set_Cursor_1 ; Select column and row
0A46 D0E0      1015            pop acc
0A48           1016       ; --- Draw Line 1 (Titles) ---
0A48 E561      1017       mov A, Current_State
0A4A B40013    1018       cjne A, #0, Update_State_1
0A4D C083      1019            push dph
0A4F C082      1019            push dpl
0A51 C0E0      1019            push acc
0A53 900350    1019            mov dptr, #Txt_Home
0A56 1207CC    1019            lcall ?Send_Constant_String
0A59 D0E0      1019            pop acc
0A5B D082      1019            pop dpl
0A5D D083      1019            pop dph
0A5F 22        1020       ret 
0A60           1021   Update_State_1:
0A60 B40114    1022       cjne A, #1, Update_State_2
0A63 C083      1023            push dph
0A65 C082      1023            push dpl
0A67 C0E0      1023            push acc
0A69 900361    1023            mov dptr, #Txt_SoakT
0A6C 1207CC    1023            lcall ?Send_Constant_String
0A6F D0E0      1023            pop acc
0A71 D082      1023            pop dpl
0A73 D083      1023            pop dph
0A75 8042      1024       sjmp Draw_Temp_Format
0A77           1025   Update_State_2:
0A77 B40214    1026       cjne A, #2, Update_State_3
0A7A C083      1027            push dph
0A7C C082      1027            push dpl
0A7E C0E0      1027            push acc
0A80 900372    1027            mov dptr, #Txt_SoakTime
0A83 1207CC    1027            lcall ?Send_Constant_String
0A86 D0E0      1027            pop acc
0A88 D082      1027            pop dpl
0A8A D083      1027            pop dph
0A8C 8046      1028       sjmp Draw_Time_Format
0A8E           1029   Update_State_3:
0A8E B40314    1030       cjne A, #3, Update_State_4
0A91 C083      1031            push dph
0A93 C082      1031            push dpl
0A95 C0E0      1031            push acc
0A97 900383    1031            mov dptr, #Txt_ReflT
0A9A 1207CC    1031            lcall ?Send_Constant_String
0A9D D0E0      1031            pop acc
0A9F D082      1031            pop dpl
0AA1 D083      1031            pop dph
0AA3 8014      1032       sjmp Draw_Temp_Format
0AA5           1033   Update_State_4:
0AA5 C083      1034            push dph
0AA7 C082      1034            push dpl
0AA9 C0E0      1034            push acc
0AAB 900394    1034            mov dptr, #Txt_ReflTime
0AAE 1207CC    1034            lcall ?Send_Constant_String
0AB1 D0E0      1034            pop acc
0AB3 D082      1034            pop dpl
0AB5 D083      1034            pop dph
0AB7 801B      1035       sjmp Draw_Time_Format
0AB9           1036   
0AB9           1037   ; --- Draw Line 2 (Values) ---
0AB9           1038   Draw_Temp_Format:
0AB9 C0E0      1039            push acc
0ABB 7401      1039            mov a, #1
0ABD 14        1039            dec a
0ABE 1207D7    1039            lcall ?Set_Cursor_2 ; Select column and row
0AC1 D0E0      1039            pop acc
0AC3 120B51    1040       lcall Get_Current_Buffer_Addr
0AC6 120B33    1041       lcall Print_String_RAM
0AC9 C0E0      1042            push acc
0ACB 7443      1042            mov a, #'C'
0ACD 12078F    1042            lcall ?WriteData
0AD0 D0E0      1042            pop acc
0AD2 8034      1043       sjmp Restore_Cursor
0AD4           1044   
0AD4           1045   Draw_Time_Format:
0AD4 C0E0      1046            push acc
0AD6 7401      1046            mov a, #1
0AD8 14        1046            dec a
0AD9 1207D7    1046            lcall ?Set_Cursor_2 ; Select column and row
0ADC D0E0      1046            pop acc
0ADE 120B51    1047       lcall Get_Current_Buffer_Addr
0AE1           1048       ; MM
0AE1 E6        1049       mov A, @R0
0AE2 12078F    1050       lcall ?WriteData
0AE5 08        1051       inc R0
0AE6 E6        1052       mov A, @R0
0AE7 12078F    1053       lcall ?WriteData
0AEA 08        1054       inc R0
0AEB           1055       ; Colon
0AEB C0E0      1056            push acc
0AED 743A      1056            mov a, #':'
0AEF 12078F    1056            lcall ?WriteData
0AF2 D0E0      1056            pop acc
0AF4           1057       ; SS
0AF4 E6        1058       mov A, @R0
0AF5 12078F    1059       lcall ?WriteData
0AF8 08        1060       inc R0
0AF9 E6        1061       mov A, @R0
0AFA 12078F    1062       lcall ?WriteData
0AFD           1063       ; Unit
0AFD C0E0      1064            push acc
0AFF 7473      1064            mov a, #'s'
0B01 12078F    1064            lcall ?WriteData
0B04 D0E0      1064            pop acc
0B06 8000      1065       sjmp Restore_Cursor
0B08           1066   
0B08           1067   ; --- Restore Cursor Position ---
0B08           1068   Restore_Cursor:
0B08 E561      1069       mov A, Current_State
0B0A B40202    1070       cjne A, #2, RC_Check_State_4  
0B0D 800C      1071       sjmp Adjust_Cursor_Time
0B0F           1072   RC_Check_State_4:             
0B0F B40402    1073       cjne A, #4, Normal_Cursor
0B12 8007      1074       sjmp Adjust_Cursor_Time
0B14           1075   
0B14           1076   Normal_Cursor:
0B14 E56A      1077       mov A, Cursor_Idx
0B16 24C0      1078       add A, #0xC0
0B18 120794    1079       lcall ?WriteCommand
0B1B           1080   
0B1B           1081   Adjust_Cursor_Time:
0B1B           1082       ; Skip the colon index (2)
0B1B E56A      1083       mov A, Cursor_Idx
0B1D B40201    1084       cjne A, #2, No_Skip
0B20 04        1085       inc A 
0B21           1086   No_Skip:
0B21           1087       ; Add 1 if past the colon
0B21 C3        1088       clr C
0B22 9402      1089       subb A, #2
0B24 4005      1090       jc No_Add
0B26 E56A      1091       mov A, Cursor_Idx
0B28 04        1092       inc A
0B29 8002      1093       sjmp Final_Cursor_Set
0B2B           1094   No_Add:
0B2B E56A      1095       mov A, Cursor_Idx
0B2D           1096   Final_Cursor_Set:
0B2D 24C0      1097       add A, #0xC0
0B2F 120794    1098       lcall ?WriteCommand
0B32 22        1099       ret
0B33           1100   
0B33           1101   Print_String_RAM:
0B33 E6        1102       mov A, @R0
0B34 6006      1103       jz Print_String_Done
0B36 12078F    1104       lcall ?WriteData
0B39 08        1105       inc R0
0B3A 80F7      1106       sjmp Print_String_RAM
0B3C           1107   Print_String_Done:
0B3C 22        1108       ret
0B3D           1109   
0B3D           1110   ; --- Clear Screen with hardware delay ---
0B3D           1111   Clear_Screen_Func:
0B3D 7401      1112            mov a, #0x01
0B3F 120794    1112            lcall ?WriteCommand        ; Clear display command
0B42 C002      1113            push AR2
0B44 7A02      1113            mov R2, #2
0B46 12074A    1113            lcall ?Wait_Milli_Seconds
0B49 D002      1113            pop AR2     ; LCD needs ~2ms to clear
0B4B 740C      1114            mov a, #0x0C
0B4D 120794    1114            lcall ?WriteCommand        ; Display ON, Cursor OFF
0B50 22        1115       ret
0B51           1116   
0B51           1117   Get_Current_Buffer_Addr:
0B51 E561      1118       mov A, Current_State
0B53 B40103    1119       cjne A, #1, Get_Buf_2
0B56 7880      1120       mov R0, #Buf_Soak_Temp
0B58 22        1121       ret
0B59           1122   Get_Buf_2:
0B59 B40203    1123       cjne A, #2, Get_Buf_3
0B5C 7884      1124       mov R0, #Buf_Soak_Time
0B5E 22        1125       ret
0B5F           1126   Get_Buf_3:
0B5F B40303    1127       cjne A, #3, Get_Buf_4
0B62 7889      1128       mov R0, #Buf_Refl_Temp
0B64 22        1129       ret
0B65           1130   Get_Buf_4:
0B65 788D      1131       mov R0, #Buf_Refl_Time
0B67 22        1132       ret
0B68           1133   
0B68           1134   ;-------------------------------------------------------------------------------
0B68           1135   ; Update HEX2-HEX0 with temperature (3 digits)
0B68           1136   ;-------------------------------------------------------------------------------
0B68           1137   Update_HEX_Temp:
0B68 9007F4    1138       mov dptr, #T_7seg
0B6B           1139       ; Hundreds -> HEX2
0B6B E543      1140       mov a, bcd+1
0B6D 540F      1141       anl a, #0x0F
0B6F 93        1142       movc a, @a+dptr
0B70 F593      1143       mov HEX2, a
0B72           1144       ; Tens -> HEX1
0B72 E542      1145       mov a, bcd+0
0B74 C4        1146       swap a
0B75 540F      1147       anl a, #0x0F
0B77 93        1148       movc a, @a+dptr
0B78 F592      1149       mov HEX1, a
0B7A           1150       ; Ones -> HEX0
0B7A E542      1151       mov a, bcd+0
0B7C 540F      1152       anl a, #0x0F
0B7E 93        1153       movc a, @a+dptr
0B7F F591      1154       mov HEX0, a
0B81 22        1155       ret
0B82           1156       
0B82           1157   ;---------------------------------------------------------
0B82           1158   PB0_DEB:
0B82           1159   ;non-blocking state machine for PB0 debounce
0B82 E572      1160       mov a, PB0_DEB_state
0B84           1161   PB0_DEB_state0:
0B84 B4000A    1162       cjne a, #0, PB0_DEB_state1
0B87 20902F    1163       jb PB0, PB0_DEB_done
0B8A 757100    1164       mov PB0_DEB_timer, #0
0B8D 0572      1165       inc PB0_DEB_state
0B8F 8028      1166       sjmp PB0_DEB_done
0B91           1167   PB0_DEB_state1:
0B91 B40109    1168       cjne a, #1, PB0_DEB_state2
0B94           1169       ; this is the debounce state
0B94 E571      1170       mov a, PB0_DEB_timer
0B96 B43220    1171       cjne a, #50, PB0_DEB_done ; 50 ms passed?
0B99 0572      1172       inc PB0_DEB_state
0B9B 801C      1173       sjmp PB0_DEB_done  
0B9D           1174   PB0_DEB_state2:
0B9D B4020C    1175       cjne a, #2, PB0_DEB_state3
0BA0 209004    1176       jb PB0, PB0_DEB_state2b
0BA3 0572      1177       inc PB0_DEB_state
0BA5 8012      1178       sjmp PB0_DEB_done  
0BA7           1179   PB0_DEB_state2b:
0BA7 757200    1180       mov PB0_DEB_state, #0
0BAA 800D      1181       sjmp PB0_DEB_done
0BAC           1182   PB0_DEB_state3:
0BAC B4030A    1183       cjne a, #3, PB0_DEB_done
0BAF 309007    1184       jnb PB0, PB0_DEB_done
0BB2 D215      1185       setb PB0_flag ; Suscesfully detected a valid PB0 press/release
0BB4 B2ED      1186            cpl LEDRA.5
0BB6 757200    1187       mov PB0_DEB_state, #0  
0BB9           1188   PB0_DEB_done:
0BB9 22        1189       ret
0BBA           1190   
0BBA           1191   PB2_DEB:
0BBA           1192   ;non-blocking state machine for PB2 debounce
0BBA E574      1193       mov a, PB2_DEB_state
0BBC           1194   PB2_DEB_state0:
0BBC B4000A    1195       cjne a, #0, PB2_DEB_state1
0BBF 20B72D    1196       jb PB2, PB2_DEB_done
0BC2 757300    1197       mov PB2_DEB_timer, #0
0BC5 0574      1198       inc PB2_DEB_state
0BC7 8026      1199       sjmp PB2_DEB_done
0BC9           1200   PB2_DEB_state1:
0BC9 B40109    1201       cjne a, #1, PB2_DEB_state2
0BCC           1202       ; this is the debounce state
0BCC E573      1203       mov a, PB2_DEB_timer
0BCE B4321E    1204       cjne a, #50, PB2_DEB_done ; 50 ms passed?
0BD1 0574      1205       inc PB2_DEB_state
0BD3 801A      1206       sjmp PB2_DEB_done  
0BD5           1207   PB2_DEB_state2:
0BD5 B4020C    1208       cjne a, #2, PB2_DEB_state3
0BD8 20B704    1209       jb PB2, PB2_DEB_state2b
0BDB 0574      1210       inc PB2_DEB_state
0BDD 8010      1211       sjmp PB2_DEB_done  
0BDF           1212   PB2_DEB_state2b:
0BDF 757400    1213       mov PB2_DEB_state, #0
0BE2 800B      1214       sjmp PB2_DEB_done
0BE4           1215   PB2_DEB_state3:
0BE4 B40308    1216       cjne a, #3, PB2_DEB_done
0BE7 30B705    1217       jnb PB2, PB2_DEB_done
0BEA D217      1218       setb PB2_flag ; Suscesfully detected a valid PB2 press/release
0BEC 757400    1219       mov PB2_DEB_state, #0  
0BEF           1220   PB2_DEB_done:
0BEF 22        1221       ret
0BF0           1222   
0BF0           1223   ; ------------------------------------------------------------------------------
0BF0           1224   ; Non-blocking FSM for the one second counter
0BF0           1225   ;-------------------------------------------------------------------------------
0BF0           1226   SEC_FSM:
0BF0 E570      1227       mov a, SEC_FSM_state
0BF2           1228   SEC_FSM_state0:
0BF2 B4000C    1229       cjne a, #0, SEC_FSM_state1
0BF5 E56F      1230       mov a, SEC_FSM_timer
0BF7 B4FA51    1231       cjne a, #250, SEC_FSM_done
0BFA 756F00    1232       mov SEC_FSM_timer, #0
0BFD 0570      1233       inc SEC_FSM_state
0BFF 804A      1234       sjmp SEC_FSM_done
0C01           1235   SEC_FSM_state1:  
0C01 B4010E    1236       cjne a, #1, SEC_FSM_state2
0C04 D2E9      1237       setb LEDRA.1
0C06 E56F      1238       mov a, SEC_FSM_timer
0C08 B4FA40    1239       cjne a, #250, SEC_FSM_done
0C0B 756F00    1240       mov SEC_FSM_timer, #0
0C0E 0570      1241       inc SEC_FSM_state
0C10 8039      1242       sjmp SEC_FSM_done
0C12           1243   SEC_FSM_state2:  
0C12 B4020E    1244       cjne a, #2, SEC_FSM_state3
0C15 D2EA      1245       setb LEDRA.2
0C17 E56F      1246       mov a, SEC_FSM_timer
0C19 B4FA2F    1247       cjne a, #250, SEC_FSM_done
0C1C 756F00    1248       mov SEC_FSM_timer, #0
0C1F 0570      1249       inc SEC_FSM_state
0C21 8028      1250       sjmp SEC_FSM_done
0C23           1251   SEC_FSM_state3:  
0C23 B40325    1252       cjne a, #3, SEC_FSM_done
0C26 D2EB      1253       setb LEDRA.3
0C28 E56F      1254       mov a, SEC_FSM_timer
0C2A B4FA1E    1255       cjne a, #250, SEC_FSM_done
0C2D 756F00    1256       mov SEC_FSM_timer, #0
0C30 757000    1257       mov SEC_FSM_state, #0
0C33           1258       
0C33           1259       ; These flags are always set (global use)
0C33 D204      1260       setb one_second_lcd_flag
0C35 D201      1261       setb one_second_flag
0C37           1262       
0C37           1263       ; Heartbeat LED always toggles
0C37 B2E8      1264       cpl LEDRA.0
0C39           1265       
0C39           1266       ; Only update time if counting is enabled
0C39 300D0F    1267       jnb time_count_doing_signal, SEC_FSM_done
0C3C           1268       
0C3C           1269       ; Update current time (only when counting)
0C3C E530      1270       mov a, current_time_sec
0C3E 04        1271       inc a
0C3F B43C07    1272       cjne a, #60, SEC_NoMinuteCarry
0C42 753000    1273       mov current_time_sec, #0
0C45 0531      1274       inc current_time_minute
0C47 8002      1275       sjmp SEC_FSM_done
0C49           1276   SEC_NoMinuteCarry:
0C49 F530      1277       mov current_time_sec, a
0C4B           1278   SEC_FSM_done:
0C4B 22        1279       ret
0C4C           1280   
0C4C           1281   ; ------------------------------------------------------------------------------
0C4C           1282   ; Counting the processing time 
0C4C           1283   ;-------------------------------------------------------------------------------
0C4C           1284   Time_Counter:
0C4C C0E0      1285       push ACC
0C4E C0D0      1286       push psw
0C50 E560      1287       mov a, Control_FSM_state
0C52           1288       
0C52           1289       ; State 2: Start counting
0C52 B4020F    1290       cjne a, #2, Time_Counter_Nstate2
0C55 101102    1291       jbc state_change_signal_Count, Time_Counter_Start
0C58 800F      1292       sjmp Time_Counter_Done
0C5A           1293   
0C5A           1294   Time_Counter_Start:
0C5A 753000    1295       mov current_time_sec, #0
0C5D 753100    1296       mov current_time_minute, #0
0C60 D20D      1297       setb time_count_doing_signal
0C62 8005      1298       sjmp Time_Counter_Done
0C64           1299   
0C64           1300   Time_Counter_Nstate2:
0C64           1301       ; State 6: Stop counting
0C64 B40602    1302       cjne a, #6, Time_Counter_Done
0C67 C20D      1303       clr time_count_doing_signal
0C69           1304   
0C69           1305   Time_Counter_Done:
0C69 D0D0      1306       pop psw
0C6B D0E0      1307       pop ACC
0C6D 22        1308       ret
0C6E           1309   
0C6E           1310   
0C6E           1311   ;-------------------------------------------------------------------------------
0C6E           1312   ; Time_Compare_MMSS
0C6E           1313   ;
0C6E           1314   ; PURPOSE:
0C6E           1315   ;   Compare elapsed time (current_time_minute:current_time_sec)
0C6E           1316   ;   against soak and reflow setpoints (soak_time_*, reflow_time_*).
0C6E           1317   ;
0C6E           1318   ; BEHAVIOR:
0C6E           1319   ;   - If current_time >= soak_end_time   then soak_time_reached = 1
0C6E           1320   ;   - If current_time >= reflow_end_time then reflow_time_reached = 1
0C6E           1321   ;
0C6E           1322   ; NOTES:
0C6E           1323   ;   Compare minutes first, then seconds.
0C6E           1324   ;-------------------------------------------------------------------------------
0C6E           1325   Time_Compare_MMSS:
0C6E C0E0      1326       push acc
0C70 C0D0      1327       push psw
0C72           1328   
0C72 E560      1329       mov a, Control_FSM_state
0C74 B4032E    1330       cjne a, #3, TC_Not_Soak
0C77           1331   
0C77           1332   ; ============================================================
0C77           1333   ; STATE 3: SOAK TIME COMPARISON
0C77           1334   ; ============================================================
0C77 101002    1335       jbc state_change_signal_TC, TC_Soak_Start_Record
0C7A 8015      1336       sjmp TC_Soak_Comparing
0C7C           1337   
0C7C           1338   TC_Soak_Start_Record:
0C7C           1339       ; Calculate end time = current_time + soak_time
0C7C E531      1340       mov a, current_time_minute
0C7E 2533      1341       add a, soak_time_minute
0C80 F537      1342       mov soak_end_time_minute, a
0C82           1343   
0C82 E530      1344       mov a, current_time_sec
0C84 2532      1345       add a, soak_time_sec
0C86 F536      1346       mov soak_end_time_sec, a
0C88           1347   
0C88           1348       ; Check for seconds overflow (>= 60)
0C88 C3        1349       clr c
0C89 943C      1350       subb a, #60
0C8B 4004      1351       jc TC_Soak_Comparing           ; No overflow, skip adjustment
0C8D           1352   
0C8D           1353       ; Overflow: adjust seconds and add 1 to minutes
0C8D F536      1354       mov soak_end_time_sec, a
0C8F 0537      1355       inc soak_end_time_minute
0C91           1356   
0C91           1357   TC_Soak_Comparing:
0C91           1358       ; Compare minutes first
0C91 E531      1359       mov  a, current_time_minute
0C93 C3        1360       clr  c
0C94 9537      1361       subb a, soak_end_time_minute
0C96 403E      1362       jc   TC_Done                   ; current_min < end_min -> not reached
0C98 7007      1363       jnz  TC_Soak_Reached           ; current_min > end_min -> reached
0C9A           1364   
0C9A           1365       ; Minutes equal -> compare seconds
0C9A E530      1366       mov  a, current_time_sec
0C9C C3        1367       clr  c
0C9D 9536      1368       subb a, soak_end_time_sec
0C9F 4035      1369       jc   TC_Done                   ; current_sec < end_sec -> not reached
0CA1           1370                                      ; current_sec >= end_sec -> fall through to reached
0CA1           1371   
0CA1           1372   TC_Soak_Reached:
0CA1 D208      1373       setb soak_time_reached
0CA3 8031      1374       sjmp TC_Done
0CA5           1375   
0CA5           1376   ; ============================================================
0CA5           1377   ; STATE 5: REFLOW TIME COMPARISON
0CA5           1378   ; ============================================================
0CA5           1379   TC_Not_Soak:
0CA5 E560      1380       mov a, Control_FSM_state
0CA7 B4052C    1381       cjne a, #5, TC_Done
0CAA           1382   
0CAA 101002    1383       jbc state_change_signal_TC, TC_Reflow_Start_Record
0CAD 8015      1384       sjmp TC_Reflow_Comparing
0CAF           1385   
0CAF           1386   TC_Reflow_Start_Record:
0CAF           1387       ; Calculate end time = current_time + reflow_time
0CAF E531      1388       mov a, current_time_minute
0CB1 2535      1389       add a, reflow_time_minute
0CB3 F539      1390       mov reflow_end_time_minute, a
0CB5           1391   
0CB5 E530      1392       mov a, current_time_sec
0CB7 2534      1393       add a, reflow_time_sec
0CB9 F538      1394       mov reflow_end_time_sec, a
0CBB           1395   
0CBB           1396       ; Check for seconds overflow (>= 60)
0CBB C3        1397       clr c
0CBC 943C      1398       subb a, #60
0CBE 4004      1399       jc TC_Reflow_Comparing         ; No overflow, skip adjustment
0CC0           1400   
0CC0           1401       ; Overflow: adjust seconds and add 1 to minutes
0CC0 F538      1402       mov reflow_end_time_sec, a
0CC2 0539      1403       inc reflow_end_time_minute
0CC4           1404   
0CC4           1405   TC_Reflow_Comparing:
0CC4           1406       ; Compare minutes first
0CC4 E531      1407       mov  a, current_time_minute
0CC6 C3        1408       clr  c
0CC7 9539      1409       subb a, reflow_end_time_minute
0CC9 400B      1410       jc   TC_Done                   ; current_min < end_min -> not reached
0CCB 7007      1411       jnz  TC_Reflow_Reached         ; current_min > end_min -> reached
0CCD           1412   
0CCD           1413       ; Minutes equal -> compare seconds
0CCD E530      1414       mov  a, current_time_sec
0CCF C3        1415       clr  c
0CD0 9538      1416       subb a, reflow_end_time_sec
0CD2 4002      1417       jc   TC_Done                   ; current_sec < end_sec -> not reached
0CD4           1418                                      ; current_sec >= end_sec -> fall through to reached
0CD4           1419   
0CD4           1420   TC_Reflow_Reached:
0CD4 D209      1421       setb reflow_time_reached
0CD6           1422   
0CD6           1423   TC_Done:
0CD6 D0D0      1424       pop  psw
0CD8 D0E0      1425       pop  acc
0CDA 22        1426       ret
0CDB           1427   
0CDB           1428   ;-------------------------------------------------------------------------------;
0CDB           1429   ; Temp_Compare
0CDB           1430   ; Checks if we have reached the user's target temperatures.
0CDB           1431   ; Only compares relevant temperature based on current Control_FSM_state:
0CDB           1432   ;   State 2: Sets 'soak_temp_reached' if current_temp >= soak_temp
0CDB           1433   ;   State 4: Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0CDB           1434   ;   State 6: Sets 'cooling_temp_reached' if current_temp < 100C
0CDB           1435   ;-------------------------------------------------------------------------------;
0CDB           1436   Temp_Compare:
0CDB C0E0      1437       push acc
0CDD C0D0      1438       push psw
0CDF C000      1439       push AR0
0CE1 C001      1440       push AR1
0CE3 C002      1441       push AR2
0CE5           1442       
0CE5 E560      1443       mov a, Control_FSM_state
0CE7           1444       
0CE7           1445       ; --- CHECK STATE 2: SOAK TEMP ---
0CE7 B40202    1446       cjne a, #2, Temp_Compare_Check_State4
0CEA 800A      1447       sjmp Check_Soak_Threshold
0CEC           1448       
0CEC           1449   Temp_Compare_Check_State4:
0CEC           1450       ; --- CHECK STATE 4: REFLOW TEMP ---
0CEC B40402    1451       cjne a, #4, Temp_Compare_Check_State6
0CEF 801D      1452       sjmp Check_Reflow_Threshold
0CF1           1453       
0CF1           1454   Temp_Compare_Check_State6:
0CF1           1455       ; --- CHECK STATE 6: COOLING TEMP ---
0CF1 B4064D    1456       cjne a, #6, Temp_Compare_Done
0CF4 8030      1457       sjmp Check_Cooling_Threshold
0CF6           1458   
0CF6           1459   Check_Soak_Threshold:
0CF6           1460       ; Copy current_temp to X
0CF6 7847      1461       mov R0, #current_temp
0CF8 793A      1462       mov R1, #x
0CFA 120D4C    1463       lcall Copy4_Bytes_R0_to_R1
0CFD           1464   
0CFD           1465       ; Copy soak_temp to Y
0CFD 784B      1466       mov R0, #soak_temp
0CFF 793E      1467       mov R1, #y
0D01 120D4C    1468       lcall Copy4_Bytes_R0_to_R1
0D04           1469   
0D04           1470       ; Compare: Is X (Current) < Y (Target)?
0D04 12011A    1471       lcall x_lt_y
0D07 200037    1472       jb mf, Temp_Compare_Done          ; If Current < Target, not reached yet
0D0A           1473       
0D0A           1474       ; If Current >= Target
0D0A D205      1475       setb soak_temp_reached
0D0C 8033      1476       sjmp Temp_Compare_Done
0D0E           1477   
0D0E           1478   Check_Reflow_Threshold:
0D0E           1479       ; Copy current_temp to X
0D0E 7847      1480       mov R0, #current_temp
0D10 793A      1481       mov R1, #x
0D12 120D4C    1482       lcall Copy4_Bytes_R0_to_R1
0D15           1483   
0D15           1484       ; Copy reflow_temp to Y
0D15 784F      1485       mov R0, #reflow_temp
0D17 793E      1486       mov R1, #y
0D19 120D4C    1487       lcall Copy4_Bytes_R0_to_R1
0D1C           1488   
0D1C           1489       ; Compare
0D1C 12011A    1490       lcall x_lt_y
0D1F 20001F    1491       jb mf, Temp_Compare_Done          ; If Current < Target, not reached yet
0D22           1492       
0D22           1493       ; If Current >= Target
0D22 D206      1494       setb reflow_temp_reached
0D24 801B      1495       sjmp Temp_Compare_Done
0D26           1496   
0D26           1497   Check_Cooling_Threshold:
0D26           1498       ; Copy current_temp to X
0D26 7847      1499       mov R0, #current_temp
0D28 793A      1500       mov R1, #x
0D2A 120D4C    1501       lcall Copy4_Bytes_R0_to_R1
0D2D           1502       
0D2D 753E64    1503            mov y+0, #low (100 % 0x10000) 
0D30 753F00    1503            mov y+1, #high(100 % 0x10000) 
0D33 754000    1503            mov y+2, #low (100 / 0x10000) 
0D36 754100    1503            mov y+3, #high(100 / 0x10000)                         ; Cooling target = 100C
0D39 12011A    1504       lcall x_lt_y
0D3C 300002    1505       jnb mf, Temp_Compare_Done         ; If temp >= 100, not cooled yet
0D3F           1506       
0D3F           1507       ; If Current < 100C
0D3F D207      1508       setb cooling_temp_reached
0D41           1509   
0D41           1510   ; ---------------------------------------------------------
0D41           1511   Temp_Compare_Done:
0D41 D002      1512       pop AR2
0D43 D001      1513       pop AR1
0D45 D000      1514       pop AR0
0D47 D0D0      1515       pop psw
0D49 D0E0      1516       pop acc
0D4B 22        1517       ret
0D4C           1518   
0D4C           1519   ;-------------------------------------------------------------------------------;
0D4C           1520   ; Copy4_Bytes_R0_to_R1
0D4C           1521   ;
0D4C           1522   ; PURPOSE:
0D4C           1523   ;   Utility routine to copy a 32-bit value (4 bytes)
0D4C           1524   ;   from one memory location to another.
0D4C           1525   ;
0D4C           1526   ; INPUTS:
0D4C           1527   ;   R0 st source address
0D4C           1528   ;   R1 at destination address
0D4C           1529   ;
0D4C           1530   ; USES:
0D4C           1531   ;   R2 as loop counter
0D4C           1532   ;
0D4C           1533   ; EXAMPLE:
0D4C           1534   ;   mov R0, #current_temp
0D4C           1535   ;   mov R1, #x
0D4C           1536   ;   lcall Copy4_Bytes_R0_to_R1
0D4C           1537   ;-------------------------------------------------------------------------------;
0D4C           1538   Copy4_Bytes_R0_to_R1:
0D4C 7A04      1539       mov  R2, #4
0D4E           1540   Copy4_Loop:
0D4E E6        1541       mov  a, @R0
0D4F F7        1542       mov  @R1, a
0D50 08        1543       inc  R0
0D51 09        1544       inc  R1
0D52 DAFA      1545       djnz R2, Copy4_Loop
0D54 22        1546       ret
0D55           1547   
0D55           1548   ;-------------------------------------------------------------------------------
0D55           1549   ; PWM
0D55           1550   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0D55           1551   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0D55           1552   ; ------------------------------------------------------------------------------
0D55           1553   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0D55 100202    1554       jbc one_ms_pwm_flag, pwm_wave_generator
0D58 8071      1555       sjmp end_pwm_generator
0D5A           1556   
0D5A           1557   pwm_wave_generator:
0D5A C200      1558       clr mf
0D5C           1559       ; move pwm counter value into x for comparison purpose
0D5C 855C3A    1560       mov x, pwm_counter
0D5F 855D3B    1561       mov x+1, pwm_counter+1
0D62 855E3C    1562       mov x+2, pwm_counter+2
0D65 855F3D    1563       mov x+3, pwm_counter+3
0D68           1564   
0D68 753EDB    1565            mov y+0, #low (PWM_PERIOD % 0x10000) 
0D6B 753F05    1565            mov y+1, #high(PWM_PERIOD % 0x10000) 
0D6E 754000    1565            mov y+2, #low (PWM_PERIOD / 0x10000) 
0D71 754100    1565            mov y+3, #high(PWM_PERIOD / 0x10000) 
0D74           1566   
0D74           1567       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0D74           1568       ; increase x by 1
0D74 120152    1569       lcall x_eq_y 
0D77 20001D    1570       jb mf, wrap_pwm_counter
0D7A           1571       ; x not equal 1499, increment by 1
0D7A 753E01    1572            mov y+0, #low (1 % 0x10000) 
0D7D 753F00    1572            mov y+1, #high(1 % 0x10000) 
0D80 754000    1572            mov y+2, #low (1 / 0x10000) 
0D83 754100    1572            mov y+3, #high(1 / 0x10000) 
0D86 1200D3    1573       lcall add32
0D89           1574       ; update pwm_counter
0D89 853A5C    1575       mov pwm_counter, x
0D8C 853B5D    1576       mov pwm_counter+1, x+1
0D8F 853C5E    1577       mov pwm_counter+2, x+2
0D92 853D5F    1578       mov pwm_counter+3, x+3
0D95 8018      1579       sjmp set_pwm
0D97           1580   
0D97           1581   wrap_pwm_counter:
0D97           1582       ; x equal 1499, wrap to 0
0D97 753A00    1583            mov x+0, #low (0 % 0x10000) 
0D9A 753B00    1583            mov x+1, #high(0 % 0x10000) 
0D9D 753C00    1583            mov x+2, #low (0 / 0x10000) 
0DA0 753D00    1583            mov x+3, #high(0 / 0x10000) 
0DA3 853A5C    1584       mov pwm_counter, x
0DA6 853B5D    1585       mov pwm_counter+1, x+1
0DA9 853C5E    1586       mov pwm_counter+2, x+2
0DAC 853D5F    1587       mov pwm_counter+3, x+3
0DAF           1588   
0DAF           1589   set_pwm:
0DAF           1590       ; compare with power_output, if pwm counter smaller than power_output, 
0DAF           1591       ; set pwm pin high; else set pwm pin low load y with power output value
0DAF 85583E    1592       mov y, power_output
0DB2 85593F    1593       mov y+1, power_output+1
0DB5 855A40    1594       mov y+2, power_output+2
0DB8 855B41    1595       mov y+3, power_output+3
0DBB           1596   
0DBB           1597       ; compare x(pwm counter) with y(power output)
0DBB 12011A    1598       lcall x_lt_y
0DBE 200006    1599       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
0DC1           1600       ;output set pwm pin low if pwm counter greater than power output
0DC1 C293      1601       clr PWM_OUT
0DC3 C2EC      1602       clr LEDRA.4
0DC5 8004      1603       sjmp end_pwm_generator
0DC7           1604   
0DC7           1605   set_pwm_high:
0DC7 D293      1606       setb PWM_OUT
0DC9 D2EC      1607       setb LEDRA.4
0DCB           1608   
0DCB           1609   end_pwm_generator:
0DCB 22        1610       ret
0DCC           1611   
0DCC           1612   ;-------------------------------------------------------------------------------
0DCC           1613   
0DCC           1614   ;-------------------------------------------------------------------------------;
0DCC           1615   ; Abort condition safety check Temperature time
0DCC           1616   ;
0DCC           1617   ; PURPOSE:
0DCC           1618   ;   Automatic cycle termination on error:
0DCC           1619   ;   Abort if oven fails to reach at least 50C in first 60s (1 minute).
0DCC           1620   ;
0DCC           1621   ; TRIP CONDITION:
0DCC           1622   ;   if (current_time_minute >= 1) AND (current_temp < 50C)
0DCC           1623   ;       -> set tc_missing_abort
0DCC           1624   ;       -> set stop_signal
0DCC           1625   ;
0DCC           1626   ; ASSUMPTIONS:
0DCC           1627   ;   - current_time_sec (byte): seconds 0-59
0DCC           1628   ;   - current_time_minute (byte): minutes counter
0DCC           1629   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0DCC           1630   ;-------------------------------------------------------------------------------;
0DCC           1631   Safety_Check_TC:
0DCC C0E0      1632       push acc
0DCE C0D0      1633       push psw
0DD0 C000      1634       push AR0
0DD2 C001      1635       push AR1
0DD4           1636   
0DD4           1637       ; ---------------------------------------------------------
0DD4           1638       ; GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0DD4           1639       ; ---------------------------------------------------------
0DD4 E560      1640       mov a, Control_FSM_state
0DD6 B40202    1641       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0DD9 8003      1642       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0DDB           1643   
0DDB           1644   Safety_TC_Exit_Bridge:
0DDB 020E11    1645       ljmp Safety_TC_Done               ; Jump to the end
0DDE           1646   
0DDE           1647   Safety_Logic_Proceed:
0DDE           1648       ; If already aborted or startup window closed, do nothing
0DDE 201330    1649       jb   tc_missing_abort, Safety_TC_Done
0DE1 30142D    1650       jnb  tc_startup_window, Safety_TC_Done
0DE4           1651   
0DE4           1652       ; Check: current_time_minute >= 1 ? (has 1 minute passed?)
0DE4 E531      1653       mov  a, current_time_minute
0DE6 6029      1654       jz   Safety_TC_Done               ; minute == 0, still waiting
0DE8           1655   
0DE8           1656       ; We reached 1 minute: close the startup window so it won't re-check later
0DE8 C214      1657       clr  tc_startup_window
0DEA           1658   
0DEA           1659       ; Now check: current_temp < 50 ?
0DEA 7847      1660       mov  R0, #current_temp
0DEC 793A      1661       mov  R1, #x
0DEE 120D4C    1662       lcall Copy4_Bytes_R0_to_R1
0DF1           1663   
0DF1 753E32    1664            mov y+0, #low (50 % 0x10000) 
0DF4 753F00    1664            mov y+1, #high(50 % 0x10000) 
0DF7 754000    1664            mov y+2, #low (50 / 0x10000) 
0DFA 754100    1664            mov y+3, #high(50 / 0x10000) 
0DFD 12011A    1665       lcall x_lt_y
0E00 30000E    1666       jnb  mf, Safety_TC_Done           ; temp >= 50  pass
0E03           1667   
0E03           1668       ; FAIL: at 1 minute, still below 50C  abort
0E03 C293      1669       clr  PWM_OUT
0E05 D213      1670       setb tc_missing_abort
0E07 D20B      1671       setb stop_signal
0E09           1672       
0E09           1673       ; Force FSM to State 0 (Welcome)
0E09 756000    1674       mov Control_FSM_state, #0
0E0C           1675       
0E0C           1676       ; Force UI to State 0 (Home Screen)
0E0C 756100    1677       mov Current_State, #0
0E0F           1678       
0E0F           1679       ; Trigger Screen Refresh
0E0F D20F      1680       setb state_change_signal          ; Tell loop to redraw "Welcome"
0E11           1681   
0E11           1682   Safety_TC_Done:
0E11 D001      1683       pop  AR1
0E13 D000      1684       pop  AR0
0E15 D0D0      1685       pop  psw
0E17 D0E0      1686       pop  acc
0E19 22        1687       ret
0E1A           1688   
0E1A           1689   ; ============================================================
0E1A           1690   ; BUZZER STARTUP FUNCTIONS
0E1A           1691   ; ============================================================
0E1A           1692   ;============================================================
0E1A           1693   ; Beep_Judge
0E1A           1694   ; Purpose: Trigger appropriate beep pattern based on events
0E1A           1695   ;   - Beep once when state changes
0E1A           1696   ;   - Beep five times when entering state 6 (cooling/finished)
0E1A           1697   ;   - Beep ten times if tc_missing_abort = 1 (error)
0E1A           1698   ;
0E1A           1699   ; Call this in main loop after Control_FSM
0E1A           1700   ;============================================================
0E1A           1701   Beep_Judge:
0E1A C0E0      1702       push acc
0E1C C0D0      1703       push psw
0E1E           1704   
0E1E           1705       ; --- Priority 1: Error condition (highest priority) ---
0E1E 30130A    1706       jnb tc_missing_abort, Beep_Judge_Check_State6
0E21           1707       ; Error detected - beep 10 times (only once per error)
0E21 20191B    1708       jb beep_error_done, Beep_Judge_Done   ; Already beeped for this error?
0E24 D219      1709       setb beep_error_done                   ; Mark as handled
0E26 120E4E    1710       lcall Beep_Ten
0E29 8014      1711       sjmp Beep_Judge_Done
0E2B           1712   
0E2B           1713   Beep_Judge_Check_State6:
0E2B           1714       ; --- Priority 2: Entering State 6 (finished) ---
0E2B 301211    1715       jnb state_change_beep_signal, Beep_Judge_Done  ; No state change? Exit
0E2E           1716       
0E2E E560      1717       mov a, Control_FSM_state
0E30 B40607    1718       cjne a, #6, Beep_Judge_Normal_Change
0E33           1719       ; Entering state 6 - beep 5 times
0E33 C212      1720       clr state_change_beep_signal               ; Consume the signal
0E35 120E49    1721       lcall Beep_Five
0E38 8005      1722       sjmp Beep_Judge_Done
0E3A           1723   
0E3A           1724   Beep_Judge_Normal_Change:
0E3A           1725       ; --- Priority 3: Normal state change - beep once ---
0E3A C212      1726       clr state_change_beep_signal               ; Consume the signal
0E3C 120E44    1727       lcall Beep_Once
0E3F           1728   
0E3F           1729   Beep_Judge_Done:
0E3F D0D0      1730       pop psw
0E41 D0E0      1731       pop acc
0E43 22        1732       ret
0E44           1733   
0E44           1734   Beep_Once:
0E44 757501    1735       mov beep_count, #1
0E47 800A      1736       sjmp Beep_Start
0E49           1737   
0E49           1738   Beep_Five:
0E49 757505    1739       mov beep_count, #5
0E4C 8005      1740       sjmp Beep_Start
0E4E           1741   
0E4E           1742   Beep_Ten:
0E4E 75750A    1743       mov beep_count, #10
0E51 8000      1744       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0E53           1745   
0E53           1746   Beep_Start:
0E53 C28C      1747       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0E55 757601    1748       mov beep_state, #1   ; Set State to ON
0E58 757700    1749       mov beep_tmr, #0     ; Reset Timer High Byte
0E5B 757800    1750       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0E5E D2A9      1751       setb ET0             ; [FIX] Ensure Interrupt is enabled
0E60 D28C      1752       setb TR0             ; START the 2kHz tone
0E62 22        1753       ret
0E63           1754   ;-------------------------------------------------------------------------------
0E63           1755   ; Buzzer beep Task 
0E63           1756   ; Purpose: beeps, holds, stop
0E63           1757   ; Buzzer task:
0E63           1758   ; Beep once when state changes
0E63           1759   ; Beep five times if finished
0E63           1760   ; Beep ten times if meets error
0E63           1761   ;============================================================
0E63           1762   Beep_Task:
0E63 301835    1763       jnb one_ms_beep_flag, Beep_Done
0E66 C218      1764       clr one_ms_beep_flag
0E68           1765   
0E68 E576      1766       mov a, beep_state
0E6A 602F      1767       jz Beep_Done
0E6C           1768   
0E6C           1769   ; ---- increment 16-bit timer ----
0E6C 0577      1770       inc beep_tmr
0E6E E577      1771       mov a, beep_tmr
0E70 7002      1772       jnz Beep_Check
0E72 0578      1773       inc beep_tmr+1
0E74           1774   
0E74           1775   Beep_Check:
0E74           1776       ; FUZZY TIMER CHECK
0E74           1777       ; Check if High Byte is non-zero (Time >= 256ms)
0E74 E578      1778       mov a, beep_tmr+1
0E76 6023      1779       jz Beep_Done        ; If 0, keep beeping
0E78           1780   
0E78           1781       ; --- Time Limit Reached ---
0E78 757700    1782       mov beep_tmr, #0    ; Reset timer
0E7B 757800    1783       mov beep_tmr+1, #0
0E7E           1784   
0E7E E576      1785       mov a, beep_state
0E80 B40106    1786       cjne a, #1, Beep_Off_State
0E83           1787   
0E83           1788       ; State was 1 (ON) -> Turn OFF
0E83 C28C      1789       clr TR0             ; Hardware Silence
0E85 757602    1790       mov beep_state, #2  ; Set State to OFF (Pause)
0E88 22        1791       ret
0E89           1792   
0E89           1793   Beep_Off_State:
0E89           1794   ; ---- OFF finished -> decrement count / next ON ----
0E89 1575      1795       dec beep_count
0E8B E575      1796       mov a, beep_count
0E8D 6006      1797       jz  Beep_Stop
0E8F           1798   
0E8F 757601    1799       mov beep_state, #1
0E92 D28C      1800       setb TR0
0E94 22        1801       ret
0E95           1802   
0E95           1803   Beep_Stop:
0E95 C28C      1804       clr TR0
0E97 757600    1805       mov beep_state, #0
0E9A 22        1806       ret
0E9B           1807   
0E9B           1808   Beep_Done:
0E9B 22        1809       ret
0E9C           1810       
0E9C           1811   ;-------------------------------------------------------------------------------;
0E9C           1812   ; Main Control FSM for the entire process
0E9C           1813   ;-------------------------------------------------------------------------------;
0E9C           1814   Control_FSM:
0E9C E560      1815       mov a, Control_FSM_state
0E9E 8008      1816       sjmp Control_FSM_state0
0EA0           1817   
0EA0           1818   Control_FSM_state0_a:
0EA0 756000    1819            mov Control_FSM_state, #0
0EA3 D20F      1820            setb state_change_signal
0EA5 D210      1821            setb state_change_signal_TC
0EA7 22        1822            ret
0EA8           1823   Control_FSM_state0:
0EA8 B40017    1824       cjne a, #0, Control_FSM_state1
0EAB C219      1825       clr beep_error_done
0EAD 301504    1826       jnb PB0_flag, Control_FSM_state0_ret  ; Check flag
0EB0 C215      1827       clr PB0_flag                 
0EB2 8001      1828       sjmp Control_FSM_state1_a
0EB4           1829   Control_FSM_state0_ret:
0EB4 22        1830       ret
0EB5           1831   
0EB5           1832   Control_FSM_state1_a:
0EB5 756001    1833       mov Control_FSM_state, #1
0EB8 756100    1834       mov Current_State, #0
0EBB D20F      1835       setb state_change_signal
0EBD D210      1836            setb state_change_signal_TC
0EBF D212      1837       setb state_change_beep_signal
0EC1 22        1838            ret
0EC2           1839   Control_FSM_state1:
0EC2 B40116    1840       cjne a, #1, Control_FSM_state2
0EC5 301504    1841       jnb PB0_flag, Control_FSM_state1_ret  ; Check flag
0EC8 C215      1842       clr PB0_flag                    
0ECA 8001      1843       sjmp Control_FSM_state2_a
0ECC           1844   Control_FSM_state1_ret:
0ECC 22        1845       ret
0ECD           1846   
0ECD           1847   ; --- STATE 2: RAMP TO SOAK ---
0ECD           1848   Control_FSM_state2_a:
0ECD 756002    1849            mov Control_FSM_state, #2
0ED0 D20F      1850            setb state_change_signal
0ED2 D210      1851            setb state_change_signal_TC
0ED4 D211      1852            setb state_change_signal_Count
0ED6 D212      1853       setb state_change_beep_signal
0ED8 C205      1854       clr soak_temp_reached
0EDA 22        1855            ret
0EDB           1856   Control_FSM_state2:
0EDB B4021C    1857       cjne a, #2, Control_FSM_state3
0EDE 301705    1858       jnb PB2_flag, State2_Check
0EE1 C217      1859       clr PB2_flag
0EE3 020F48    1860       ljmp Control_FSM_state6_a ; Pause
0EE6           1861   
0EE6           1862   State2_Check:
0EE6 300506    1863       jnb soak_temp_reached, State2_Ret
0EE9           1864       
0EE9           1865       ; --- Move to State 3 ---
0EE9 C205      1866       clr soak_temp_reached
0EEB C208      1867       clr soak_time_reached
0EED 8001      1868            sjmp Control_FSM_state3_a
0EEF           1869   State2_Ret:
0EEF 22        1870       ret
0EF0           1871   
0EF0           1872   ; --- STATE 3: SOAK PHASE ---
0EF0           1873   Control_FSM_state3_a:
0EF0 756003    1874            mov Control_FSM_state, #3
0EF3 D20F      1875            setb state_change_signal
0EF5 D210      1876            setb state_change_signal_TC
0EF7 D212      1877       setb state_change_beep_signal
0EF9 22        1878            ret
0EFA           1879   Control_FSM_state3:
0EFA B4031A    1880       cjne a, #3, Control_FSM_state4
0EFD 301705    1881       jnb PB2_flag, State3_Check
0F00 C217      1882       clr PB2_flag
0F02 020F48    1883       ljmp Control_FSM_state6_a
0F05           1884   State3_Check:
0F05 300804    1885       jnb soak_time_reached, State3_Ret
0F08 C208      1886       clr soak_time_reached
0F0A 8001      1887       sjmp Control_FSM_state4_a
0F0C           1888   State3_Ret:
0F0C 22        1889       ret
0F0D           1890   
0F0D           1891   ; --- STATE 4: RAMP TO PEAK ---
0F0D           1892   Control_FSM_state4_a:
0F0D 756004    1893            mov Control_FSM_state, #4
0F10 D20F      1894            setb state_change_signal
0F12 D210      1895            setb state_change_signal_TC
0F14 D212      1896       setb state_change_beep_signal
0F16 22        1897            ret
0F17           1898   Control_FSM_state4:
0F17 B4041C    1899       cjne a, #4, Control_FSM_state5
0F1A 301705    1900       jnb PB2_flag, State4_Check
0F1D C217      1901       clr PB2_flag
0F1F 020F48    1902       ljmp Control_FSM_state6_a
0F22           1903   State4_Check:
0F22 300606    1904       jnb reflow_temp_reached, State4_Ret
0F25 C206      1905       clr reflow_temp_reached
0F27 C209      1906       clr reflow_time_reached
0F29 8001      1907            sjmp Control_FSM_state5_a
0F2B           1908   State4_Ret:
0F2B 22        1909       ret
0F2C           1910   
0F2C           1911   ; --- STATE 5: REFLOW PHASE ---
0F2C           1912   Control_FSM_state5_a:
0F2C 756005    1913            mov Control_FSM_state, #5
0F2F D20F      1914            setb state_change_signal
0F31 D210      1915            setb state_change_signal_TC
0F33 D212      1916       setb state_change_beep_signal
0F35 22        1917            ret
0F36           1918   Control_FSM_state5:
0F36 B4051D    1919       cjne a, #5, Control_FSM_state6
0F39 301704    1920       jnb PB2_flag, State5_Check
0F3C C217      1921       clr PB2_flag
0F3E 8008      1922       sjmp Control_FSM_state6_a
0F40           1923   State5_Check:
0F40 300904    1924       jnb reflow_time_reached, State5_Ret
0F43 C209      1925       clr reflow_time_reached
0F45 8001      1926       sjmp Control_FSM_state6_a
0F47           1927   State5_Ret:
0F47 22        1928       ret
0F48           1929   
0F48           1930   ; --- STATE 6: COOLING ---
0F48           1931   Control_FSM_state6_a:
0F48 756006    1932            mov Control_FSM_state, #6
0F4B D20F      1933            setb state_change_signal
0F4D D210      1934            setb state_change_signal_TC
0F4F D211      1935            setb state_change_signal_Count
0F51 D212      1936       setb state_change_beep_signal
0F53 C207      1937       clr cooling_temp_reached
0F55 22        1938            ret
0F56           1939   Control_FSM_state6:
0F56 B40612    1940       cjne a, #6, Control_FSM_state7
0F59           1941       ; Wait for Cooling Temp Reached
0F59 300704    1942       jnb cooling_temp_reached, State6_Ret
0F5C C207      1943       clr cooling_temp_reached
0F5E 8001      1944       sjmp Control_FSM_state7_a
0F60           1945   State6_Ret:
0F60 22        1946       ret
0F61           1947   
0F61           1948   ; --- STATE 7: DONE ---
0F61           1949   Control_FSM_state7_a:
0F61 756007    1950            mov Control_FSM_state, #7
0F64 D20F      1951            setb state_change_signal
0F66 D210      1952            setb state_change_signal_TC
0F68 D212      1953       setb state_change_beep_signal
0F6A 22        1954            ret
0F6B           1955   Control_FSM_state7:
0F6B B40708    1956       cjne a, #7, Control_FSM_done
0F6E           1957       ; Let's assume you meant the physical button P1.0 like State 0
0F6E 101502    1958       jbc PB0_flag, Control_FSM_state7_pressed
0F71 8003      1959            sjmp Control_FSM_done
0F73           1960   Control_FSM_state7_pressed:
0F73 020EA0    1961       ljmp Control_FSM_state0_a
0F76           1962   
0F76           1963   Control_FSM_done:
0F76 22        1964       ret
0F77           1965   
0F77           1966   ; ================================================================
0F77           1967   ; UI & HELPER SUBROUTINES
0F77           1968   ; ================================================================
0F77           1969   
0F77           1970   ; ----------------------------------------------------------------
0F77           1971   ; MODULE: BRIDGE (Text to Integer Conversion)
0F77           1972   ; ----------------------------------------------------------------
0F77           1973   
0F77           1974   ;--------------------------
0F77           1975   ;keep updating varaibles
0F77           1976   Update_FSM_Variables:
0F77 C0E0      1977            push ACC
0F79 C006      1978            push AR6
0F7B C007      1979            push AR7
0F7D E560      1980            mov a, Control_FSM_state
0F7F B40132    1981            cjne a, #1, Update_FSM_Variables_done
0F82           1982   
0F82           1983       ; --- 1. SOAK TEMP ---
0F82 7880      1984       mov R0, #Buf_Soak_Temp
0F84 120FBB    1985       lcall Parse_Temp_String
0F87 8F4B      1986       mov soak_temp+0, R7
0F89 754C00    1987       mov soak_temp+1, #0
0F8C 754D00    1988       mov soak_temp+2, #0
0F8F 754E00    1989       mov soak_temp+3, #0
0F92           1990   
0F92           1991       ; --- 2. REFLOW TEMP ---
0F92 7889      1992       mov R0, #Buf_Refl_Temp
0F94 120FBB    1993       lcall Parse_Temp_String
0F97 8F4F      1994       mov reflow_temp+0, R7
0F99 755000    1995       mov reflow_temp+1, #0
0F9C 755100    1996       mov reflow_temp+2, #0
0F9F 755200    1997       mov reflow_temp+3, #0
0FA2           1998   
0FA2           1999       ; --- 3. SOAK TIME ---
0FA2 7884      2000       mov R0, #Buf_Soak_Time
0FA4 120FCF    2001       lcall Parse_Time_String
0FA7 8F33      2002       mov soak_time_minute, R7
0FA9 8E32      2003       mov soak_time_sec, R6
0FAB           2004   
0FAB           2005       ; --- 4. REFLOW TIME ---
0FAB 788D      2006       mov R0, #Buf_Refl_Time
0FAD 120FCF    2007       lcall Parse_Time_String
0FB0 8F35      2008       mov reflow_time_minute, R7
0FB2 8E34      2009       mov reflow_time_sec, R6
0FB4           2010   
0FB4           2011   Update_FSM_Variables_done:
0FB4 D007      2012            pop AR7
0FB6 D006      2013            pop AR6
0FB8 D0E0      2014            pop ACC
0FBA 22        2015       ret
0FBB           2016   ;--------------------------
0FBB           2017   
0FBB           2018   ; --- Helper: Parse "123" to Integer ---
0FBB           2019   Parse_Temp_String:
0FBB 7F00      2020       mov R7, #0              ; Clear Result
0FBD           2021   Parse_Temp_Loop:
0FBD E6        2022       mov A, @R0
0FBE 600E      2023       jz Parse_Temp_Done      ; If Null, we are done
0FC0           2024       
0FC0           2025       ; Convert ASCII to Digit
0FC0 C3        2026       clr C
0FC1 9430      2027       subb A, #0x30
0FC3 FD        2028       mov R5, A               ; R5 = New Digit
0FC4           2029       
0FC4           2030       ; Result = (Result * 10) + New Digit
0FC4 EF        2031       mov A, R7
0FC5 75F00A    2032       mov B, #10
0FC8 A4        2033       mul AB
0FC9 2D        2034       add A, R5
0FCA FF        2035       mov R7, A
0FCB           2036       
0FCB 08        2037       inc R0
0FCC 80EF      2038       sjmp Parse_Temp_Loop
0FCE           2039   Parse_Temp_Done:
0FCE 22        2040       ret
0FCF           2041   
0FCF           2042   ; --- Parse "MMSS" to ceconds ---
0FCF           2043   Parse_Time_String:
0FCF           2044       ; Minutes tens
0FCF E6        2045       mov A, @R0
0FD0 C3        2046       clr C
0FD1 9430      2047       subb A, #0x30
0FD3 75F00A    2048       mov B, #10
0FD6 A4        2049       mul AB
0FD7 FD        2050       mov R5, A
0FD8 08        2051       inc R0
0FD9           2052   
0FD9           2053       ; Minutes ones
0FD9 E6        2054       mov A, @R0
0FDA C3        2055       clr C
0FDB 9430      2056       subb A, #0x30
0FDD 2D        2057       add A, R5
0FDE FD        2058       mov R5, A
0FDF 08        2059       inc R0
0FE0           2060   
0FE0           2061       ; Seconds tens
0FE0 E6        2062       mov A, @R0
0FE1 C3        2063       clr C
0FE2 9430      2064       subb A, #0x30
0FE4 75F00A    2065       mov B, #10
0FE7 A4        2066       mul AB
0FE8 FC        2067       mov R4, A
0FE9 08        2068       inc R0
0FEA           2069   
0FEA           2070       ; Seconds ones
0FEA E6        2071       mov A, @R0
0FEB C3        2072       clr C
0FEC 9430      2073       subb A, #0x30
0FEE 2C        2074       add A, R4
0FEF FC        2075       mov R4, A
0FF0           2076   
0FF0           2077       ; Return minutes/seconds
0FF0 ED        2078            mov a, R5
0FF1 FF        2079       mov R7, a     ; minutes
0FF2 EC        2080            mov a, R4
0FF3 FE        2081       mov R6, a     ; seconds
0FF4 22        2082       ret
0FF5           2083   
0FF5           2084   ; ----------------------------------------------------------------
0FF5           2085   ; MODULE: BUTTON HANDLER (Mode Selection)
0FF5           2086   ; ----------------------------------------------------------------
0FF5           2087   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0FF5           2088   Wait_25ms_BLOCKING:
0FF5 1211D3    2089       lcall Wait_25ms
0FF8 50FB      2090       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0FFA 22        2091       ret
0FFB           2092   
0FFB           2093   ; ----------------------------------------------------------------
0FFB           2094   ; MODULE: BUTTON HANDLER (Non-Blocking Debounce)
0FFB           2095   ; ----------------------------------------------------------------
0FFB           2096   ; Variables needed:
0FFB           2097   ;   BTN_DEB_state   - state machine state (0-3)
0FFB           2098   ;   BTN_DEB_timer   - debounce timer (incremented by ISR every 1ms)
0FFB           2099   ;   BTN_DEB_id      - which button was pressed (1-4)
0FFB           2100   ; ----------------------------------------------------------------
0FFB           2101   
0FFB           2102   Check_Buttons:
0FFB C0E0      2103       push ACC
0FFD C0D0      2104       push PSW
0FFF           2105       
0FFF           2106       ; Only process in Control_FSM_state 1
0FFF E560      2107       mov a, Control_FSM_state
1001 B40107    2108       cjne a, #1, Check_Buttons_Done_bridge
1004           2109       
1004           2110       ; --- FORCE INPUT MODE ---
1004 438055    2111       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, P0.6 to '1' (Input Mode)
1007           2112       
1007 E57A      2113       mov a, BTN_DEB_state
1009 8003      2114       sjmp BTN_DEB_state0
100B           2115   
100B           2116   Check_Buttons_Done_bridge:
100B 0210B5    2117       ljmp Check_Buttons_Done
100E           2118   
100E           2119   ; ============================================================
100E           2120   ; State 0: Wait for any button press
100E           2121   ; ============================================================
100E           2122   BTN_DEB_state0:
100E B4002A    2123       cjne a, #0, BTN_DEB_state1
1011           2124       
1011           2125       ; Check each button, record which one was pressed
1011 30800C    2126       jnb BTN_SOAK_TEMP, BTN_Detect_SoakTemp
1014 30820E    2127       jnb BTN_SOAK_TIME, BTN_Detect_SoakTime
1017 308410    2128       jnb BTN_REFL_TEMP, BTN_Detect_ReflTemp
101A 308612    2129       jnb BTN_REFL_TIME, BTN_Detect_ReflTime
101D 0210B5    2130       ljmp Check_Buttons_Done     ; No button pressed
1020           2131   
1020           2132   BTN_Detect_SoakTemp:
1020 757C01    2133       mov BTN_DEB_id, #1
1023 800F      2134       sjmp BTN_Start_Debounce
1025           2135   BTN_Detect_SoakTime:
1025 757C02    2136       mov BTN_DEB_id, #2
1028 800A      2137       sjmp BTN_Start_Debounce
102A           2138   BTN_Detect_ReflTemp:
102A 757C03    2139       mov BTN_DEB_id, #3
102D 8005      2140       sjmp BTN_Start_Debounce
102F           2141   BTN_Detect_ReflTime:
102F 757C04    2142       mov BTN_DEB_id, #4
1032 8000      2143       sjmp BTN_Start_Debounce
1034           2144   
1034           2145   BTN_Start_Debounce:
1034 757B00    2146       mov BTN_DEB_timer, #0
1037 057A      2147       inc BTN_DEB_state
1039 807A      2148       sjmp Check_Buttons_Done
103B           2149   
103B           2150   ; ============================================================
103B           2151   ; State 1: Debounce delay (wait 50ms)
103B           2152   ; ============================================================
103B           2153   BTN_DEB_state1:
103B B40109    2154       cjne a, #1, BTN_DEB_state2
103E E57B      2155       mov a, BTN_DEB_timer
1040 B43272    2156       cjne a, #50, Check_Buttons_Done   ; Wait 50ms
1043 057A      2157       inc BTN_DEB_state
1045 806E      2158       sjmp Check_Buttons_Done
1047           2159   
1047           2160   ; ============================================================
1047           2161   ; State 2: Verify button still pressed
1047           2162   ; ============================================================
1047           2163   BTN_DEB_state2:
1047 B40226    2164       cjne a, #2, BTN_DEB_state3
104A           2165       
104A           2166       ; Check if the same button is still pressed
104A E57C      2167       mov a, BTN_DEB_id
104C B40105    2168       cjne a, #1, BTN_Verify_Check2
104F 30801A    2169       jnb BTN_SOAK_TEMP, BTN_Verify_OK
1052 8013      2170       sjmp BTN_Verify_Fail
1054           2171   BTN_Verify_Check2:
1054 B40205    2172       cjne a, #2, BTN_Verify_Check3
1057 308212    2173       jnb BTN_SOAK_TIME, BTN_Verify_OK
105A 800B      2174       sjmp BTN_Verify_Fail
105C           2175   BTN_Verify_Check3:
105C B40305    2176       cjne a, #3, BTN_Verify_Check4
105F 30840A    2177       jnb BTN_REFL_TEMP, BTN_Verify_OK
1062 8003      2178       sjmp BTN_Verify_Fail
1064           2179   BTN_Verify_Check4:
1064 308605    2180       jnb BTN_REFL_TIME, BTN_Verify_OK
1067           2181       ; Fall through to fail
1067           2182   
1067           2183   BTN_Verify_Fail:
1067 757A00    2184       mov BTN_DEB_state, #0           ; Was noise, reset
106A 8049      2185       sjmp Check_Buttons_Done
106C           2186   
106C           2187   BTN_Verify_OK:
106C 057A      2188       inc BTN_DEB_state               ; Confirmed, wait for release
106E 8045      2189       sjmp Check_Buttons_Done
1070           2190   
1070           2191   ; ============================================================
1070           2192   ; State 3: Wait for button release, then trigger action
1070           2193   ; ============================================================
1070           2194   BTN_DEB_state3:
1070 B40342    2195       cjne a, #3, Check_Buttons_Done
1073           2196       
1073           2197       ; Check if the button is released
1073 E57C      2198       mov a, BTN_DEB_id
1075 B40105    2199       cjne a, #1, BTN_Release_Check2
1078 30803A    2200       jnb BTN_SOAK_TEMP, Check_Buttons_Done   ; Still pressed, wait
107B 8013      2201       sjmp BTN_Do_Action
107D           2202   BTN_Release_Check2:
107D B40205    2203       cjne a, #2, BTN_Release_Check3
1080 308232    2204       jnb BTN_SOAK_TIME, Check_Buttons_Done
1083 800B      2205       sjmp BTN_Do_Action
1085           2206   BTN_Release_Check3:
1085 B40305    2207       cjne a, #3, BTN_Release_Check4
1088 30842A    2208       jnb BTN_REFL_TEMP, Check_Buttons_Done
108B 8003      2209       sjmp BTN_Do_Action
108D           2210   BTN_Release_Check4:
108D 308625    2211       jnb BTN_REFL_TIME, Check_Buttons_Done
1090           2212       ; Fall through to action
1090           2213   
1090           2214   ; ============================================================
1090           2215   ; Button Released - Execute Action
1090           2216   ; ============================================================
1090           2217   BTN_Do_Action:
1090 E57C      2218       mov a, BTN_DEB_id
1092           2219       
1092 B40105    2220       cjne a, #1, BTN_Action_2
1095 756101    2221       mov Current_State, #1           ; Soak Temp
1098 8013      2222       sjmp BTN_Action_Complete
109A           2223   BTN_Action_2:
109A B40205    2224       cjne a, #2, BTN_Action_3
109D 756102    2225       mov Current_State, #2           ; Soak Time
10A0 800B      2226       sjmp BTN_Action_Complete
10A2           2227   BTN_Action_3:
10A2 B40305    2228       cjne a, #3, BTN_Action_4
10A5 756103    2229       mov Current_State, #3           ; Refl Temp
10A8 8003      2230       sjmp BTN_Action_Complete
10AA           2231   BTN_Action_4:
10AA 756104    2232       mov Current_State, #4           ; Refl Time
10AD           2233   
10AD           2234   BTN_Action_Complete:
10AD 756A00    2235       mov Cursor_Idx, #0
10B0 D224      2236       setb fullscreen_update_signal   ; Trigger screen redraw
10B2 757A00    2237       mov BTN_DEB_state, #0           ; Reset state machine
10B5           2238   
10B5           2239   Check_Buttons_Done:
10B5 D0D0      2240       pop PSW
10B7 D0E0      2241       pop ACC
10B9 22        2242       ret
10BA           2243   ; ----------------------------------------------------------------
10BA           2244   ; MODULE: KEYPAD HANDLER (Input Logic)
10BA           2245   ; ----------------------------------------------------------------
10BA           2246   Check_Keypad:
10BA E560      2247       mov a, Control_FSM_state
10BC B40152    2248       cjne a, #1, Keypad_Exit
10BF           2249   
10BF           2250       ; If State is 0 (Home), ignore keypad
10BF E561      2251       mov A, Current_State
10C1 604E      2252       jz Keypad_Exit
10C3           2253       
10C3 121112    2254       lcall Keypad_Scan
10C6 5049      2255       jnc Keypad_Exit         ; Carry = 0 means no key pressed
10C8           2256   
10C8 EF        2257       mov A, R7
10C9 B40E09    2258       cjne A, #14, Check_Hash ; 14 is Star (*)
10CC           2259       
10CC 121216    2260       lcall Reset_Current_Buffer
10CF D224      2261       setb fullscreen_update_signal
10D1 756A00    2262       mov Cursor_Idx, #0
10D4 22        2263       ret
10D5           2264   
10D5           2265   Check_Hash:
10D5 EF        2266       mov A, R7
10D6 B40C01    2267       cjne A, #12, Check_Numeric 
10D9 22        2268       ret                
10DA           2269   
10DA           2270   Check_Numeric:
10DA           2271       ; Ensure key is 0-9
10DA EF        2272       mov A, R7
10DB C3        2273       clr C
10DC 940A      2274       subb A, #10
10DE 5030      2275       jnc Symbol_Key_Ignored
10E0           2276       
10E0           2277       ; Convert to ASCII
10E0 EF        2278       mov A, R7
10E1 2430      2279       add A, #0x30
10E3 FD        2280       mov R5, A
10E4           2281   
10E4           2282       ;save to Buffer
10E4 120B51    2283       lcall Get_Current_Buffer_Addr
10E7 E56A      2284       mov A, Cursor_Idx
10E9 28        2285       add A, R0
10EA F8        2286       mov R0, A
10EB ED        2287       mov A, R5
10EC F6        2288       mov @R0, A
10ED 056A      2289       inc Cursor_Idx
10EF           2290   
10EF           2291       ;Check cursor limits ---
10EF E561      2292       mov A, Current_State
10F1 B40102    2293       cjne A, #1, Check_Limit_Time_1
10F4 8005      2294       sjmp Limit_Temp_3
10F6           2295   
10F6           2296   Check_Limit_Time_1:
10F6 B4030B    2297       cjne A, #3, Limit_Time_4
10F9 8000      2298       sjmp Limit_Temp_3
10FB           2299   
10FB           2300   Limit_Temp_3:
10FB E56A      2301       mov A, Cursor_Idx
10FD B4030D    2302       cjne A, #3, Do_Refresh
1100 156A      2303       dec Cursor_Idx          
1102 8009      2304       sjmp Do_Refresh
1104           2305   
1104           2306   Limit_Time_4:
1104 E56A      2307       mov A, Cursor_Idx
1106 B40404    2308       cjne A, #4, Do_Refresh
1109 156A      2309       dec Cursor_Idx         
110B 8000      2310       sjmp Do_Refresh
110D           2311   
110D           2312   Do_Refresh:
110D D224      2313       setb fullscreen_update_signal
110F 22        2314       ret
1110           2315   
1110           2316   Symbol_Key_Ignored:
1110 22        2317       ret
1111           2318   Keypad_Exit:
1111 22        2319       ret
1112           2320   
1112           2321   ;-------------------------------------------------------------------------------
1112           2322   ; hardware
1112           2323   ;-------------------------------------------------------------------------------
1112           2324   Keypad_Scan:
1112 C292      2325       clr ROW1
1114 C294      2326       clr ROW2
1116 C296      2327       clr ROW3
1118 C2A0      2328       clr ROW4
111A A2A2      2329       mov C, COL1
111C 82A4      2330       anl C, COL2
111E 82A6      2331       anl C, COL3
1120 82B0      2332       anl C, COL4
1122 5002      2333       jnc Keypad_Debounce
1124 C3        2334       clr C
1125 22        2335       ret
1126           2336   
1126           2337   Keypad_Debounce:
1126 120FF5    2338       lcall Wait_25ms_BLOCKING
1129 A2A2      2339       mov C, COL1
112B 82A4      2340       anl C, COL2
112D 82A6      2341       anl C, COL3
112F 82B0      2342       anl C, COL4
1131 5002      2343       jnc Keypad_Find_Row
1133 C3        2344       clr C
1134 22        2345       ret
1135           2346   
1135           2347   Keypad_Find_Row:
1135 D292      2348       setb ROW1
1137 D294      2349       setb ROW2
1139 D296      2350       setb ROW3
113B D2A0      2351       setb ROW4
113D           2352   
113D           2353       ; Row 1
113D C292      2354       clr ROW1
113F 30A23D    2355       jnb COL1, Keypad_Key_1
1142 30A43E    2356       jnb COL2, Keypad_Key_2
1145 30A63F    2357       jnb COL3, Keypad_Key_3
1148 30B040    2358       jnb COL4, Keypad_Key_A
114B D292      2359       setb ROW1
114D           2360   
114D           2361       ; Row 2
114D C294      2362       clr ROW2
114F 30A23D    2363       jnb COL1, Keypad_Key_4
1152 30A43E    2364       jnb COL2, Keypad_Key_5
1155 30A63F    2365       jnb COL3, Keypad_Key_6
1158 30B040    2366       jnb COL4, Keypad_Key_B
115B D294      2367       setb ROW2
115D           2368   
115D           2369       ; Row 3
115D C296      2370       clr ROW3
115F 30A23D    2371       jnb COL1, Keypad_Key_7
1162 30A43E    2372       jnb COL2, Keypad_Key_8
1165 30A63F    2373       jnb COL3, Keypad_Key_9
1168 30B040    2374       jnb COL4, Keypad_Key_C
116B D296      2375       setb ROW3
116D           2376   
116D           2377       ; Row 4
116D C2A0      2378       clr ROW4
116F 30A23D    2379       jnb COL1, Keypad_Key_Star
1172 30A43E    2380       jnb COL2, Keypad_Key_0
1175 30A63F    2381       jnb COL3, Keypad_Key_Hash
1178 30B040    2382       jnb COL4, Keypad_Key_D
117B D2A0      2383       setb ROW4
117D C3        2384       clr C
117E 22        2385       ret
117F           2386   
117F           2387   ; Key Mapping
117F 7F01      2388   Keypad_Key_1: mov R7, #1
1181 803C      2389          sjmp Wait_Release
1183 7F02      2390   Keypad_Key_2: mov R7, #2
1185 8038      2391          sjmp Wait_Release
1187 7F03      2392   Keypad_Key_3: mov R7, #3
1189 8034      2393          sjmp Wait_Release
118B 7F0A      2394   Keypad_Key_A: mov R7, #10
118D 8030      2395          sjmp Wait_Release
118F 7F04      2396   Keypad_Key_4: mov R7, #4
1191 802C      2397          sjmp Wait_Release
1193 7F05      2398   Keypad_Key_5: mov R7, #5
1195 8028      2399          sjmp Wait_Release
1197 7F06      2400   Keypad_Key_6: mov R7, #6
1199 8024      2401          sjmp Wait_Release
119B 7F0B      2402   Keypad_Key_B: mov R7, #11
119D 8020      2403          sjmp Wait_Release
119F 7F07      2404   Keypad_Key_7: mov R7, #7
11A1 801C      2405          sjmp Wait_Release
11A3 7F08      2406   Keypad_Key_8: mov R7, #8
11A5 8018      2407          sjmp Wait_Release
11A7 7F09      2408   Keypad_Key_9: mov R7, #9
11A9 8014      2409          sjmp Wait_Release
11AB 7F0D      2410   Keypad_Key_C: mov R7, #13
11AD 8010      2411          sjmp Wait_Release
11AF 7F0E      2412   Keypad_Key_Star: mov R7, #14
11B1 800C      2413          sjmp Wait_Release
11B3 7F00      2414   Keypad_Key_0: mov R7, #0
11B5 8008      2415          sjmp Wait_Release
11B7 7F0C      2416   Keypad_Key_Hash: mov R7, #12
11B9 8004      2417          sjmp Wait_Release
11BB 7F0F      2418   Keypad_Key_D: mov R7, #15
11BD 8000      2419          sjmp Wait_Release
11BF           2420   
11BF           2421   Wait_Release:
11BF A2A2      2422       mov C, COL1
11C1 82A4      2423       anl C, COL2
11C3 82A6      2424       anl C, COL3
11C5 82B0      2425       anl C, COL4
11C7 50F6      2426       jnc Wait_Release
11C9 D3        2427       setb C
11CA D292      2428       setb ROW1
11CC D294      2429       setb ROW2
11CE D296      2430       setb ROW3
11D0 D2A0      2431       setb ROW4
11D2 22        2432       ret
11D3           2433   
11D3           2434   Wait_25ms:
11D3           2435       ; 1. Check if we are already waiting
11D3 201A0E    2436       jb wait25_active, Check_Timer_Status
11D6           2437       
11D6           2438       ; 2. Check if we just finished
11D6 301B04    2439       jnb wait25_done, Start_New_Timer
11D9           2440       
11D9           2441       ; 3. Timer is done
11D9 C21B      2442       clr wait25_done
11DB D3        2443       setb C          ; Carry = 1 means done
11DC 22        2444       ret
11DD           2445   
11DD           2446   Start_New_Timer:
11DD           2447       ; 4. Start a new 25ms wait
11DD 755700    2448       mov wait25_count, #0
11E0 D21A      2449       setb wait25_active
11E2 C3        2450       clr C           ; Carry = 0 means not yet
11E3 22        2451       ret
11E4           2452   
11E4           2453   Check_Timer_Status:
11E4           2454       ; 5. Still waiting... return False immediately
11E4 C3        2455       clr C           ; Carry = 0 means "Not Done Yet"
11E5 22        2456       ret
11E6           2457   
11E6           2458   ;-------------------------------------------------------------------------------
11E6           2459   ; reset logic
11E6           2460   ;-------------------------------------------------------------------------------
11E6           2461   Init_All_Buffers:
11E6 7880      2462       mov R0, #Buf_Soak_Temp
11E8 1211FB    2463       lcall Init_Temp_Template
11EB 7889      2464       mov R0, #Buf_Refl_Temp
11ED 1211FB    2465       lcall Init_Temp_Template
11F0 7884      2466       mov R0, #Buf_Soak_Time
11F2 121207    2467       lcall Init_Time_Template
11F5 788D      2468       mov R0, #Buf_Refl_Time
11F7 121207    2469       lcall Init_Time_Template
11FA 22        2470       ret
11FB           2471   
11FB           2472   Init_Temp_Template:
11FB 7630      2473       mov @R0, #'0'
11FD 08        2474       inc R0
11FE 7630      2475       mov @R0, #'0'
1200 08        2476       inc R0
1201 7630      2477       mov @R0, #'0'
1203 08        2478       inc R0
1204 7600      2479       mov @R0, #0
1206 22        2480       ret
1207           2481   
1207           2482   Init_Time_Template:
1207 7630      2483       mov @R0, #'0'
1209 08        2484       inc R0
120A 7630      2485       mov @R0, #'0'
120C 08        2486       inc R0
120D 7630      2487       mov @R0, #'0'
120F 08        2488       inc R0
1210 7630      2489       mov @R0, #'0'
1212 08        2490       inc R0
1213 7600      2491       mov @R0, #0
1215 22        2492       ret
1216           2493   
1216           2494   Reset_Current_Buffer:
1216 E561      2495       mov A, Current_State
1218 B40106    2496       cjne A, #1, Reset_Chk_2
121B 7880      2497       mov R0, #Buf_Soak_Temp
121D 1211FB    2498       lcall Init_Temp_Template
1220 22        2499       ret
1221           2500   Reset_Chk_2:
1221 B40206    2501       cjne A, #2, Reset_Chk_3
1224 7884      2502       mov R0, #Buf_Soak_Time
1226 121207    2503       lcall Init_Time_Template
1229 22        2504       ret
122A           2505   Reset_Chk_3:
122A B40306    2506       cjne A, #3, Reset_Chk_4
122D 7889      2507       mov R0, #Buf_Refl_Temp
122F 1211FB    2508       lcall Init_Temp_Template
1232 22        2509       ret
1233           2510   Reset_Chk_4:
1233 788D      2511       mov R0, #Buf_Refl_Time
1235 121207    2512       lcall Init_Time_Template
1238 22        2513       ret 
1239           2514       
1239           2515   ; ================================================================
1239           2516   ; MODULE: THERMOCOUPLE ADC DRIVER (WITH NOISE SUPPRESSION & JUMP FIX)
1239           2517   ; ================================================================
1239           2518   Read_Thermocouple:
1239 1211D3    2519       lcall Wait_25ms
123C 4001      2520       jc Proceed_Reading
123E 22        2521       ret 
123F           2522   
123F           2523   Proceed_Reading:
123F E588      2524       mov A, TCON      
1241 5410      2525       anl A, #0x10    
1243 C0E0      2526       push acc         
1245 C28C      2527       clr TR0         
1247           2528   
1247 75A180    2529       mov ADC_C, #0x80    
124A 00        2530       nop
124B 00        2531       nop
124C 75A101    2532       mov ADC_C, #0x01   
124F           2533       
124F 7DFA      2534       mov R5, #250
1251           2535   ADC_Settle_Loop:
1251 00        2536       nop
1252 00        2537       nop
1253 DDFC      2538       djnz R5, ADC_Settle_Loop
1255           2539       
1255 85A23A    2540       mov x+0, ADC_L
1258 85A33B    2541       mov x+1, ADC_H
125B 753C00    2542       mov x+2, #0
125E 753D00    2543       mov x+3, #0
1261           2544       
1261 E53B      2545       mov a, x+1
1263 540F      2546       anl a, #0x0F
1265 F53B      2547       mov x+1, a
1267           2548       
1267 D0E0      2549       pop acc         
1269 6002      2550       jz Skip_Restore 
126B D28C      2551       setb TR0       
126D           2552   Skip_Restore:
126D           2553   
126D           2554            ; as per our volatge reference (measured using the DMM)
126D 753E16    2555            mov y+0, #low (4118 % 0x10000) 
1270 753F10    2555            mov y+1, #high(4118 % 0x10000) 
1273 754000    2555            mov y+2, #low (4118 / 0x10000) 
1276 754100    2555            mov y+3, #high(4118 / 0x10000) 
1279 12018C    2556       lcall mul32       
127C           2557   
127C 75A104    2558       mov ADC_C, #0x04   
127F 85A23E    2559       mov y+0, ADC_L      
1282 85A33F    2560       mov y+1, ADC_H      
1285 754000    2561       mov y+2, #0
1288 754100    2562       mov y+3, #0
128B 75A100    2563       mov ADC_C, #0x00   
128E           2564       
128E 120280    2565       lcall div32         
1291 753E64    2566            mov y+0, #low (100 % 0x10000) 
1294 753F00    2566            mov y+1, #high(100 % 0x10000) 
1297 754000    2566            mov y+2, #low (100 / 0x10000) 
129A 754100    2566            mov y+3, #high(100 / 0x10000) 
129D 12018C    2567       lcall mul32
12A0 753E2B    2568            mov y+0, #low (1323 % 0x10000) 
12A3 753F05    2568            mov y+1, #high(1323 % 0x10000) 
12A6 754000    2568            mov y+2, #low (1323 / 0x10000) 
12A9 754100    2568            mov y+3, #high(1323 / 0x10000)  ;using our amplifiers resistance ratio and 41uV   
12AC 120280    2569       lcall div32    
12AF 753E14    2570            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
12B2 753F00    2570            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
12B5 754000    2570            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
12B8 754100    2570            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
12BB 1200D3    2571       lcall add32     
12BE           2572       
12BE 853A47    2573       mov current_temp+0, x+0
12C1 853B48    2574       mov current_temp+1, x+1
12C4 853C49    2575       mov current_temp+2, x+2
12C7 853D4A    2576       mov current_temp+3, x+3
12CA           2577   
12CA 22        2578       ret
12CB           2579       
12CB           2580   ;-------------------------------------------------------------------------------
12CB           2581   ; power control
12CB           2582   ;-------------------------------------------------------------------------------
12CB           2583   Power_Control:
12CB 755800    2584       mov power_output+0, #0
12CE 755900    2585       mov power_output+1, #0
12D1 755A00    2586       mov power_output+2, #0
12D4 755B00    2587       mov power_output+3, #0
12D7           2588   
12D7 E560      2589       mov a, Control_FSM_state
12D9           2590   
12D9           2591       ; --- State 2: RAMP TO SOAK ---
12D9 B40202    2592       cjne a, #2, PC_Check_Soak
12DC 8016      2593       sjmp Set_Max_Power
12DE           2594   
12DE           2595   PC_Check_Soak:
12DE           2596       ; --- State 3: SOAK PHASE ---
12DE B40305    2597       cjne a, #3, PC_Check_Ramp_Reflow
12E1 20050F    2598       jb soak_temp_reached, PC_Done 
12E4 801B      2599       sjmp Set_20_Percent_Power     
12E6           2600   
12E6           2601   PC_Check_Ramp_Reflow:
12E6           2602       ; --- State 4: RAMP TO REFLOW ---
12E6 B40402    2603       cjne a, #4, PC_Check_Reflow
12E9 8009      2604       sjmp Set_Max_Power
12EB           2605   
12EB           2606   PC_Check_Reflow:
12EB           2607       ; --- State 5: REFLOW PHASE ---
12EB B40505    2608       cjne a, #5, PC_Done
12EE 200602    2609       jb reflow_temp_reached, PC_Done
12F1 800E      2610       sjmp Set_20_Percent_Power
12F3           2611   
12F3           2612   PC_Done:
12F3 22        2613       ret
12F4           2614   
12F4           2615   Set_Max_Power:
12F4           2616       ; Load 1500 (0x05DC) = 100% Duty Cycle
12F4 7558DC    2617       mov power_output+0, #0xDC
12F7 755905    2618       mov power_output+1, #0x05
12FA 755A00    2619       mov power_output+2, #0
12FD 755B00    2620       mov power_output+3, #0
1300 22        2621       ret
1301           2622   
1301           2623   Set_20_Percent_Power:
1301           2624       ; Load 300 (0x012C) = 20% Duty Cycle
1301 75582C    2625       mov power_output+0, #0x2C
1304 755901    2626       mov power_output+1, #0x01
1307 755A00    2627       mov power_output+2, #0
130A 755B00    2628       mov power_output+3, #0
130D 22        2629       ret
130E           2630   ;--------------------------------------------------------------
130E           2631   ; set servo angle according to the state
130E           2632   ; call servo control function every 1ms
130E           2633   ;--------------------------------------------------------------
130E           2634   call_servo_control:
130E           2635            ; check current state and change servo angle
130E E560      2636            mov a, Control_FSM_state
1310           2637            
1310           2638            ; handle state 0
1310 B40004    2639            cjne a, #0, servo_state1
1313 C227      2640            clr servo_angle_zero ; close door at state 0
1315 802C      2641            sjmp check_servo_flag
1317           2642   
1317           2643            ; handle state 1
1317           2644            servo_state1:
1317 B40104    2645            cjne a, #1, servo_state2
131A D227      2646            setb servo_angle_zero ; open door at state 1
131C 8025      2647            sjmp check_servo_flag
131E           2648   
131E           2649            ; handle state 2
131E           2650            servo_state2:
131E B40204    2651            cjne a, #2, servo_state3
1321 C227      2652            clr servo_angle_zero ; close door at state 2
1323 801E      2653            sjmp check_servo_flag
1325           2654   
1325           2655            ; handle state 3
1325           2656            servo_state3:
1325 B40304    2657            cjne a, #3, servo_state4
1328 C227      2658            clr servo_angle_zero ; close door at state 3
132A 8017      2659            sjmp check_servo_flag
132C           2660   
132C           2661            ; handle state 4
132C           2662            servo_state4:
132C B40404    2663            cjne a, #4, servo_state5
132F C227      2664            clr servo_angle_zero ; close door at state 4
1331 8010      2665            sjmp check_servo_flag
1333           2666   
1333           2667            ; handle state 5
1333           2668            servo_state5:
1333 B40504    2669            cjne a, #5, servo_state6
1336 C227      2670            clr servo_angle_zero ; close door at state 5
1338 8009      2671            sjmp check_servo_flag
133A           2672   
133A           2673            ; handle state 6
133A           2674            servo_state6:
133A B40604    2675            cjne a, #6, servo_state7
133D C227      2676            clr servo_angle_zero ; close door at state 6
133F 8002      2677            sjmp check_servo_flag
1341           2678   
1341           2679            ; handle state 7
1341           2680            servo_state7:
1341 D227      2681            setb servo_angle_zero ; open door at state 7
1343           2682   
1343           2683   check_servo_flag:
1343           2684            ; check 1 ms flag
1343 102601    2685            jbc one_millisecond_flag_servo, run_servo_control
1346 22        2686            ret
1347           2687   
1347           2688   run_servo_control:
1347 12134B    2689            lcall servo_control
134A 22        2690            ret
134B           2691   
134B           2692   ;---------------------------------------------------------------
134B           2693   ; servo control
134B           2694   ; generate a 20 ms period pwm signal to control the servo motor
134B           2695   ; able to make the servo motor stay at 0 degree and 180 degree
134B           2696   ;---------------------------------------------------------------
134B           2697   servo_control:
134B D2ED      2698       setb LEDRA.5
134D C0E0      2699            push acc
134F C0D0      2700            push psw
1351 E579      2701            mov a, servo_pwm_counter ; move servo counter to accumulator
1353 04        2702            inc A ; a += 1
1354 B41402    2703            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
1357 7400      2704            mov a, #0
1359           2705   
1359           2706   servo_pwm_angle_compare: ; read target angle
1359 F579      2707            mov servo_pwm_counter, A
135B 202709    2708            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
135E           2709            ; set servo motor to 180 degrees
135E E579      2710            mov a, servo_pwm_counter
1360 C3        2711            clr c
1361 9402      2712            subb a, #SERVO_180
1363 400B      2713            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
1365 800D      2714            sjmp servo_pwm_set_low ; set low if greater
1367           2715   
1367           2716   set_zero_degree:
1367           2717            ; set servo motor to 0 degree
1367 E579      2718            mov a, servo_pwm_counter
1369 C3        2719            clr c
136A 9401      2720            subb a, #SERVO_0
136C 4002      2721            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
136E 8004      2722            sjmp servo_pwm_set_low ; set low if greater
1370           2723   
1370           2724   servo_pwm_set_high:
1370           2725            ; set pwm pin high
1370 D2B6      2726            setb SERVO_OUT
1372 8002      2727            sjmp servo_control_done
1374           2728   
1374           2729   servo_pwm_set_low:
1374           2730            ; set pwm pin low
1374 C2B6      2731            clr SERVO_OUT
1376           2732   
1376           2733   servo_control_done:
1376 D0D0      2734            pop psw
1378 D0E0      2735            pop acc
137A 22        2736            ret
137B           2737   
137B           2738   ;-------------------------------------------------------------------------------
137B           2739   ; power_control
137B           2740   ;-------------------------------------------------------------------------------
137B           2741   ; Determine the power output based on current state and current temperature 
137B           2742   ; input parameter: Control_FSM_state
137B           2743   ;-------------------------------------------------------------------------------
137B           2744   ; Update LED indicators based on power_output
137B           2745   ; 0%  -> all off
137B           2746   ; <50% -> LED_LEFT on
137B           2747   ; 50%-99% -> LED_LEFT + LED_MID on
137B           2748   ; >=100% -> LED_LEFT + LED_MID + LED_RIGHT on
137B           2749   Update_Power_LEDs:
137B           2750       ; Check for exact 0 (all bytes zero)
137B E558      2751       mov a, power_output
137D 4559      2752       orl a, power_output+1
137F 455A      2753       orl a, power_output+2
1381 455B      2754       orl a, power_output+3
1383 6032      2755       jz power_leds_low
1385           2756   
1385 85583A    2757       mov x, power_output
1388 85593B    2758       mov x+1, power_output+1
138B 855A3C    2759       mov x+2, power_output+2
138E 855B3D    2760       mov x+3, power_output+3
1391           2761   
1391 753EEE    2762            mov y+0, #low (HALF_POWER % 0x10000) 
1394 753F02    2762            mov y+1, #high(HALF_POWER % 0x10000) 
1397 754000    2762            mov y+2, #low (HALF_POWER / 0x10000) 
139A 754100    2762            mov y+3, #high(HALF_POWER / 0x10000) 
139D 12011A    2763       lcall x_lt_y
13A0 200014    2764       jb mf, power_leds_low
13A3           2765   
13A3 753EDC    2766            mov y+0, #low (MAX_POWER % 0x10000) 
13A6 753F05    2766            mov y+1, #high(MAX_POWER % 0x10000) 
13A9 754000    2766            mov y+2, #low (MAX_POWER / 0x10000) 
13AC 754100    2766            mov y+3, #high(MAX_POWER / 0x10000) 
13AF 12011A    2767       lcall x_lt_y
13B2 200009    2768       jb mf, power_leds_mid
13B5           2769   
13B5 800E      2770       sjmp power_leds_high
13B7           2771   
13B7           2772   power_leds_low:
13B7 C2B4      2773       clr  LED_LEFT
13B9 C2B3      2774       clr  LED_MID
13BB C2B2      2775       clr  LED_RIGHT
13BD 22        2776       ret
13BE           2777   
13BE           2778   power_leds_mid:
13BE D2B4      2779       setb LED_LEFT
13C0 C2B3      2780       clr LED_MID
13C2 C2B2      2781       clr  LED_RIGHT
13C4 22        2782       ret
13C5           2783   
13C5           2784   power_leds_high:
13C5 D2B4      2785       setb LED_LEFT
13C7 D2B3      2786       setb LED_MID
13C9 D2B2      2787       setb LED_RIGHT
13CB 22        2788       ret
13CC           2789   
13CC           2790   proportional_power_control:
13CC E560      2791            mov a, Control_FSM_state
13CE           2792   
13CE           2793   state0_power_control:
13CE           2794            ; idle
13CE           2795            ; 0% power
13CE B40012    2796            cjne a, #0, state1_power_control
13D1 755800    2797            mov power_output, #low(NO_POWER)
13D4 755900    2798            mov power_output+1, #low(NO_POWER)
13D7 755A00    2799            mov power_output+2, #0
13DA 755B00    2800            mov power_output+3, #0
13DD 1213B7    2801       lcall power_leds_low
13E0 0215D1    2802            ljmp power_control_done
13E3           2803   
13E3           2804   state1_power_control:
13E3           2805            ; idle
13E3           2806            ; 0% power
13E3 B40112    2807            cjne a, #1, state2_power_control
13E6 755800    2808            mov power_output, #low(NO_POWER)
13E9 755900    2809            mov power_output+1, #low(NO_POWER)
13EC 755A00    2810            mov power_output+2, #0
13EF 755B00    2811            mov power_output+3, #0
13F2 1213B7    2812       lcall power_leds_low
13F5 0215D1    2813            ljmp power_control_done
13F8           2814            
13F8           2815   state2_power_control:
13F8           2816            ; ramp to soak, ramp to ~150C
13F8           2817            ; 100% power
13F8 B40253    2818            cjne a, #2, state3_power_control
13FB           2819       
13FB 854B3A    2820       mov x, soak_temp
13FE 854C3B    2821       mov x+1, soak_temp+1
1401 854D3C    2822       mov x+2, soak_temp+2
1404 854E3D    2823       mov x+3, soak_temp+3
1407 753E05    2824            mov y+0, #low (5 % 0x10000) 
140A 753F00    2824            mov y+1, #high(5 % 0x10000) 
140D 754000    2824            mov y+2, #low (5 / 0x10000) 
1410 754100    2824            mov y+3, #high(5 / 0x10000) 
1413 1200F6    2825       lcall sub32 
1416           2826       ; now x holds soak_temp-5
1416           2827       ; turn power to 20% when current_temp > soak_temp-5
1416           2828   
1416 85473E    2829       mov y, current_temp
1419 85483F    2830       mov y+1, current_temp+1
141C 854940    2831       mov y+2, current_temp+2
141F 854A41    2832       mov y+3, current_temp+3
1422           2833   
1422 C200      2834       clr mf
1424 120178    2835       lcall x_gteq_y
1427           2836       
1427 100012    2837       jbc mf, state_2_full_power ; turn on full power when current_temp <= soak_temp-5
142A           2838       ; turn on 20% power when current_temp > soak_temp-5
142A 75582C    2839       mov power_output, #low(BASE_POWER)
142D 755901    2840       mov power_output+1, #high(BASE_POWER)
1430 755A00    2841       mov power_output+2, #0
1433 755B00    2842       mov power_output+3, #0
1436 1213BE    2843       lcall power_leds_mid
1439 0215D1    2844       ljmp power_control_done
143C           2845   
143C           2846   state_2_full_power:
143C 7558DC    2847            mov power_output, #low(MAX_POWER)
143F 755905    2848            mov power_output+1, #high(MAX_POWER)
1442 755A00    2849            mov power_output+2, #0
1445 755B00    2850            mov power_output+3, #0
1448 1213C5    2851       lcall power_leds_high
144B 0215D1    2852            ljmp power_control_done
144E           2853   
144E           2854   state3_power_control:
144E           2855            ; soak period, hold at 150C
144E           2856            ; 20% base power + proportional calculated power
144E B40305    2857            cjne a, #3, jump_state4_power_control
1451 1213BE    2858       lcall power_leds_mid
1454 8003      2859            sjmp state3_power_control_calculation
1456           2860   
1456           2861   jump_state4_power_control:
1456 021583    2862            ljmp state4_power_control
1459           2863   
1459           2864   state3_power_control_calculation:
1459           2865            ; move soak_temp to x
1459 854B3A    2866            mov x, soak_temp
145C 854C3B    2867            mov x+1, soak_temp+1
145F 854D3C    2868            mov x+2, soak_temp+2
1462 854E3D    2869            mov x+3, soak_temp+3
1465           2870            ; move current_temp to y
1465 85473E    2871            mov y, current_temp
1468 85483F    2872            mov y+1, current_temp+1
146B 854940    2873            mov y+2, current_temp+2
146E 854A41    2874            mov y+3, current_temp+3
1471           2875   
1471           2876            ; compare between soak_temp and current_temp
1471 C200      2877            clr mf
1473 120178    2878            lcall x_gteq_y
1476 10002B    2879            jbc mf, st_sub_ct
1479           2880            ; current_temp - soak_temp if st < ct
1479 C228      2881            clr soak_temp_greater
147B           2882            ; move current_temp to y
147B 854B3E    2883            mov y, soak_temp
147E 854C3F    2884            mov y+1, soak_temp+1
1481 854D40    2885            mov y+2, soak_temp+2
1484 854E41    2886            mov y+3, soak_temp+3
1487           2887            ; move current_temp to x
1487 85473A    2888            mov x, current_temp
148A 85483B    2889            mov x+1, current_temp+1
148D 85493C    2890            mov x+2, current_temp+2
1490 854A3D    2891            mov x+3, current_temp+3
1493 1200F6    2892            lcall sub32
1496 853A62    2893            mov soak_temp_diff, x
1499 853B63    2894            mov soak_temp_diff+1, x+1
149C 853C64    2895            mov soak_temp_diff+2, x+2
149F 853D65    2896            mov soak_temp_diff+3, x+3
14A2 8011      2897            sjmp proportional_input_soak
14A4           2898   
14A4           2899   st_sub_ct:
14A4           2900            ; soak_temp - current_temp
14A4 D228      2901            setb soak_temp_greater
14A6 1200F6    2902            lcall sub32
14A9 853A62    2903            mov soak_temp_diff, x
14AC 853B63    2904            mov soak_temp_diff+1, x+1
14AF 853C64    2905            mov soak_temp_diff+2, x+2
14B2 853D65    2906            mov soak_temp_diff+3, x+3
14B5           2907   
14B5           2908   proportional_input_soak:
14B5           2909            ; proportaional block calculation       
14B5           2910            ; move soak_temp_diff to x
14B5 85623A    2911            mov x, soak_temp_diff
14B8 85633B    2912            mov x+1, soak_temp_diff+1
14BB 85643C    2913            mov x+2, soak_temp_diff+2
14BE 85653D    2914            mov x+3, soak_temp_diff+3
14C1           2915            ; move proportional gain to y
14C1 753E05    2916            mov y+0, #low (KP % 0x10000) 
14C4 753F00    2916            mov y+1, #high(KP % 0x10000) 
14C7 754000    2916            mov y+2, #low (KP / 0x10000) 
14CA 754100    2916            mov y+3, #high(KP / 0x10000) 
14CD 12018C    2917            lcall mul32 ; proportional_output = proportional_gain * difference
14D0           2918            
14D0 853A66    2919            mov proportional_gain_var, x
14D3 853B67    2920            mov proportional_gain_var+1, x+1
14D6 853C68    2921            mov proportional_gain_var+2, x+2
14D9 853D69    2922            mov proportional_gain_var+3, x+3
14DC           2923   
14DC           2924            ; base_power + soak_power when soak_temp > current_temp
14DC 302829    2925            jnb soak_temp_greater, sub_proportional_soak
14DF 85663A    2926            mov x, proportional_gain_var
14E2 85673B    2927            mov x+1, proportional_gain_var+1
14E5 85683C    2928            mov x+2, proportional_gain_var+2
14E8 85693D    2929            mov x+3, proportional_gain_var+3
14EB 753E2C    2930            mov y+0, #low (BASE_POWER % 0x10000) 
14EE 753F01    2930            mov y+1, #high(BASE_POWER % 0x10000) 
14F1 754000    2930            mov y+2, #low (BASE_POWER / 0x10000) 
14F4 754100    2930            mov y+3, #high(BASE_POWER / 0x10000) 
14F7 1200D3    2931            lcall add32
14FA           2932            ; x now holds the power output before the saturator
14FA 853A66    2933            mov proportional_gain_var, x
14FD 853B67    2934            mov proportional_gain_var+1, x+1
1500 853C68    2935            mov proportional_gain_var+2, x+2
1503 853D69    2936            mov proportional_gain_var+3, x+3
1506 803D      2937            sjmp saturator_soak
1508           2938   
1508           2939   sub_proportional_soak:
1508           2940            ; base_power - soak_power when soak_temp <= current_temp
1508 753A2C    2941            mov x+0, #low (BASE_POWER % 0x10000) 
150B 753B01    2941            mov x+1, #high(BASE_POWER % 0x10000) 
150E 753C00    2941            mov x+2, #low (BASE_POWER / 0x10000) 
1511 753D00    2941            mov x+3, #high(BASE_POWER / 0x10000) 
1514 85663E    2942            mov y, proportional_gain_var
1517 85673F    2943            mov y+1, proportional_gain_var+1
151A 856840    2944            mov y+2, proportional_gain_var+2
151D 856941    2945            mov y+3, proportional_gain_var+3
1520           2946   
1520           2947            ; compare whether base_power < proportional_gain_var
1520 C200      2948            clr mf
1522 12011A    2949            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
1525 30000E    2950            jnb mf, bp_gteq_pgv
1528 756600    2951            mov proportional_gain_var, #low(NO_POWER)
152B 756700    2952            mov proportional_gain_var+1, #high(NO_POWER)
152E 756800    2953            mov proportional_gain_var+2, #0
1531 756900    2954            mov proportional_gain_var+3, #0
1534 800F      2955            sjmp saturator_soak
1536           2956   
1536           2957   bp_gteq_pgv:
1536           2958            ; calculate subtracted gain
1536 1200F6    2959            lcall sub32
1539           2960            ; x now holds the power output before the saturator
1539 853A66    2961            mov proportional_gain_var, x
153C 853B67    2962            mov proportional_gain_var+1, x+1
153F 853C68    2963            mov proportional_gain_var+2, x+2
1542 853D69    2964            mov proportional_gain_var+3, x+3
1545           2965   
1545           2966   saturator_soak:
1545           2967            ; proportional_gain_var now holds the power output before the saturator
1545           2968            ; saturate power output to max power
1545 85663A    2969            mov x, proportional_gain_var
1548 85673B    2970            mov x+1, proportional_gain_var+1
154B 85683C    2971            mov x+2, proportional_gain_var+2
154E 85693D    2972            mov x+3, proportional_gain_var+3
1551           2973   
1551 753EDC    2974            mov y+0, #low (MAX_POWER % 0x10000) 
1554 753F05    2974            mov y+1, #high(MAX_POWER % 0x10000) 
1557 754000    2974            mov y+2, #low (MAX_POWER / 0x10000) 
155A 754100    2974            mov y+3, #high(MAX_POWER / 0x10000) 
155D           2975   
155D C200      2976            clr mf
155F 120136    2977            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
1562 20000F    2978            jb mf, saturated_soak
1565           2979            ; set power_output to calculated power if not saturated
1565 856658    2980            mov power_output, proportional_gain_var
1568 856759    2981            mov power_output+1, proportional_gain_var+1
156B 85685A    2982            mov power_output+2, proportional_gain_var+2
156E 85695B    2983            mov power_output+3, proportional_gain_var+3
1571 0215D1    2984            ljmp power_control_done
1574           2985   
1574           2986   saturated_soak:
1574 7558DC    2987            mov power_output, #low(MAX_POWER)
1577 755905    2988            mov power_output+1, #high(MAX_POWER)
157A 755A00    2989            mov power_output+2, #0
157D 755B00    2990            mov power_output+3, #0
1580 0215D1    2991            ljmp power_control_done
1583           2992   
1583           2993   
1583           2994   state4_power_control:
1583           2995            ; ramp to reflow, max power
1583 B40412    2996            cjne a, #4, state5_power_control
1586 7558DC    2997            mov power_output, #low(MAX_POWER)
1589 755905    2998            mov power_output+1, #high(MAX_POWER)
158C 755A00    2999            mov power_output+2, #0
158F 755B00    3000            mov power_output+3, #0
1592 1213C5    3001       lcall power_leds_high
1595 0215D1    3002            ljmp power_control_done
1598           3003   
1598           3004   state5_power_control:
1598           3005            ; reflow 20% base power
1598 B40512    3006            cjne a, #5, state6_power_control
159B 75582C    3007            mov power_output, #low(BASE_POWER)  
159E 755901    3008            mov power_output+1, #high(BASE_POWER)
15A1 755A00    3009            mov power_output+2, #0
15A4 755B00    3010            mov power_output+3, #0
15A7 1213BE    3011       lcall power_leds_mid
15AA 0215D1    3012            ljmp power_control_done
15AD           3013   
15AD           3014   state6_power_control:
15AD           3015            ; cooling 0% power
15AD B40612    3016            cjne a, #6, state_7_power_control
15B0 755800    3017            mov power_output, #low(NO_POWER)
15B3 755900    3018            mov power_output+1, #high(NO_POWER)
15B6 755A00    3019            mov power_output+2, #0
15B9 755B00    3020            mov power_output+3, #0
15BC 1213B7    3021       lcall power_leds_low
15BF 0215D1    3022            ljmp power_control_done
15C2           3023   
15C2           3024   state_7_power_control:
15C2           3025            ; idle 0% power
15C2 755800    3026            mov power_output, #low(NO_POWER)
15C5 755900    3027            mov power_output+1, #high(NO_POWER)
15C8 755A00    3028            mov power_output+2, #0
15CB 755B00    3029            mov power_output+3, #0
15CE 1213B7    3030       lcall power_leds_low
15D1           3031   power_control_done:
15D1 22        3032            ret
15D2           3033   
15D2           3034   ;----------------------------------------------------------------------------------------
15D2           3035   ; function for playing the boot up music
15D2           3036   music:
15D2           3037            ; 1
15D2 12162A    3038            lcall playC
15D5 1216BA    3039            lcall delayHalfSec
15D8           3040            ; 1
15D8 12162A    3041            lcall playC
15DB 1216BA    3042            lcall delayHalfSec
15DE           3043            ; 5
15DE 121642    3044            lcall playG
15E1 1216BA    3045            lcall delayHalfSec
15E4           3046            ; 5
15E4 121642    3047            lcall playG
15E7 1216BA    3048            lcall delayHalfSec
15EA           3049            ; 6
15EA 12165A    3050            lcall PlayA
15ED 1216BA    3051            lcall delayHalfSec
15F0           3052            ; 6
15F0 12165A    3053            lcall PlayA
15F3 1216BA    3054            lcall delayHalfSec
15F6           3055            ; 5
15F6 121642    3056            lcall playG
15F9 1216BA    3057            lcall delayHalfSec
15FC           3058            ; 4
15FC 121672    3059            lcall playF
15FF 1216BA    3060            lcall delayHalfSec
1602           3061   
1602           3062            ; 4
1602 121672    3063            lcall playF
1605 1216BA    3064            lcall delayHalfSec
1608           3065            ; 3
1608 12168A    3066            lcall playE
160B 1216BA    3067            lcall delayHalfSec
160E           3068   
160E           3069            ; 3
160E 12168A    3070            lcall playE
1611 1216BA    3071            lcall delayHalfSec
1614           3072   
1614           3073            ; 2
1614 1216A2    3074            lcall playD
1617 1216BA    3075            lcall delayHalfSec
161A           3076   
161A           3077            ; 2
161A 1216A2    3078            lcall playD
161D 1216BA    3079            lcall delayHalfSec
1620           3080            ; 1
1620 12162A    3081            lcall playC
1623 1216BA    3082            lcall delayHalfSec
1626           3083            
1626 1216BA    3084            lcall delayHalfSec
1629 22        3085            ret
162A           3086   
162A           3087   ;------------------------------------
162A           3088   ; Play_C_0p5s
162A           3089   ; Plays ~523 Hz on P1.7 for 0.5 seconds
162A           3090   ;------------------------------------
162A           3091   playC:
162A 7F14      3092       MOV R7, #20        ; outer loop counter
162C           3093   
162C           3094   OUTER_LOOP:
162C 7E1A      3095       MOV R6, #26        ; inner loop counter
162E           3096   
162E           3097   INNER_LOOP:
162E B295      3098       CPL SOUND_OUT           ; toggle buzzer pin
1630 12163A    3099       LCALL Delay_C      ; ~960 s delay
1633 DEF9      3100       DJNZ R6, INNER_LOOP
1635           3101   
1635 DFF5      3102       DJNZ R7, OUTER_LOOP
1637           3103   
1637 C295      3104       CLR SOUND_OUT           ; stop sound (pin low)
1639 22        3105       RET
163A           3106       
163A           3107   Delay_C:
163A 7D18      3108       MOV R5, #24        ; 24  40 s = 960 s
163C           3109   DELAY_LOOP:
163C 12073D    3110       LCALL Wait40uSec
163F DDFB      3111       DJNZ R5, DELAY_LOOP
1641 22        3112       RET
1642           3113       
1642           3114   
1642           3115   ;------------------------------------
1642           3116   ; Play_G_0p5s
1642           3117   ; Plays ~784 Hz on P1.7 for 0.5 seconds
1642           3118   ;------------------------------------
1642           3119   playG:
1642 7F1F      3120       MOV R7, #31        ; outer loop
1644           3121   
1644           3122   OUTER_G:
1644 7E19      3123       MOV R6, #25        ; inner loop 31  25 = 775 toggles
1646           3124   
1646           3125   INNER_G:
1646 B295      3126       CPL SOUND_OUT           ; toggle buzzer pin
1648 121652    3127       LCALL Delay_G      ; ~640 s delay
164B DEF9      3128       DJNZ R6, INNER_G
164D           3129   
164D DFF5      3130       DJNZ R7, OUTER_G
164F           3131   
164F C295      3132       CLR SOUND_OUT           ; stop sound
1651 22        3133       RET
1652           3134       
1652           3135   Delay_G:
1652 7D10      3136       MOV R5, #16        ; 16  40 s = 640 s
1654           3137   DELAY_G_LOOP:
1654 12073D    3138       LCALL Wait40uSec
1657 DDFB      3139       DJNZ R5, DELAY_G_LOOP
1659 22        3140       RET
165A           3141            
165A           3142    
165A           3143    ;------------------------------------
165A           3144   ; Play_A_0p5s
165A           3145   ; Plays ~880 Hz on P1.7 for 0.5 seconds
165A           3146   ;------------------------------------
165A           3147   playA:
165A 7F22      3148       MOV R7, #34        ; outer loop counter
165C           3149   
165C           3150   OUTER_A:
165C 7E1A      3151       MOV R6, #26        ; inner loop ? 34  26 = 884 toggles
165E           3152   
165E           3153   INNER_A:
165E B295      3154       CPL SOUND_OUT           ; toggle buzzer pin
1660 12166A    3155       LCALL Delay_A      ; ~560 s delay
1663 DEF9      3156       DJNZ R6, INNER_A
1665           3157   
1665 DFF5      3158       DJNZ R7, OUTER_A
1667           3159   
1667 C295      3160       CLR SOUND_OUT          ; stop sound
1669 22        3161       RET
166A           3162   
166A           3163   Delay_A:
166A 7D0E      3164       MOV R5, #14        ; 14  40 s = 560 s
166C           3165   DELAY_A_LOOP:
166C 12073D    3166       LCALL Wait40uSec
166F DDFB      3167       DJNZ R5, DELAY_A_LOOP
1671 22        3168       RET
1672           3169   
1672           3170   ;------------------------------------
1672           3171   ; Play_F_0p5s
1672           3172   ; Plays ~698 Hz on P1.7 for 0.5 seconds
1672           3173   ;------------------------------------
1672           3174   playF:
1672 7F1A      3175       MOV R7, #26        ; outer loop
1674           3176   
1674           3177   OUTER_F:
1674 7E1B      3178       MOV R6, #27        ; inner loop ? 26  27 = 702 toggles
1676           3179   
1676           3180   INNER_F:
1676 B295      3181       CPL SOUND_OUT          ; toggle buzzer pin
1678 121682    3182       LCALL Delay_F      ; ~720 s delay
167B DEF9      3183       DJNZ R6, INNER_F
167D           3184   
167D DFF5      3185       DJNZ R7, OUTER_F
167F           3186   
167F C295      3187       CLR SOUND_OUT           ; stop sound
1681 22        3188       RET
1682           3189   
1682           3190   Delay_F:
1682 7D12      3191       MOV R5, #18        ; 18  40 s = 720 s
1684           3192   DELAY_F_LOOP:
1684 12073D    3193       LCALL Wait40uSec
1687 DDFB      3194       DJNZ R5, DELAY_F_LOOP
1689 22        3195       RET
168A           3196   
168A           3197   
168A           3198   ;------------------------------------
168A           3199   ; Play_E_0p5s
168A           3200   ; Plays ~659 Hz on P1.7 for 0.5 seconds
168A           3201   ;------------------------------------
168A           3202   playE:
168A 7F1A      3203       MOV R7, #26        ; outer loop
168C           3204   
168C           3205   OUTER_E:
168C 7E19      3206       MOV R6, #25        ; inner loop ? 26  25 = 650 toggles
168E           3207   
168E           3208   INNER_E:
168E B295      3209       CPL SOUND_OUT           ; toggle buzzer pin
1690 12169A    3210       LCALL Delay_E      ; ~760 s delay
1693 DEF9      3211       DJNZ R6, INNER_E
1695           3212   
1695 DFF5      3213       DJNZ R7, OUTER_E
1697           3214   
1697 C295      3215       CLR SOUND_OUT          ; stop sound
1699 22        3216       RET
169A           3217       
169A           3218   Delay_E:
169A 7D13      3219       MOV R5, #19        ; 19  40 s = 760 s
169C           3220   DELAY_E_LOOP:
169C 12073D    3221       LCALL Wait40uSec
169F DDFB      3222       DJNZ R5, DELAY_E_LOOP
16A1 22        3223       RET
16A2           3224   
16A2           3225   
16A2           3226   ;------------------------------------
16A2           3227   ; Play_D_0p5s
16A2           3228   ; Plays ~587 Hz on P1.7 for 0.5 seconds
16A2           3229   ;------------------------------------
16A2           3230   playD:
16A2 7F19      3231       MOV R7, #25        ; outer loop
16A4           3232   
16A4           3233   OUTER_D:
16A4 7E18      3234       MOV R6, #24        ; inner loop ? 25  24 = 600 toggles
16A6           3235   
16A6           3236   INNER_D:
16A6 B295      3237       CPL SOUND_OUT          ; toggle buzzer pin
16A8 1216B2    3238       LCALL Delay_D      ; ~840 s delay
16AB DEF9      3239       DJNZ R6, INNER_D
16AD           3240   
16AD DFF5      3241       DJNZ R7, OUTER_D
16AF           3242   
16AF C295      3243       CLR SOUND_OUT         ; stop sound
16B1 22        3244       RET
16B2           3245       
16B2           3246   Delay_D:
16B2 7D15      3247       MOV R5, #21        ; 21  40 s = 840 s
16B4           3248   DELAY_D_LOOP:
16B4 12073D    3249       LCALL Wait40uSec
16B7 DDFB      3250       DJNZ R5, DELAY_D_LOOP
16B9 22        3251       RET
16BA           3252   
16BA           3253   delayHalfSec:
16BA 7A32      3254            mov     R2, #50
16BC 1216C0    3255            lcall WaitmilliSec
16BF 22        3256            ret
16C0           3257   
16C0           3258   ;---------------------------------;
16C0           3259   ; Wait 'R2' milliseconds, blocking;
16C0           3260   ;---------------------------------;
16C0           3261   WaitmilliSec:
16C0 C000      3262       push AR0
16C2 C001      3263       push AR1
16C4 7928      3264   loop3: mov R1, #40
16C6 7868      3265   loop2: mov R0, #104
16C8 D8FE      3266   loop1: djnz R0, loop1 ; 4 cycles->4*60.24ns*104=25.0us
16CA D9FA      3267       djnz R1, loop2 ; 25us*40=1.0ms
16CC DAF6      3268       djnz R2, loop3 ; number of millisecons to wait passed in R2
16CE D001      3269       pop AR1
16D0 D000      3270       pop AR0
16D2 22        3271       ret
16D3           3272   ;-------------------------------------------------------------------------------
16D3           3273   
16D3           3274   ;------------------------------------------------------------------------------
16D3           3275   ; dc_control
16D3           3276   ; turns on the dc motor in cooling stage
16D3           3277   ;------------------------------------------------------------------------------
16D3           3278   dc_control:
16D3 E560      3279       mov a, Control_FSM_state
16D5           3280            
16D5           3281            ; handle state 0
16D5 B40004    3282            cjne a, #0, dc_state1
16D8 C2C0      3283            clr DC_OUT
16DA 802C      3284       sjmp dc_control_done
16DC           3285   
16DC           3286            ; handle state 1
16DC           3287            dc_state1:
16DC B40104    3288            cjne a, #1, dc_state2
16DF C2C0      3289            clr DC_OUT
16E1 8025      3290       sjmp dc_control_done
16E3           3291   
16E3           3292            ; handle state 2
16E3           3293            dc_state2:
16E3 B40204    3294            cjne a, #2, dc_state3
16E6 C2C0      3295            clr DC_OUT
16E8 801E      3296       sjmp dc_control_done
16EA           3297   
16EA           3298            ; handle state 3
16EA           3299            dc_state3:
16EA B40304    3300            cjne a, #3, dc_state4
16ED C2C0      3301            clr DC_OUT
16EF 8017      3302       sjmp dc_control_done
16F1           3303   
16F1           3304            ; handle state 4
16F1           3305            dc_state4:
16F1 B40404    3306            cjne a, #4, dc_state5
16F4 C2C0      3307            clr DC_OUT
16F6 8010      3308       sjmp dc_control_done
16F8           3309   
16F8           3310            ; handle state 5
16F8           3311            dc_state5:
16F8 B40504    3312            cjne a, #5, dc_state6
16FB C2C0      3313            clr DC_OUT
16FD 8009      3314       sjmp dc_control_done
16FF           3315   
16FF           3316            ; handle state 6
16FF           3317            dc_state6:
16FF B40604    3318       cjne a, #6, dc_state7
1702 D2C0      3319            setb DC_OUT
1704 8002      3320       sjmp dc_control_done
1706           3321   
1706           3322            ; handle state 7
1706           3323            dc_state7:
1706 C2C0      3324            clr DC_OUT  
1708           3325   
1708           3326   dc_control_done:
1708 22        3327       ret
1709           3328   
1709           3329   Boot_Line_Display_Func:
1709 C0E0      3330            push acc
170B 7401      3330            mov a, #1
170D 14        3330            dec a
170E 1207D9    3330            lcall ?Set_Cursor_1 ; Select column and row
1711 D0E0      3330            pop acc
1713 C083      3331            push dph
1715 C082      3331            push dpl
1717 C0E0      3331            push acc
1719 90044C    3331            mov dptr, #String_boot_Line1
171C 1207CC    3331            lcall ?Send_Constant_String
171F D0E0      3331            pop acc
1721 D082      3331            pop dpl
1723 D083      3331            pop dph
1725 C0E0      3332            push acc
1727 7401      3332            mov a, #1
1729 14        3332            dec a
172A 1207D7    3332            lcall ?Set_Cursor_2 ; Select column and row
172D D0E0      3332            pop acc
172F C083      3333            push dph
1731 C082      3333            push dpl
1733 C0E0      3333            push acc
1735 90045C    3333            mov dptr, #String_boot_Line2
1738 1207CC    3333            lcall ?Send_Constant_String
173B D0E0      3333            pop acc
173D D082      3333            pop dpl
173F D083      3333            pop dph
1741 22        3334       ret
1742           3335   
1742           3336   ;-------------------------------------------------------------------------------;
1742           3337   ;         Main program.          
1742           3338   ;-------------------------------------------------------------------------------;
1742           3339   main:
1742           3340   
1742           3341       ; --------------------------------------------------------
1742           3342       ; 1. SAFETY SHUTDOWN
1742           3343       ; --------------------------------------------------------
1742 C2AF      3344       clr EA              ; FORCE Interrupts OFF immediately
1744 7581C0    3345       mov SP, #0xC0       ; Reset Stack Pointer to safe location
1747           3346       
1747           3347       ; --------------------------------------------------------
1747           3348       ; THE "DIRTY DELAY" (Fixes Reset Garbage)
1747           3349       ; We burn ~100ms here using a raw loop. 
1747           3350       ; We cannot use timers yet because they aren't initialized.
1747           3351       ; --------------------------------------------------------
1747 78FA      3352       mov R0, #250
1749           3353   Reset_Delay_Outer:
1749 79FF      3354       mov R1, #255
174B           3355   Reset_Delay_Inner:
174B D9FE      3356       djnz R1, Reset_Delay_Inner
174D D8FA      3357       djnz R0, Reset_Delay_Outer
174F           3358       
174F           3359       ; --- PORT CONFIGURATION ---
174F 759AAA    3360       mov P0MOD, #0xAA
1752           3361       ; P1: Mixed usage 
1752           3362       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
1752           3363       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
1752           3364       ; P1.0 (Unused/RX) -> Input
1752           3365       ; Binary: 11111110 -> Hex: 0xFE
1752 759BFE    3366       mov P1MOD, #0xFE
1755           3367   
1755           3368       ; P2: Row4(Out), Cols(In)
1755           3369       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
1755           3370       ; Binary: 00000001 -> Hex: 0x01
1755 759C01    3371       mov P2MOD, #0x01
1758           3372   
1758           3373       ; P3: Col4(In)
1758           3374       ; P3.0 (Col4) is In (0).
1758 759D5C    3375       mov P3MOD, #01011100B
175B 75C101    3376       mov P4MOD, #00000001B
175E           3377   
175E           3378       ; Turn off all the LEDs
175E 75E800    3379       mov LEDRA, #0 ; LEDRA is bit addressable
1761 759500    3380       mov LEDRB, #0 ; LEDRB is NOT bit addresable
1764           3381   
1764           3382       ; Enable Global interrupts
1764 D2AF      3383       setb EA  
1766           3384   
1766           3385            ; FSM initial states
1766 757000    3386            mov SEC_FSM_state, #0
1769 756000    3387            mov Control_FSM_state, #0
176C 756100    3388            mov Current_State, #0
176F           3389            ; FSM timers initialization
176F 756F00    3390            mov SEC_FSM_timer, #0
1772           3391            ; time counters initialization
1772 753000    3392            mov current_time_sec, #0
1775 753100    3393            mov current_time_minute, #0
1778 753200    3394            mov soak_time_sec, #0
177B 753300    3395            mov soak_time_minute, #0
177E 753400    3396            mov reflow_time_sec, #0
1781 753500    3397            mov reflow_time_minute, #0
1784 753600    3398            mov soak_end_time_sec, #0
1787 753700    3399            mov soak_end_time_minute, #0
178A 753800    3400            mov reflow_end_time_sec, #0
178D 753900    3401            mov reflow_end_time_minute, #0
1790           3402       ; Initialize counter to zero
1790 755C00    3403       mov pwm_counter, #0
1793 755D00    3404       mov pwm_counter+1, #0
1796 755E00    3405       mov pwm_counter+2, #0
1799 755F00    3406       mov pwm_counter+3, #0
179C           3407       ; Initialize power output
179C 755B00    3408       mov power_output+3, #0
179F 755A00    3409       mov power_output+2, #0
17A2 755902    3410       mov power_output+1, #02H
17A5 7558EE    3411       mov power_output, #0EEH ; (initilize to 750 for testing)
17A8           3412            ; FSM Buttons push button init
17A8 757200    3413            mov     PB0_DEB_state, #0
17AB 757400    3414            mov     PB2_DEB_state, #0
17AE 757100    3415            mov     PB0_DEB_timer, #0
17B1 757300    3416            mov     PB2_DEB_timer, #0
17B4           3417       ; [FIX] ADD THIS BLOCK TO STOP STARTUP BEEP
17B4 757600    3418       mov beep_state, #0
17B7 757500    3419       mov beep_count, #0
17BA 757700    3420       mov beep_tmr, #0
17BD 757800    3421       mov beep_tmr+1, #0
17C0           3422       ; Buttons 
17C0 757A00    3423       mov BTN_DEB_state, #0
17C3 757B00    3424       mov BTN_DEB_timer, #0
17C6 757C00    3425       mov BTN_DEB_id, #0
17C9 757900    3426       mov servo_pwm_counter, #0
17CC 757D00    3427       mov rx_idx, #0
17CF 757E00    3428       mov rx_ready, #0
17D2 C218      3429       clr one_ms_beep_flag
17D4 C28C      3430       clr TR0 ; Force buzzer hardware OFF
17D6           3431   
17D6           3432            ; Clear all the flags
17D6 C295      3433            clr SOUND_OUT
17D8 C219      3434       clr beep_error_done
17DA C213      3435            clr tc_missing_abort
17DC C20B      3436            clr stop_signal
17DE C215      3437            clr PB0_flag
17E0 C216      3438            clr PB1_flag
17E2 C217      3439            clr PB2_flag
17E4 C201      3440            clr one_second_flag
17E6 C204      3441            clr one_second_lcd_flag
17E8 C20E      3442            clr config_finish_signal
17EA C20D      3443       clr time_count_doing_signal
17EC C224      3444       clr fullscreen_update_signal
17EE C205      3445            clr soak_temp_reached
17F0 C208      3446            clr soak_time_reached
17F2 C206      3447            clr reflow_temp_reached
17F4 C209      3448            clr reflow_time_reached
17F6 C207      3449            clr cooling_temp_reached
17F8 C210      3450       clr state_change_signal_TC
17FA C211      3451            clr state_change_signal_Count
17FC C212      3452       clr state_change_beep_signal
17FE C226      3453       clr one_millisecond_flag_servo
1800 C229      3454       clr remote_config_mode
1802 C2C0      3455       clr DC_OUT
1804           3456       ; Set bit
1804 D20F      3457            setb state_change_signal
1806 D214      3458       setb tc_startup_window
1808           3459   
1808 120B3D    3460       lcall Clear_Screen_Func
180B 121709    3461       lcall Boot_Line_Display_Func
180E 12047D    3462       lcall Timer0_Init
1811 1206C6    3463       lcall Timer2_Init
1814 120799    3464       lcall ELCD_4BIT
1817           3465       ;----- Two new lines I added to initialize the UI
1817 1211E6    3466       lcall Init_All_Buffers
181A 120497    3467       lcall Initialize_Serial_Port
181D 1215D2    3468       lcall music
1820           3469   ;-------------------------------------------------------------------------------;
1820           3470   ; while(1) loop
1820           3471   ;-------------------------------------------------------------------------------;
1820           3472   loop:
1820           3473   
1820 120BF0    3474            lcall SEC_FSM
1823           3475   
1823           3476            ; Check the FSM for the overall control flow of the reflow process
1823 120E9C    3477       lcall Control_FSM
1826           3478   
1826           3479       ; Check the FSM for PB01 debounce
1826 120B82    3480       lcall PB0_DEB
1829 120BBA    3481            lcall PB2_DEB
182C           3482       
182C           3483       ; Added to take temp readings
182C 121239    3484       lcall Read_Thermocouple
182F           3485       
182F           3486       ; 1. Check if we reached temp (Observer)
182F 120CDB    3487       lcall Temp_Compare
1832           3488       
1832           3489       ; 2. Decide heater power based on flags (Driver)
1832           3490       ;lcall Power_Control
1832 1213CC    3491       lcall proportional_power_control
1835           3492       
1835 120DCC    3493       lcall Safety_Check_TC
1838           3494   
1838 120C4C    3495            lcall Time_Counter
183B           3496   
183B           3497            ; Update Variables (times and temp)
183B 120F77    3498            lcall Update_FSM_Variables
183E           3499   
183E           3500       ; GUI Interface polling uart port
183E 1204CC    3501       lcall Serial_RX_Pump
1841 120525    3502       lcall Serial_Process_Line
1844           3503   
1844           3504            ; Update while at state 1
1844           3505            ; LCD
1844 120A2E    3506            lcall Update_Screen_Full 
1847           3507            ; Buttons
1847 120FFB    3508            lcall Check_Buttons 
184A           3509            ; PB0pad
184A 1210BA    3510       lcall Check_Keypad
184D           3511   
184D           3512       ; Update the LCD display based on the current state
184D 12085E    3513       lcall LCD_Display_Update_func
1850           3514   
1850 120C6E    3515            lcall Time_Compare_MMSS
1853           3516   
1853           3517       ; Update the pwm output for the ssr
1853 120D55    3518       lcall PWM_Wave 
1856           3519            ; Update the Buzzer 
1856 120E63    3520            lcall Beep_Task
1859           3521       ; Update the pwm output for the servo
1859 12130E    3522       lcall call_servo_control
185C           3523   
185C 120E1A    3524       lcall Beep_Judge
185F           3525   
185F 1216D3    3526       lcall dc_control
1862           3527   
1862           3528       ; After initialization the program stays in this 'forever' loop
1862 021820    3529       ljmp loop
1865           3530   ;-------------------------------------------------------------------------------;
1865           3531   END
