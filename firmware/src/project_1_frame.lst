0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 020A4E       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9            reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 020414      12            ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15            reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18            reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21            reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 02047F      24            ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 29   $LIST
0320             31   ; ----------------------------------------------------------------------------------------------;
0320             32   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             33   dseg at 0x30
0030             34   current_time_sec:     ds 1
0031             35   current_time_minute:  ds 1
0032             36   ; math32 buffer variables
0032             37   x:               ds      4
0036             38   y:               ds      4
003A             39   bcd:     ds      5
003F             40   
003F             41   current_temp: ds 4 ;
0043             42   soak_temp:    ds 4 ;
0047             43   reflow_temp:  ds 4 ;
004B             44   
004B             45   current_time: ds 4 ;
004F             46   soak_time:    ds 4 ;
0053             47   reflow_time:  ds 4 ;
0057             48   
0057             49   power_output:  ds 4 ;
005B             50   pwm_counter: ds 4 ; counter for pwm (0-1500)
005F             51   
005F             52   KEY1_DEB_timer: ds 1
0060             53   SEC_FSM_timer:  ds 1
0061             54   KEY1_DEB_state:    ds 1
0062             55   SEC_FSM_state:      ds 1
0063             56   Control_FSM_state: ds 1 
0064             57   btn_last: ds 1
0065             58   enter_last: ds 1
0066             59   state_timer: ds 1
0067             60   ; 46d bytes used
0067             61   
0067             62   ;-------------------------------------------------------------------------------
0067             63   ; bit operation setb, clr, jb, and jnb
0000             64   bseg
0000             65   mf:              dbit 1 ; math32 sign
0001             66   one_second_flag: dbit 1
0002             67   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003             68   one_ms_ui_flag: dbit 1  ; 1ms tick for UI debounce
0004             69   
0004             70   soak_temp_reached: dbit 1
0005             71   reflow_temp_reached: dbit 1
0006             72   cooling_temp_reached: dbit 1
0007             73   
0007             74   soak_time_reached: dbit 1
0008             75   reflow_time_reached: dbit 1
0009             76   
0009             77   reset_signal: dbit 1
000A             78   stop_signal: dbit 1
000B             79   start_signal: dbit 1
000C             80   config_finish_signal: dbit 1
000D             81   
000D             82   state_change_signal: dbit 1
000E             83   
000E             84   Key1_flag: dbit 1
000F             85   enter_event: dbit 1
0010             86   
0010             87   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
0011             88   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0012             89   PB0_flag: dbit 1 ; start entire program
0013             90   PB1_flag: dbit 1 ; start soak
0014             91   PB2_flag: dbit 1 ; pause process
0015             92   ; 11 bits used
0015             93   
0015             94   ;-------------------------------------------------------------------------------
0320             95   cseg
0320             96   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320             97   BAUD                EQU 57600
0320             98   
0320             99   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            100   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            101   ; is always 12 unlike the N76E003 where is selectable.
0320            102   
0320            103   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            104   
0320            105   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            106   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            107   
0320            108   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            109   POWER_FULL     EQU PWM_PERIOD
0320            110   POWER_20       EQU 300
0320            111   POWER_0        EQU 0
0320            112   
0320            113   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            114   
0320            115   PWM_OUT             EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            116   
0320            117   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            118   ; P0 is in connector JPIO.
0320            119   ELCD_RS equ P3.7
0320            120   ELCD_RW equ P3.5
0320            121   ELCD_E  equ P3.3
0320            122   ELCD_D4 equ P3.1
0320            123   ELCD_D5 equ P2.7
0320            124   ELCD_D6 equ P2.5
0320            125   ELCD_D7 equ P2.3
0320            126   
0320            127   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   128   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   129   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   130   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            131   
0350            132   ;                       1234567890123456
0350 53657420   133   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
0360 536F616B   134   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
036B 5265666C   135   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
0378 536F616B   136   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
0383 5265666C   137   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
0390            138   
0390            139   ;                     1234567890123456
0390 52616D70   140   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03A0 536F616B   141   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
03B0 52616D70   142   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
03C0 5265666C   143   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
03D0 436F6F6C   144   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
03E0 50726F63   145   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
03F0            146   
03F0 20202020   147   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
0401            148   
0401            149   ;-------------------------------------------------------------------------------
0401            150   ; Timers Setting:
0401            151   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
0401            152   ;        Timer 1: Serial port baud rate 57600 generator
0401            153   ;        Timer 2: 1ms interrupt for BCD counter increment/decrement
0401            154   ;-------------------------------------------------------------------------------
0401            155   ; Routine to initialize the ISR for Timer 0 ;
0401            156   Timer0_Init:
0401 E589       157            mov a, TMOD
0403 54F0       158            anl a, #0xf0 ; Clear the bits for timer 0
0405 4401       159            orl a, #0x01 ; Configure timer 0 as 16-timer
0407 F589       160            mov TMOD, a
0409 758CFD     161            mov TH0, #high(TIMER0_RELOAD)
040C 758A5A     162            mov TL0, #low(TIMER0_RELOAD)
040F            163            ; Enable the timer and interrupts
040F D2A9       164       setb ET0  ; Enable timer 0 interrupt
0411 D28C       165       setb TR0  ; Start timer 0
0413 22         166            ret
0414            167   ; ISR for timer 0.  Set to execute every 1/4096Hz 
0414            168   ; to generate a 2048 Hz square wave at pin P1.5 
0414            169   Timer0_ISR:
0414            170            ;clr TF0  ; According to the data sheet this is done for us already.
0414 758CFD     171            mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0417 758A5A     172            mov TL0, #low(TIMER0_RELOAD)
041A B295       173            cpl SOUND_OUT ; Connect speaker to P1.5
041C 32         174            reti
041D            175   ; -----------------------------------------------------------------------------------------------;
041D            176   
041D            177   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
041D            178   Initialize_Serial_Port:
041D            179            ; Configure serial port and baud rate
041D C28E       180            clr TR1 ; Disable timer 1
041F 53890F     181            anl TMOD, #0x0f ; Mask the bits for timer 1
0422 438920     182            orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
0425 438780     183       orl PCON, #80H ; Set SMOD to 1
0428 758DFD     184            mov TH1, #low(TIMER_1_RELOAD)
042B 758BFD     185            mov TL1, #low(TIMER_1_RELOAD) 
042E D28E       186            setb TR1 ; Enable timer 1
0430 759852     187            mov SCON, #52H
0433 22         188            ret
0434            189   
0434            190   ; uart sending functions
0434            191   putchar:
0434            192            ; non-blocking: if not ready, drop byte
0434 309904     193            jnb TI, putchar_done
0437 C299       194            clr TI
0439 F599       195            mov     SBUF,a
043B            196   putchar_done:
043B 22         197            ret
043C            198   
043C            199   SendString:
043C E4         200       clr a
043D 93         201       movc a, @a+dptr
043E 6006       202       jz SendString_L1
0440 120434     203       lcall putchar
0443 A3         204       inc dptr
0444 80F6       205       sjmp SendString  
0446            206   SendString_L1:
0446 22         207            ret
0447            208   
0447            209   ;-------------------------------------------------------------------------------
0447            210   ; serial debugging
0447            211   ; send a four byte number via serial to laptop
0447            212   ; need to be used with python script
0447            213   ; content needed to be sent should be stored in the varaible x
0447            214   ;-------------------------------------------------------------------------------
0447            215   Send32:
0447            216       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
0447 74AA       217       mov A, #0AAH
0449 120434     218       lcall putchar
044C 7455       219       mov A, #055H
044E 120434     220       lcall putchar
0451            221   
0451 E535       222       mov A, x+3
0453 120434     223       lcall putchar
0456 E534       224       mov A, x+2
0458 120434     225       lcall putchar
045B E533       226       mov A, x+1
045D 120434     227       lcall putchar
0460 E532       228       mov A, x+0
0462 120434     229       lcall putchar
0465            230   
0465 740A       231       mov A, #0AH
0467 120434     232       lcall putchar
046A 22         233       ret
046B            234   ; -----------------------------------------------------------------------------------------------;
046B            235   
046B            236   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
046B              1   ;------------------------------------------------------------------------------------------------;
046B              2   ; Routine to initialize the ISR for timer 2 
046B              3   Timer2_Init:
046B 75C800       4            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
046E 75CDF5       5            mov TH2, #high(TIMER2_RELOAD)
0471 75CC27       6            mov TL2, #low(TIMER2_RELOAD)
0474              7            ; Set the reload value
0474 75CBF5       8            mov RCAP2H, #high(TIMER2_RELOAD)
0477 75CA27       9            mov RCAP2L, #low(TIMER2_RELOAD)
047A             10            ; Enable the timer and interrupts
047A D2AD        11       setb ET2  ; Enable timer 2 interrupt
047C D2CA        12       setb TR2  ; Enable timer 2
047E 22          13            ret
047F             14   
047F             15   ; ISR for timer 2.  Runs every 1 ms ;
047F             16   Timer2_ISR:
047F C0E0        17            push acc
0481 C0D0        18            push psw
0483 C2CF        19            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0485             20            ; cpl P1.1 ; Optional debug pin toggle for scope (ensure it's not used elsewhere)
0485             21   
0485             22   ; FSM states timers
0485 055F        23            inc KEY1_DEB_timer
0487 0560        24            inc SEC_FSM_timer
0489             25   
0489 D202        26            setb one_ms_pwm_flag ; set the one millisecond flag for pwm signal generation
048B D203        27            setb one_ms_ui_flag  ; 1ms tick for UI debounce
048D             28   
048D             29   Timer2_ISR_done:
048D D0D0        30            pop psw
048F D0E0        31            pop acc
0491 32          32            reti
0492             33   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
0492              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
0492              2   cseg
0492              3   
0492              4   ; When using a 33.333333MHz crystal clock
0492              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
0492              6   
0492              7   ;---------------------------------;
0492              8   ; Wait 40 microseconds            ;
0492              9   ;---------------------------------;
0492             10   Wait40uSec:
0492 C000        11            push AR0
0494 78BE        12            mov R0, #190
0496             13   L0: 
0496 00          14            nop
0497 00          15            nop
0498 00          16            nop
0499 00          17            nop
049A D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
049C D000        19            pop AR0
049E 22          20       ret
049F             21   
049F             22   ;---------------------------------;
049F             23   ; Wait 'R2' milliseconds          ;
049F             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
049F             31   
049F             32   ?Wait_Milli_Seconds:
049F C000        33            push AR0
04A1 C001        34            push AR1
04A3 7932        35   L3: mov R1, #50
04A5 78DF        36   L2: mov R0, #223
04A7 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
04A9 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
04AB DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
04AD D001        40       pop AR1
04AF D000        41       pop AR0
04B1 22          42       ret
04B2             43            
04B2             44   ;---------------------------------;
04B2             45   ; Toggles the 'E' pin in the LCD  ;
04B2             46   ;---------------------------------;
04B2             47   ELCD_pulse:
04B2 D2B3        48            setb ELCD_E
04B4 120492      49            lcall Wait40uSec
04B7 C2B3        50            clr ELCD_E
04B9 120492      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
04BC 22          52       ret
04BD             53   
04BD             54   ;---------------------------------;
04BD             55   ; Writes acc to LCD in 4-bit mode ;
04BD             56   ;---------------------------------;
04BD             57   ELCD_byte:
04BD             58            ; Write high 4 bits first
04BD A2E7        59            mov c, ACC.7
04BF 92A3        60            mov ELCD_D7, c
04C1 A2E6        61            mov c, ACC.6
04C3 92A5        62            mov ELCD_D6, c
04C5 A2E5        63            mov c, ACC.5
04C7 92A7        64            mov ELCD_D5, c
04C9 A2E4        65            mov c, ACC.4
04CB 92B1        66            mov ELCD_D4, c
04CD 1204B2      67       lcall ELCD_pulse
04D0             68            ; Write low 4 bits next
04D0 A2E3        69            mov c, ACC.3
04D2 92A3        70            mov ELCD_D7, c
04D4 A2E2        71            mov c, ACC.2
04D6 92A5        72            mov ELCD_D6, c
04D8 A2E1        73            mov c, ACC.1
04DA 92A7        74            mov ELCD_D5, c
04DC A2E0        75            mov c, ACC.0
04DE 92B1        76            mov ELCD_D4, c
04E0 1204B2      77       lcall ELCD_pulse
04E3 22          78            ret
04E4             79   
04E4             80   ;---------------------------------;
04E4             81   ; Write data to LCD               ;
04E4             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
04E4             87            
04E4             88   ?WriteData:
04E4 D2B7        89            setb ELCD_RS
04E6 0204BD      90            ljmp ELCD_byte
04E9             91   
04E9             92   ;---------------------------------;
04E9             93   ; Write command to LCD            ;
04E9             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
04E9             99   
04E9            100   ?WriteCommand:
04E9 C2B7       101            clr ELCD_RS
04EB 0204BD     102            ljmp ELCD_byte
04EE            103   
04EE            104   ;---------------------------------;
04EE            105   ; Configure LCD in 4-bit mode     ;
04EE            106   ;---------------------------------;
04EE            107   ELCD_4BIT:
04EE C2B3       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
04F0            109            ;clr ELCD_RW  ; RW forced to zero
04F0            110            
04F0            111            ; After power on, let the LCD start up before initializing
04F0 C002       112            push AR2
04F2 7A28       112            mov R2, #40
04F4 12049F     112            lcall ?Wait_Milli_Seconds
04F7 D002       112            pop AR2
04F9            112   
04F9            113            
04F9            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
04F9 7433       115            mov a, #0x33
04FB 1204E9     115            lcall ?WriteCommand
04FE 7433       116            mov a, #0x33
0500 1204E9     116            lcall ?WriteCommand
0503 7432       117            mov a, #0x32
0505 1204E9     117            lcall ?WriteCommand ; change to 4-bit mode
0508            118   
0508            119            ; Configure the LCD
0508 7428       120            mov a, #0x28
050A 1204E9     120            lcall ?WriteCommand
050D 740C       121            mov a, #0x0c
050F 1204E9     121            lcall ?WriteCommand
0512 7401       122            mov a, #0x01
0514 1204E9     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
0517            123   
0517            124       ;Wait for the clear screen command to finish.
0517 C002       125            push AR2
0519 7A02       125            mov R2, #2
051B 12049F     125            lcall ?Wait_Milli_Seconds
051E D002       125            pop AR2
0520            125   
0520 22         126       ret
0521            127   
0521            128   ;---------------------------------;
0521            129   ; Send a constant string to LCD   ;
0521            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
0521            141   
0521            142   ?Send_Constant_String:
0521 E4         143       clr a
0522 93         144       movc a, @a+dptr
0523 6006       145       jz ?Send_Constant_String_Done
0525 1204E4     146       lcall ?WriteData
0528 A3         147       inc dptr
0529 80F6       148       sjmp ?Send_Constant_String
052B            149   ?Send_Constant_String_Done:
052B 22         150       ret  
052C            151   
052C            152   ;---------------------------------;
052C            153   ; Set LCD cursor at row, column   ;
052C            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
052C            162   
052C            163   ?Set_Cursor_2:
052C 4440       164            orl a, #01000000B
052E            165   ?Set_Cursor_1:
052E 4480       166            orl a, #10000000B
0530 0204E9     167            ljmp ?WriteCommand ; Select column and row
0533            168   
0533            169   ;---------------------------------;
0533            170   ; Display a BCD number in the LCD ;
0533            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
0533            178   
0533            179   ?Display_BCD:
0533 C0E0       180            push acc
0535            181            ; Write most significant digit
0535 E8         182            mov a, r0
0536 C4         183            swap a
0537 540F       184            anl a, #0fh
0539 4430       185            orl a, #30h
053B 1204E4     186            lcall ?WriteData
053E            187            ; write least significant digit
053E E8         188            mov a, r0
053F 540F       189            anl a, #0fh
0541 4430       190            orl a, #30h
0543 1204E4     191            lcall ?WriteData
0546 D0E0       192            pop acc
0548 22         193            ret
0549            194   
0549            195   ;------------------------------------;
0549            196   ; Display a char in the LCD          ;
0549            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
0549            204   
0549            239            ;-----------------------------------------------------------------------------------------------;
0549            240   
0549            241   ;-------------------------------------------------------------------------------
0549            242   ; Display Function for 7-segment displays                
0549            243   ;-------------------------------------------------------------------------------
0549            244   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0549            245   T_7seg:
0549 C0F9A4B0   246       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
054E 9282F880   247       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
0553 8883C6A1   248       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0559            249   
0559            250   ; Displays a BCD number pased in R0 in HEX5-HEX0
0559            251   Display_BCD_7_Seg_HEX10:
0559 900549     252            mov dptr, #T_7seg
055C E8         253            mov a, R0
055D C4         254            swap a
055E 540F       255            anl a, #0FH
0560 93         256            movc a, @a+dptr
0561 F592       257            mov HEX1, a
0563 E8         258            mov a, R0
0564 540F       259            anl a, #0FH
0566 93         260            movc a, @a+dptr
0567 F591       261            mov HEX0, a
0569 22         262            ret
056A            263   
056A            264   Display_BCD_7_Seg_HEX32:
056A 900549     265            mov dptr, #T_7seg
056D E8         266            mov a, R0
056E C4         267            swap a
056F 540F       268            anl a, #0FH
0571 93         269            movc a, @a+dptr
0572 F594       270            mov HEX3, a
0574 E8         271            mov a, R0
0575 540F       272            anl a, #0FH
0577 93         273            movc a, @a+dptr
0578 F593       274            mov HEX2, a
057A 22         275            ret
057B            276   
057B            277   Display_BCD_7_Seg_HEX54:
057B 900549     278            mov dptr, #T_7seg
057E E8         279            mov a, R0
057F C4         280            swap a
0580 540F       281            anl a, #0FH
0582 93         282            movc a, @a+dptr
0583 F58F       283            mov HEX5, a
0585 E8         284            mov a, R0
0586 540F       285            anl a, #0FH
0588 93         286            movc a, @a+dptr
0589 F58E       287            mov HEX4, a
058B 22         288            ret
058C            289   
058C            290   ; The 8-bit hex number passed in the accumulator is converted to
058C            291   ; BCD and stored in [R1, R0]
058C            292   Hex_to_bcd_8bit:
058C 75F064     293            mov b, #100
058F 84         294            div ab
0590 F9         295            mov R1, a   ; After dividing, a has the 100s
0591 E5F0       296            mov a, b    ; Remainder is in register b
0593 75F00A     297            mov b, #10
0596 84         298            div ab ; The tens are stored in a, the units are stored in b 
0597 C4         299            swap a
0598 54F0       300            anl a, #0xf0
059A 45F0       301            orl a, b
059C F8         302            mov R0, a
059D 22         303            ret
059E            304   
059E            305   ;-------------------------------------------------------------------------------
059E            306   ; Display Function for LCD                                               
059E            307   ;-------------------------------------------------------------------------------
059E            308   LCD_Display_Update_func:
059E C0E0       309            push acc
05A0 200D03     310            jb  state_change_signal, LCD_Display_Update_Go
05A3 0206D9     311            ljmp LCD_Display_Update_Skip
05A6            312   LCD_Display_Update_Go:
05A6 C20D       313            clr state_change_signal
05A8 E563       314            mov a, Control_FSM_state
05AA            315   
05AA            316   LCD_Display_Update_0:
05AA B4003B     317            cjne a, #0, LCD_Display_Update_1
05AD C0E0       318            push acc
05AF 7401       318            mov a, #1
05B1 14         318            dec a
05B2 12052E     318            lcall ?Set_Cursor_1 ; Select column and row
05B5 D0E0       318            pop acc
05B7 C083       319            push dph
05B9 C082       319            push dpl
05BB C0E0       319            push acc
05BD 900330     319            mov dptr, #String_state0_1
05C0 120521     319            lcall ?Send_Constant_String
05C3 D0E0       319            pop acc
05C5 D082       319            pop dpl
05C7 D083       319            pop dph
05C9 C0E0       320            push acc
05CB 7401       320            mov a, #1
05CD 14         320            dec a
05CE 12052C     320            lcall ?Set_Cursor_2 ; Select column and row
05D1 D0E0       320            pop acc
05D3 C083       321            push dph
05D5 C082       321            push dpl
05D7 C0E0       321            push acc
05D9 900340     321            mov dptr, #String_state0_2
05DC 120521     321            lcall ?Send_Constant_String
05DF D0E0       321            pop acc
05E1 D082       321            pop dpl
05E3 D083       321            pop dph
05E5 0206D6     322            ljmp LCD_Display_Update_done
05E8            323   
05E8            324   LCD_Display_Update_1:
05E8 B4011F     325            cjne a, #1, LCD_Display_Update_2
05EB C0E0       326            push acc
05ED 7401       326            mov a, #1
05EF 14         326            dec a
05F0 12052E     326            lcall ?Set_Cursor_1 ; Select column and row
05F3 D0E0       326            pop acc
05F5 C083       327            push dph
05F7 C082       327            push dpl
05F9 C0E0       327            push acc
05FB 900390     327            mov dptr, #String_state2
05FE 120521     327            lcall ?Send_Constant_String
0601 D0E0       327            pop acc
0603 D082       327            pop dpl
0605 D083       327            pop dph
0607 0206D6     328            ljmp LCD_Display_Update_done
060A            329   
060A            330   LCD_Display_Update_2:
060A B4021F     331            cjne a, #2, LCD_Display_Update_3
060D C0E0       332            push acc
060F 7401       332            mov a, #1
0611 14         332            dec a
0612 12052E     332            lcall ?Set_Cursor_1 ; Select column and row
0615 D0E0       332            pop acc
0617 C083       333            push dph
0619 C082       333            push dpl
061B C0E0       333            push acc
061D 9003A0     333            mov dptr, #String_state3
0620 120521     333            lcall ?Send_Constant_String
0623 D0E0       333            pop acc
0625 D082       333            pop dpl
0627 D083       333            pop dph
0629 0206D6     334            ljmp LCD_Display_Update_done
062C            335   
062C            336   LCD_Display_Update_3:
062C B4031F     337            cjne a, #3, LCD_Display_Update_4
062F C0E0       338            push acc
0631 7401       338            mov a, #1
0633 14         338            dec a
0634 12052E     338            lcall ?Set_Cursor_1 ; Select column and row
0637 D0E0       338            pop acc
0639 C083       339            push dph
063B C082       339            push dpl
063D C0E0       339            push acc
063F 9003B0     339            mov dptr, #String_state4
0642 120521     339            lcall ?Send_Constant_String
0645 D0E0       339            pop acc
0647 D082       339            pop dpl
0649 D083       339            pop dph
064B 0206D6     340            ljmp LCD_Display_Update_done
064E            341   
064E            342   LCD_Display_Update_4:
064E B4041F     343            cjne a, #4, LCD_Display_Update_5
0651 C0E0       344            push acc
0653 7401       344            mov a, #1
0655 14         344            dec a
0656 12052E     344            lcall ?Set_Cursor_1 ; Select column and row
0659 D0E0       344            pop acc
065B C083       345            push dph
065D C082       345            push dpl
065F C0E0       345            push acc
0661 9003C0     345            mov dptr, #String_state5
0664 120521     345            lcall ?Send_Constant_String
0667 D0E0       345            pop acc
0669 D082       345            pop dpl
066B D083       345            pop dph
066D 0206D6     346            ljmp LCD_Display_Update_done
0670            347   
0670            348   LCD_Display_Update_5:
0670 B4051F     349            cjne a, #5, LCD_Display_Update_6
0673 C0E0       350            push acc
0675 7401       350            mov a, #1
0677 14         350            dec a
0678 12052E     350            lcall ?Set_Cursor_1 ; Select column and row
067B D0E0       350            pop acc
067D C083       351            push dph
067F C082       351            push dpl
0681 C0E0       351            push acc
0683 9003D0     351            mov dptr, #String_state6
0686 120521     351            lcall ?Send_Constant_String
0689 D0E0       351            pop acc
068B D082       351            pop dpl
068D D083       351            pop dph
068F 0206D6     352            ljmp LCD_Display_Update_done
0692            353   
0692            354   LCD_Display_Update_6:
0692 B4061F     355            cjne a, #6, LCD_Display_Update_7
0695 C0E0       356            push acc
0697 7401       356            mov a, #1
0699 14         356            dec a
069A 12052E     356            lcall ?Set_Cursor_1 ; Select column and row
069D D0E0       356            pop acc
069F C083       357            push dph
06A1 C082       357            push dpl
06A3 C0E0       357            push acc
06A5 9003D0     357            mov dptr, #String_state6
06A8 120521     357            lcall ?Send_Constant_String
06AB D0E0       357            pop acc
06AD D082       357            pop dpl
06AF D083       357            pop dph
06B1 0206D6     358            ljmp LCD_Display_Update_done
06B4            359   
06B4            360   LCD_Display_Update_7:
06B4 B4071F     361            cjne a, #7, LCD_Display_Update_done
06B7 C0E0       362            push acc
06B9 7401       362            mov a, #1
06BB 14         362            dec a
06BC 12052E     362            lcall ?Set_Cursor_1 ; Select column and row
06BF D0E0       362            pop acc
06C1 C083       363            push dph
06C3 C082       363            push dpl
06C5 C0E0       363            push acc
06C7 9003E0     363            mov dptr, #String_state7
06CA 120521     363            lcall ?Send_Constant_String
06CD D0E0       363            pop acc
06CF D082       363            pop dpl
06D1 D083       363            pop dph
06D3 0206D6     364            ljmp LCD_Display_Update_done
06D6            365   
06D6            366   LCD_Display_Update_done:
06D6 D0E0       367            pop acc
06D8 22         368            ret
06D9            369   LCD_Display_Update_Skip:
06D9 0206D6     370            ljmp LCD_Display_Update_done
06DC            371   
06DC            372   LCD_Display_Update_Temp:
06DC            373            
06DC            374   ;---------------------------------------------------------
06DC            375   
06DC            376   KEY1_DEB:
06DC            377   ;non-blocking state machine for KEY1 debounce
06DC E561       378            mov a, KEY1_DEB_state
06DE            379   KEY1_DEB_state0:
06DE B4000A     380            cjne a, #0, KEY1_DEB_state1
06E1 20F92D     381            jb KEY.1, KEY1_DEB_done
06E4 755F00     382            mov KEY1_DEB_timer, #0
06E7 0561       383            inc KEY1_DEB_state
06E9 8026       384            sjmp KEY1_DEB_done
06EB            385   KEY1_DEB_state1:
06EB B40109     386            cjne a, #1, KEY1_DEB_state2
06EE            387            ; this is the debounce state
06EE E55F       388            mov a, KEY1_DEB_timer
06F0 B4321E     389            cjne a, #50, KEY1_DEB_done ; 50 ms passed?
06F3 0561       390            inc KEY1_DEB_state
06F5 801A       391            sjmp KEY1_DEB_done      
06F7            392   KEY1_DEB_state2:
06F7 B4020C     393            cjne a, #2, KEY1_DEB_state3
06FA 20F904     394            jb KEY.1, KEY1_DEB_state2b
06FD 0561       395            inc KEY1_DEB_state
06FF 8010       396            sjmp KEY1_DEB_done      
0701            397   KEY1_DEB_state2b:
0701 756100     398            mov KEY1_DEB_state, #0
0704 800B       399            sjmp KEY1_DEB_done
0706            400   KEY1_DEB_state3:
0706 B40308     401            cjne a, #3, KEY1_DEB_done
0709 30F905     402            jnb KEY.1, KEY1_DEB_done
070C D20E       403            setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
070E 756100     404            mov KEY1_DEB_state, #0  
0711            405   KEY1_DEB_done:
0711 22         406            ret
0712            407   
0712            408   ; ------------------------------------------------------------------------------
0712            409   ; Non-blocking FSM for the one second counter
0712            410   ;-------------------------------------------------------------------------------
0712            411   SEC_FSM:
0712 E562       412            mov a, SEC_FSM_state
0714            413   SEC_FSM_state0:
0714 B4000C     414            cjne a, #0, SEC_FSM_state1
0717 E560       415            mov a, SEC_FSM_timer
0719 B4FA57     416            cjne a, #250, SEC_FSM_done ; 250 ms passed?
071C 756000     417            mov SEC_FSM_timer, #0
071F 0562       418            inc SEC_FSM_state
0721 8050       419            sjmp SEC_FSM_done
0723            420   SEC_FSM_state1:  
0723 B4010E     421            cjne a, #1, SEC_FSM_state2
0726 D2E9       422            setb LEDRA.1
0728 E560       423            mov a, SEC_FSM_timer
072A B4FA46     424            cjne a, #250, SEC_FSM_done ; 250 ms passed?
072D 756000     425            mov SEC_FSM_timer, #0
0730 0562       426            inc SEC_FSM_state
0732 803F       427            sjmp SEC_FSM_done
0734            428   SEC_FSM_state2:  
0734 B4020E     429            cjne a, #2, SEC_FSM_state3
0737 D2EA       430            setb LEDRA.2
0739 E560       431            mov a, SEC_FSM_timer
073B B4FA35     432            cjne a, #250, SEC_FSM_done ; 250 ms passed?
073E 756000     433            mov SEC_FSM_timer, #0
0741 0562       434            inc SEC_FSM_state
0743 802E       435            sjmp SEC_FSM_done
0745            436   SEC_FSM_state3:  
0745 B4032B     437            cjne a, #3, SEC_FSM_done
0748 D2EB       438            setb LEDRA.3
074A E560       439            mov a, SEC_FSM_timer
074C B4FA24     440            cjne a, #250, SEC_FSM_done ; 250 ms passed?
074F 756000     441            mov SEC_FSM_timer, #0
0752 756200     442            mov SEC_FSM_state, #0
0755 E530       443            mov a, current_time_sec
0757 B43B07     444            cjne a, #59, IncCurrentTimeSec ; Don't let the seconds counter pass 59
075A 753000     445            mov current_time_sec, #0
075D 0531       446            inc current_time_minute
075F 8004       447            sjmp Sec_FSM_1Hz_Done
0761            448   IncCurrentTimeSec:
0761 0530       449            inc current_time_sec
0763 B2E8       450            cpl LEDRA.0 ; 1 Hz heartbeat LED
0765            451   Sec_FSM_1Hz_Done:
0765            452            ; increment per-state timer when in timed states (2 or 4)
0765 E563       453            mov a, Control_FSM_state
0767 B40204     454            cjne a, #2, Sec_FSM_Check4
076A 0566       455            inc state_timer
076C 8005       456            sjmp SEC_FSM_done
076E            457   Sec_FSM_Check4:
076E B40402     458            cjne a, #4, SEC_FSM_done
0771 0566       459            inc state_timer
0773            460   SEC_FSM_done:
0773 22         461            ret
0774            462   
0774            463   ;-------------------------------------------------------------------------------
0774            464   ; PWM
0774            465   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0774            466   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0774            467   ; ------------------------------------------------------------------------------
0774            468   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0774 100202     469            jbc one_ms_pwm_flag, pwm_wave_generator
0777 8071       470            sjmp end_pwm_generator
0779            471   
0779            472   pwm_wave_generator:
0779 C200       473            clr mf
077B            474            ; move pwm counter value into x for comparison purpose
077B 855B32     475            mov x, pwm_counter
077E 855C33     476            mov x+1, pwm_counter+1
0781 855D34     477            mov x+2, pwm_counter+2
0784 855E35     478            mov x+3, pwm_counter+3
0787            479   
0787 7536DB     480            mov y+0, #low (PWM_PERIOD % 0x10000) 
078A 753705     480            mov y+1, #high(PWM_PERIOD % 0x10000) 
078D 753800     480            mov y+2, #low (PWM_PERIOD / 0x10000) 
0790 753900     480            mov y+3, #high(PWM_PERIOD / 0x10000) 
0793            481   
0793            482            ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0793            483            ; increase x by 1
0793 120152     484            lcall x_eq_y 
0796 20001D     485            jb mf, wrap_pwm_counter
0799            486            ; x not equal 1499, increment by 1
0799 753601     487            mov y+0, #low (1 % 0x10000) 
079C 753700     487            mov y+1, #high(1 % 0x10000) 
079F 753800     487            mov y+2, #low (1 / 0x10000) 
07A2 753900     487            mov y+3, #high(1 / 0x10000) 
07A5 1200D3     488            lcall add32
07A8            489            ; update pwm_counter
07A8 85325B     490            mov pwm_counter, x
07AB 85335C     491            mov pwm_counter+1, x+1
07AE 85345D     492            mov pwm_counter+2, x+2
07B1 85355E     493            mov pwm_counter+3, x+3
07B4 8018       494            sjmp set_pwm
07B6            495   
07B6            496   wrap_pwm_counter:
07B6            497            ; x equal 1499, wrap to 0
07B6 753200     498            mov x+0, #low (0 % 0x10000) 
07B9 753300     498            mov x+1, #high(0 % 0x10000) 
07BC 753400     498            mov x+2, #low (0 / 0x10000) 
07BF 753500     498            mov x+3, #high(0 / 0x10000) 
07C2 85325B     499            mov pwm_counter, x
07C5 85335C     500            mov pwm_counter+1, x+1
07C8 85345D     501            mov pwm_counter+2, x+2
07CB 85355E     502            mov pwm_counter+3, x+3
07CE            503   
07CE            504   set_pwm:
07CE            505            ; compare with power_output, if pwm counter smaller than power_output, 
07CE            506            ; set pwm pin high; else set pwm pin low load y with power output value
07CE 855736     507            mov y, power_output
07D1 855837     508            mov y+1, power_output+1
07D4 855938     509            mov y+2, power_output+2
07D7 855A39     510            mov y+3, power_output+3
07DA            511   
07DA            512            ; compare x(pwm counter) with y(power output)
07DA 12011A     513            lcall x_lt_y
07DD 200006     514            jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
07E0            515            ;output set pwm pin low if pwm counter greater than power output
07E0 C293       516            clr PWM_OUT
07E2 C2EC       517            clr LEDRA.4
07E4 8004       518            sjmp end_pwm_generator
07E6            519   
07E6            520   set_pwm_high:
07E6 D293       521            setb PWM_OUT
07E8 D2EC       522            setb LEDRA.4
07EA            523   
07EA            524   end_pwm_generator:
07EA 22         525            ret
07EB            526   
07EB            527   ;-------------------------------------------------------------------------------;
07EB            528   ; Power helpers
07EB            529   ;-------------------------------------------------------------------------------;
07EB            530   Set_Power_Full:
07EB 7557DB     531            mov power_output,   #low(POWER_FULL)
07EE 755805     532            mov power_output+1, #high(POWER_FULL)
07F1 755900     533            mov power_output+2, #0
07F4 755A00     534            mov power_output+3, #0
07F7 22         535            ret
07F8            536   
07F8            537   Set_Power_20:
07F8 75572C     538            mov power_output,   #low(POWER_20)
07FB 755801     539            mov power_output+1, #high(POWER_20)
07FE 755900     540            mov power_output+2, #0
0801 755A00     541            mov power_output+3, #0
0804 22         542            ret
0805            543   
0805            544   Set_Power_0:
0805 755700     545            mov power_output,   #0
0808 755800     546            mov power_output+1, #0
080B 755900     547            mov power_output+2, #0
080E 755A00     548            mov power_output+3, #0
0811 22         549            ret
0812            550   
0812            551   ;-------------------------------------------------------------------------------;
0812            552   ; Button scan (non-blocking)
0812            553   ;-------------------------------------------------------------------------------;
0812            554   Scan_Buttons:
0812            555            ; Read P0 even bits (active-low buttons)
0812 E580       556            mov A, P0
0814 F4         557            cpl A
0815 5455       558            anl A, #055h
0817 FF         559            mov R7, A
0818            560   
0818            561            ; new_presses = pressed & ~last
0818 E564       562            mov A, btn_last
081A F4         563            cpl A
081B 5F         564            anl A, R7
081C FE         565            mov R6, A
081D 8F64       566            mov btn_last, R7
081F            567   
081F            568            ; Enter button (P1.0 active-low) edge detect
081F A290       569            mov C, P1.0
0821 B3         570            cpl C
0822 500B       571            jnc Enter_Not_Pressed
0824 E565       572            mov A, enter_last
0826 700A       573            jnz Enter_Done
0828 D20F       574            setb enter_event
082A 756501     575            mov enter_last, #1
082D 8003       576            sjmp Enter_Done
082F            577   Enter_Not_Pressed:
082F 756500     578            mov enter_last, #0
0832            579   Enter_Done:
0832            580   
0832            581            ; Map mode buttons to screens/states
0832 EE         582            mov A, R6
0833 30E00B     583            jnb ACC.0, Btn_Soak_Ramp_Skip
0836 756301     584            mov Control_FSM_state, #1
0839 D20D       585            setb state_change_signal
083B 756600     586            mov state_timer, #0
083E 1207EB     587            lcall Set_Power_Full
0841            588   Btn_Soak_Ramp_Skip:
0841 EE         589            mov A, R6
0842 30E20B     590            jnb ACC.2, Btn_Soak_Skip
0845 756302     591            mov Control_FSM_state, #2
0848 D20D       592            setb state_change_signal
084A 756600     593            mov state_timer, #0
084D 1207F8     594            lcall Set_Power_20
0850            595   Btn_Soak_Skip:
0850 EE         596            mov A, R6
0851 30E40B     597            jnb ACC.4, Btn_Reflow_Ramp_Skip
0854 756303     598            mov Control_FSM_state, #3
0857 D20D       599            setb state_change_signal
0859 756600     600            mov state_timer, #0
085C 1207EB     601            lcall Set_Power_Full
085F            602   Btn_Reflow_Ramp_Skip:
085F EE         603            mov A, R6
0860 30E60B     604            jnb ACC.6, Btn_Reflow_Skip
0863 756304     605            mov Control_FSM_state, #4
0866 D20D       606            setb state_change_signal
0868 756600     607            mov state_timer, #0
086B 1207F8     608            lcall Set_Power_20
086E            609   Btn_Reflow_Skip:
086E 22         610            ret
086F            611   
086F            612   ;-------------------------------------------------------------------------------;
086F            613   ; Temp_Compare
086F            614   ;
086F            615   ; PURPOSE:
086F            616   ;   Compare the current measured temperature against
086F            617   ;   the soak and reflow temperature setpoints.
086F            618   ;
086F            619   ; BEHAVIOR:
086F            620   ;   - If current_temp >= soak_temp   if soak_temp_reached   = 1
086F            621   ;   - If current_temp >= reflow_temp if reflow_temp_reached = 1
086F            622   ;
086F            623   ; NOTES:
086F            624   ;   - Uses 32-bit UNSIGNED comparison from math32.asm
086F            625   ;   - Comparison is done by:
086F            626   ;       x < y ?   (mf = 1)  if NOT reached
086F            627   ;       x >= y ?  (mf = 0)  if reached
086F            628   ;   - This routine ONLY SETS flags.
086F            629   ;     Clearing flags must be handled by the FSM.
086F            630   ;
086F            631   ; EXPECTED VARIABLES (DSEG / BSEG):
086F            632   ;   current_temp[4], soak_temp[4], reflow_temp[4]
086F            633   ;   x[4], y[4]
086F            634   ;   mf (math32 compare flag)
086F            635   ;   soak_temp_reached, reflow_temp_reached
086F            636   ;-------------------------------------------------------------------------------;
086F            637   Temp_Compare:
086F C0E0       638       push acc
0871 C0D0       639       push psw
0873 C000       640       push AR0
0875 C001       641       push AR1
0877 C002       642       push AR2
0879            643       
0879            644   ; Check: current_temp >= soak_temp ?
0879            645       ; Copy current_temp of x (math32 operand A)
0879 783F       646       mov  R0, #current_temp
087B 7932       647       mov  R1, #x
087D 1208F1     648       lcall Copy4_Bytes_R0_to_R1
0880            649   
0880            650       ; Copy soak_temp of y (math32 operand B)
0880 7843       651       mov  R0, #soak_temp
0882 7936       652       mov  R1, #y
0884 1208F1     653       lcall Copy4_Bytes_R0_to_R1
0887            654   
0887            655       ; Perform x < y comparison
0887            656       ; mf = 1 if current_temp < soak_temp  (NOT reached)
0887            657       ; mf = 0 if current_temp >= soak_temp (REACHED)
0887 12011A     658       lcall x_lt_y
088A 200002     659       jb   mf, Temp_Soak_NotReached
088D D204       660       setb soak_temp_reached
088F            661   
088F            662   ; Check: current_temp >= reflow_temp ?
088F            663   Temp_Soak_NotReached:
088F            664       ; Copy current_temp of x
088F 783F       665       mov  R0, #current_temp
0891 7932       666       mov  R1, #x
0893 1208F1     667       lcall Copy4_Bytes_R0_to_R1
0896            668   
0896            669       ; Copy reflow_temp of y
0896 7847       670       mov  R0, #reflow_temp
0898 7936       671       mov  R1, #y
089A 1208F1     672       lcall Copy4_Bytes_R0_to_R1
089D            673   
089D            674       ; Compare x < y again
089D 12011A     675       lcall x_lt_y
08A0 200002     676       jb   mf, Temp_Reflow_NotReached
08A3 D205       677       setb reflow_temp_reached
08A5            678   
08A5            679   Temp_Reflow_NotReached:
08A5 D002       680       pop  AR2
08A7 D001       681       pop  AR1
08A9 D000       682       pop  AR0
08AB D0D0       683       pop  psw
08AD D0E0       684       pop  acc
08AF 22         685       ret
08B0            686   ;-------------------------------------------------------------------------------;
08B0            687   ; Time_Compare
08B0            688   ;
08B0            689   ; PURPOSE:
08B0            690   ;   Compare the elapsed time against soak and reflow
08B0            691   ;   time limits.
08B0            692   ;
08B0            693   ; BEHAVIOR:
08B0            694   ;   - If current_time >= soak_time   if soak_time_reached   = 1
08B0            695   ;   - If current_time >= reflow_time if reflow_time_reached = 1
08B0            696   ;
08B0            697   ; NOTES:
08B0            698   ;   - Time values are treated as 32-bit UNSIGNED numbers
08B0            699   ;     (e.g., milliseconds or seconds).
08B0            700   ;   - Uses the SAME compare logic as Temp_Compare.
08B0            701   ;   - This routine ONLY SETS flags.
08B0            702   ;
08B0            703   ; EXPECTED VARIABLES:
08B0            704   ;   current_time[4], soak_time[4], reflow_time[4]
08B0            705   ;   x[4], y[4]
08B0            706   ;   mf, soak_time_reached, reflow_time_reached
08B0            707   ;-------------------------------------------------------------------------------;
08B0            708   Time_Compare:
08B0 C0E0       709       push acc
08B2 C0D0       710       push psw
08B4 C000       711       push AR0
08B6 C001       712       push AR1
08B8 C002       713       push AR2
08BA            714   
08BA            715   ; Check: current_time >= soak_time ?
08BA            716       ; Copy current_time of x
08BA 784B       717       mov  R0, #current_time
08BC 7932       718       mov  R1, #x
08BE 1208F1     719       lcall Copy4_Bytes_R0_to_R1
08C1            720   
08C1            721       ; Copy soak_time of y
08C1 784F       722       mov  R0, #soak_time
08C3 7936       723       mov  R1, #y
08C5 1208F1     724       lcall Copy4_Bytes_R0_to_R1
08C8            725   
08C8            726       ; Compare elapsed time vs soak time
08C8 12011A     727       lcall x_lt_y
08CB 200002     728       jb   mf, Time_Soak_NotReached
08CE D207       729       setb soak_time_reached
08D0            730   
08D0            731   ; Check: current_time >= reflow_time ?
08D0            732   Time_Soak_NotReached:
08D0            733       ; Copy current_time of x
08D0 784B       734       mov  R0, #current_time
08D2 7932       735       mov  R1, #x
08D4 1208F1     736       lcall Copy4_Bytes_R0_to_R1
08D7            737   
08D7            738       ; Copy reflow_time of y
08D7 7853       739       mov  R0, #reflow_time
08D9 7936       740       mov  R1, #y
08DB 1208F1     741       lcall Copy4_Bytes_R0_to_R1
08DE            742   
08DE            743       ; Compare elapsed time vs reflow time
08DE 12011A     744       lcall x_lt_y
08E1 200002     745       jb   mf, Time_Reflow_NotReached
08E4 D208       746       setb reflow_time_reached
08E6            747   
08E6            748   Time_Reflow_NotReached:
08E6 D002       749       pop  AR2
08E8 D001       750       pop  AR1
08EA D000       751       pop  AR0
08EC D0D0       752       pop  psw
08EE D0E0       753       pop  acc
08F0 22         754       ret
08F1            755   
08F1            756   ;-------------------------------------------------------------------------------;
08F1            757   ; Copy4_Bytes_R0_to_R1
08F1            758   ;
08F1            759   ; PURPOSE:
08F1            760   ;   Utility routine to copy a 32-bit value (4 bytes)
08F1            761   ;   from one memory location to another.
08F1            762   ;
08F1            763   ; INPUTS:
08F1            764   ;   R0 st source address
08F1            765   ;   R1 at destination address
08F1            766   ;
08F1            767   ; USES:
08F1            768   ;   R2 as loop counter
08F1            769   ;
08F1            770   ; EXAMPLE:
08F1            771   ;   mov R0, #current_temp
08F1            772   ;   mov R1, #x
08F1            773   ;   lcall Copy4_Bytes_R0_to_R1
08F1            774   ;-------------------------------------------------------------------------------;
08F1            775   Copy4_Bytes_R0_to_R1:
08F1 7A04       776       mov  R2, #4
08F3            777   Copy4_Loop:
08F3 E6         778       mov  a, @R0
08F4 F7         779       mov  @R1, a
08F5 08         780       inc  R0
08F6 09         781       inc  R1
08F7 DAFA       782       djnz R2, Copy4_Loop
08F9 22         783       ret
08FA            784   
08FA            785   ;-------------------------------------------------------------------------------;
08FA            786   ; Abort condition safety check Temperature time
08FA            787   ;
08FA            788   ; PURPOSE:
08FA            789   ;   Automatic cycle termination on error:
08FA            790   ;   Abort if oven fails to reach at least 50C in first 60s.
08FA            791   ;
08FA            792   ; TRIP CONDITION:
08FA            793   ;   if (current_time >= 60s) AND (current_temp < 50C)
08FA            794   ;       -> set tc_missing_abort
08FA            795   ;       -> set stop_signal
08FA            796   ;
08FA            797   ; ASSUMPTIONS:
08FA            798   ;   - current_time is in SECONDS (32-bit, little-endian)
08FA            799   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
08FA            800   ;
08FA            801   ;   the Load_Y constants accordingly.
08FA            802   ;-------------------------------------------------------------------------------;
08FA            803   Safety_Check_TC:
08FA C0E0       804       push acc
08FC C0D0       805       push psw
08FE C000       806       push AR0
0900 C001       807       push AR1
0902 C002       808       push AR2
0904            809   
0904            810       ; If already aborted or startup window closed, do nothing
0904 20103D     811       jb   tc_missing_abort, Safety_TC_Done
0907 30113A     812       jnb  tc_startup_window, Safety_TC_Done
090A            813   
090A            814       ; Check: current_time >= 60 ?
090A 784B       815       mov  R0, #current_time
090C 7932       816       mov  R1, #x
090E 1208F1     817       lcall Copy4_Bytes_R0_to_R1
0911            818   
0911 75363C     819            mov y+0, #low (60 % 0x10000) 
0914 753700     819            mov y+1, #high(60 % 0x10000) 
0917 753800     819            mov y+2, #low (60 / 0x10000) 
091A 753900     819            mov y+3, #high(60 / 0x10000) 
091D 12011A     820       lcall x_lt_y
0920 200021     821       jb   mf, Safety_TC_Done        ; still < 60s  keep waiting
0923            822   
0923            823       ; We reached 60s: close the startup window so it won't re-check later
0923 C211       824       clr  tc_startup_window
0925            825   
0925            826       ; Now check: current_temp < 50 ?
0925 783F       827       mov  R0, #current_temp
0927 7932       828       mov  R1, #x
0929 1208F1     829       lcall Copy4_Bytes_R0_to_R1
092C            830   
092C 753632     831            mov y+0, #low (50 % 0x10000) 
092F 753700     831            mov y+1, #high(50 % 0x10000) 
0932 753800     831            mov y+2, #low (50 / 0x10000) 
0935 753900     831            mov y+3, #high(50 / 0x10000) 
0938 12011A     832       lcall x_lt_y
093B 300006     833       jnb  mf, Safety_TC_Done        ; temp >= 50  pass
093E            834   
093E            835       ; FAIL: at 60s, still below 50C  abort
093E D210       836       setb tc_missing_abort
0940 D20A       837       setb stop_signal
0942 C293       838       clr  PWM_OUT
0944            839   
0944            840   Safety_TC_Done:
0944 D002       841       pop  AR2
0946 D001       842       pop  AR1
0948 D000       843       pop  AR0
094A D0D0       844       pop  psw
094C D0E0       845       pop  acc
094E 22         846       ret
094F            847   
094F            848   ;-------------------------------------------------------------------------------;
094F            849   ; Main Control FSM for the entire process
094F            850   ;-------------------------------------------------------------------------------;
094F            851   Control_FSM:
094F E563       852            mov a, Control_FSM_state
0951 020961     853            ljmp Control_FSM_state0
0954            854   
0954            855   Control_FSM_state0_a:
0954 756300     856            mov Control_FSM_state, #0
0957 D20D       857            setb state_change_signal
0959 756600     858            mov state_timer, #0
095C 120805     859            lcall Set_Power_0
095F E563       860            mov a, Control_FSM_state
0961            861   Control_FSM_state0:
0961 B40015     862            cjne a, #0, Control_FSM_state1
0964 100F03     863            jbc enter_event, Control_FSM_state0_enter
0967 020A4D     864            ljmp Control_FSM_done
096A            865   Control_FSM_state0_enter:
096A 02096D     866            ljmp Control_FSM_state1_a
096D            867   
096D            868   Control_FSM_state1_a:
096D 0563       869            inc Control_FSM_state
096F D20D       870            setb state_change_signal
0971 756600     871            mov state_timer, #0
0974 1207EB     872            lcall Set_Power_Full
0977 E563       873            mov a, Control_FSM_state
0979            874   Control_FSM_state1:
0979 B40131     875            cjne a, #1, Control_FSM_state2
097C 100F1F     876            jbc enter_event, Control_FSM_state1_enter
097F            877            ; advance when current_temp >= 150
097F 783F       878            mov  R0, #current_temp
0981 7932       879            mov  R1, #x
0983 1208F1     880            lcall Copy4_Bytes_R0_to_R1
0986 753696     881            mov y+0, #low (150 % 0x10000) 
0989 753700     881            mov y+1, #high(150 % 0x10000) 
098C 753800     881            mov y+2, #low (150 / 0x10000) 
098F 753900     881            mov y+3, #high(150 / 0x10000) 
0992 12011A     882            lcall x_lt_y
0995 200003     883            jb   mf, Control_FSM_state1_wait
0998 0209A1     884            ljmp Control_FSM_state2_a
099B            885   Control_FSM_state1_wait:
099B 020A4D     886            ljmp Control_FSM_done
099E            887   Control_FSM_state1_enter:
099E 0209A1     888            ljmp Control_FSM_state2_a
09A1            889   
09A1            890   Control_FSM_state2_a:
09A1 0563       891            inc Control_FSM_state
09A3 D20D       892            setb state_change_signal
09A5 756600     893            mov state_timer, #0
09A8 1207F8     894            lcall Set_Power_20
09AB E563       895            mov a, Control_FSM_state
09AD            896   Control_FSM_state2:
09AD B4021F     897            cjne a, #2, Control_FSM_state3
09B0 100F0D     898            jbc enter_event, Control_FSM_state2_enter
09B3            899            ; advance when state_timer >= 60
09B3 E566       900            mov a, state_timer
09B5 C3         901            clr c
09B6 943C       902            subb a, #60
09B8 4003       903            jc Control_FSM_state2_wait
09BA 0209C3     904            ljmp Control_FSM_state3_a
09BD            905   Control_FSM_state2_wait:
09BD 020A4D     906            ljmp Control_FSM_done
09C0            907   Control_FSM_state2_enter:
09C0 0209C3     908            ljmp Control_FSM_state3_a
09C3            909   
09C3            910   Control_FSM_state3_a:
09C3 0563       911            inc Control_FSM_state
09C5 D20D       912            setb state_change_signal
09C7 756600     913            mov state_timer, #0
09CA 1207EB     914            lcall Set_Power_Full
09CD E563       915            mov a, Control_FSM_state
09CF            916   Control_FSM_state3:
09CF B40331     917            cjne a, #3, Control_FSM_state4
09D2 100F1F     918            jbc enter_event, Control_FSM_state3_enter
09D5            919            ; advance when current_temp >= 220
09D5 783F       920            mov  R0, #current_temp
09D7 7932       921            mov  R1, #x
09D9 1208F1     922            lcall Copy4_Bytes_R0_to_R1
09DC 7536DC     923            mov y+0, #low (220 % 0x10000) 
09DF 753700     923            mov y+1, #high(220 % 0x10000) 
09E2 753800     923            mov y+2, #low (220 / 0x10000) 
09E5 753900     923            mov y+3, #high(220 / 0x10000) 
09E8 12011A     924            lcall x_lt_y
09EB 200003     925            jb   mf, Control_FSM_state3_wait
09EE 0209F7     926            ljmp Control_FSM_state4_a
09F1            927   Control_FSM_state3_wait:
09F1 020A4D     928            ljmp Control_FSM_done
09F4            929   Control_FSM_state3_enter:
09F4 0209F7     930            ljmp Control_FSM_state4_a
09F7            931   
09F7            932   Control_FSM_state4_a:
09F7 0563       933            inc Control_FSM_state   
09F9 D20D       934            setb state_change_signal
09FB 756600     935            mov state_timer, #0
09FE 1207F8     936            lcall Set_Power_20
0A01 E563       937            mov a, Control_FSM_state
0A03            938   Control_FSM_state4:
0A03 B4041F     939            cjne a, #4, Control_FSM_state5
0A06 100F0D     940            jbc enter_event, Control_FSM_state4_enter
0A09            941            ; advance when state_timer >= 45
0A09 E566       942            mov a, state_timer
0A0B C3         943            clr c
0A0C 942D       944            subb a, #45
0A0E 4003       945            jc Control_FSM_state4_wait
0A10 020A19     946            ljmp Control_FSM_state5_a
0A13            947   Control_FSM_state4_wait:
0A13 020A4D     948            ljmp Control_FSM_done
0A16            949   Control_FSM_state4_enter:
0A16 020A19     950            ljmp Control_FSM_state5_a
0A19            951   
0A19            952   Control_FSM_state5_a:
0A19 0563       953            inc Control_FSM_state
0A1B D20D       954            setb state_change_signal
0A1D 756600     955            mov state_timer, #0
0A20 120805     956            lcall Set_Power_0
0A23 E563       957            mov a, Control_FSM_state
0A25            958   Control_FSM_state5:
0A25 B40525     959            cjne a, #5, Control_FSM_done
0A28 100F1F     960            jbc enter_event, Control_FSM_state5_enter
0A2B            961            ; return when current_temp <= 60 (i.e., < 61)
0A2B 783F       962            mov  R0, #current_temp
0A2D 7932       963            mov  R1, #x
0A2F 1208F1     964            lcall Copy4_Bytes_R0_to_R1
0A32 75363D     965            mov y+0, #low (61 % 0x10000) 
0A35 753700     965            mov y+1, #high(61 % 0x10000) 
0A38 753800     965            mov y+2, #low (61 / 0x10000) 
0A3B 753900     965            mov y+3, #high(61 / 0x10000) 
0A3E 12011A     966            lcall x_lt_y
0A41 200003     967            jb   mf, Control_FSM_state5_cool_done
0A44 020A4D     968            ljmp Control_FSM_done
0A47            969   Control_FSM_state5_cool_done:
0A47 020954     970            ljmp Control_FSM_state0_a
0A4A            971   Control_FSM_state5_enter:
0A4A 020954     972            ljmp Control_FSM_state0_a
0A4D            973   
0A4D            974   Control_FSM_done:
0A4D 22         975            ret
0A4E            976   ;-------------------------------------------------------------------------------;
0A4E            977   ;         Main program.          
0A4E            978   ;-------------------------------------------------------------------------------;
0A4E            979   main:
0A4E            980            ; Initialization
0A4E 75817F     981       mov SP, #0x7F
0A51            982   
0A51            983            ; P0: even bits inputs (buttons), odd bits outputs (LCD)
0A51 759AAA     984       mov P0MOD, #0AAh
0A54            985       ; P1: outputs on 1.5 (speaker), 1.3 (PWM), 1.1 (LCD E), P1.0 input
0A54 759B2A     986       mov P1MOD, #02Ah
0A57 759CFF     987       mov P2MOD, #0xff
0A5A 759DFF     988       mov P3MOD, #0xff
0A5D            989       ; Turn off all the LEDs
0A5D 75E800     990       mov LEDRA, #0 ; LEDRA is bit addressable
0A60 759500     991       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0A63            992   
0A63            993            ; Enable Global interrupts
0A63 D2AF       994       setb EA  
0A65            995   
0A65            996            ; FSM initial states
0A65 756100     997            mov KEY1_DEB_state, #0
0A68 756200     998            mov SEC_FSM_state, #0
0A6B 756300     999            mov Control_FSM_state, #0
0A6E 756400    1000            mov btn_last, #0
0A71 756500    1001            mov enter_last, #0
0A74 756600    1002            mov state_timer, #0
0A77           1003            ; FSM timers initialization
0A77 755F00    1004            mov KEY1_DEB_timer, #0
0A7A 756000    1005            mov SEC_FSM_timer, #0
0A7D           1006            ; time counters initialization
0A7D 753000    1007            mov current_time_sec, #0
0A80 753100    1008            mov current_time_minute, #0
0A83           1009            ; Initialize counter to zero
0A83 755B00    1010       mov pwm_counter, #0
0A86 755C00    1011            mov pwm_counter+1, #0
0A89 755D00    1012            mov pwm_counter+2, #0
0A8C 755E00    1013            mov pwm_counter+3, #0
0A8F           1014            ; Initialize power output
0A8F 755A00    1015            mov power_output+3, #0
0A92 755900    1016            mov power_output+2, #0
0A95 755802    1017            mov power_output+1, #02H
0A98 7557EE    1018            mov power_output, #0EEH ; (initilize to 750 for testing)
0A9B           1019   
0A9B           1020            ; Clear all the flags
0A9B C210      1021            clr  tc_missing_abort
0A9D C20A      1022            clr  stop_signal
0A9F C212      1023            clr PB0_flag
0AA1 C213      1024            clr PB1_flag
0AA3 C214      1025            clr PB2_flag
0AA5 C201      1026            clr one_second_flag
0AA7 C20C      1027            clr config_finish_signal
0AA9 C204      1028            clr soak_temp_reached
0AAB C207      1029            clr soak_time_reached
0AAD C205      1030            clr reflow_temp_reached
0AAF C208      1031            clr reflow_time_reached
0AB1 C206      1032            clr cooling_temp_reached
0AB3 C20D      1033            clr state_change_signal
0AB5 C20F      1034            clr enter_event
0AB7           1035   
0AB7           1036            ; Set bit
0AB7 D211      1037            setb tc_startup_window
0AB9           1038   
0AB9 120401    1039            lcall Timer0_Init
0ABC 12046B    1040       lcall Timer2_Init
0ABF 1204EE    1041            lcall ELCD_4BIT
0AC2 12041D    1042            lcall Initialize_Serial_Port
0AC5           1043   ;-------------------------------------------------------------------------------;
0AC5           1044   ; while(1) loop
0AC5           1045   ;-------------------------------------------------------------------------------;
0AC5           1046   loop:
0AC5           1047            ; Check the FSM for KEY1 debounce
0AC5 1206DC    1048            lcall KEY1_DEB
0AC8           1049   
0AC8           1050            ; Check the FSM for one second counter
0AC8 120712    1051            lcall SEC_FSM
0ACB           1052   
0ACB           1053            ; Read buttons (non-blocking)
0ACB 120812    1054            lcall Scan_Buttons
0ACE           1055   
0ACE           1056            ; Check the FSM for the overall control flow of the reflow process
0ACE 12094F    1057            lcall Control_FSM
0AD1           1058   
0AD1           1059            ; Update the LCD display based on the current state
0AD1 12059E    1060            lcall LCD_Display_Update_func
0AD4           1061   
0AD4           1062            ; Update the pwm output for the ssr
0AD4 120774    1063            lcall PWM_Wave 
0AD7           1064   
0AD7           1065            ; After initialization the program stays in this 'forever' loop
0AD7 020AC5    1066            ljmp loop
0ADA           1067   ;-------------------------------------------------------------------------------;
0ADA           1068   
0ADA           1069   END
