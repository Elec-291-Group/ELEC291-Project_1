0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 020A8B       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 020469      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 0204D6      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   current_time_sec:     ds 1
0031             38   current_time_minute:  ds 1
0032             39   ; math32 buffer variables
0032             40   x:      ds  4
0036             41   y:      ds  4
003A             42   bcd:    ds  5
003F             43   
003F             44   current_temp: ds 4 ;
0043             45   soak_temp:    ds 4 ;
0047             46   reflow_temp:  ds 4 ;
004B             47   
004B             48   wait25_btn_cnt:    ds 1
004C             49   wait25_keypad_cnt: ds 1
004D             50   wait25_adc_cnt:    ds 1
004E             51   wait25_lcd_cnt:    ds 1
004F             52   wait25_count: ds 1  
0050             53   
0050             54   current_time: ds 4 ;
0054             55   soak_time:    ds 4 ;
0058             56   reflow_time:  ds 4 ;
005C             57   
005C             58   power_output:  ds 4 ;
0060             59   pwm_counter: ds 4 ; counter for pwm (0-1500)
0064             60   
0064             61   KEY1_DEB_timer: ds 1
0065             62   SEC_FSM_timer:  ds 1
0066             63   KEY1_DEB_state:    ds 1
0067             64   SEC_FSM_state:     ds 1
0068             65   Control_FSM_state: ds 1 
0069             66   
0069             67   Current_State:     ds 1
006A             68   
006A             69   
006A             70   ;-- UI buffers I added (ayaan)
006A             71   Cursor_Idx: ds 1
006B             72   
006B             73   ; These hold the TEXT (ASCII) safely
006B             74   ; Digits Only + Null Terminator, got rid of C,:, and s 
006B             75   Buf_Soak_Temp: ds 4   
006F             76   Buf_Soak_Time: ds 5   
0074             77   Buf_Refl_Temp: ds 4   
0078             78   Buf_Refl_Time: ds 5
007D             79   
007D             80   ; 46d bytes used
007D             81   
007D             82   ;-------------------------------------------------------------------------------
007D             83   ; bit operation setb, clr, jb, and jnb
0000             84   bseg
0000             85   mf:     dbit 1 ; math32 sign
0001             86   one_second_flag: dbit 1
0002             87   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003             88   
0003             89   soak_temp_reached: dbit 1
0004             90   reflow_temp_reached: dbit 1
0005             91   cooling_temp_reached: dbit 1
0006             92   
0006             93   soak_time_reached: dbit 1
0007             94   reflow_time_reached: dbit 1
0008             95   
0008             96   reset_signal: dbit 1
0009             97   stop_signal: dbit 1
000A             98   start_signal: dbit 1
000B             99   config_finish_signal: dbit 1
000C            100   
000C            101   state_change_signal: dbit 1
000D            102   
000D            103   Key1_flag: dbit 1
000E            104   
000E            105   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
000F            106   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0010            107   PB0_flag: dbit 1 ; start entire program
0011            108   PB1_flag: dbit 1 ; start soak
0012            109   PB2_flag: dbit 1 ; pause process
0013            110   
0013            111   ; BSEG (Bit Segment)
0013            112   wait25_active: dbit 1 ; 1 = We are currently waiting
0014            113   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0015            114   wait25_btn_active:    dbit 1
0016            115   wait25_btn_done:      dbit 1
0017            116   wait25_keypad_active: dbit 1
0018            117   wait25_keypad_done:   dbit 1
0019            118   wait25_adc_active:    dbit 1
001A            119   wait25_adc_done:      dbit 1
001B            120   wait25_lcd_active:    dbit 1
001C            121   wait25_lcd_done:      dbit 1
001D            122   ; 11 bits used
001D            123   
001D            124   ;-------------------------------------------------------------------------------
0320            125   cseg
0320            126   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            127   BAUD           EQU 57600
0320            128   
0320            129   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            130   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            131   ; is always 12 unlike the N76E003 where is selectable.
0320            132   
0320            133   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            134   
0320            135   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            136   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            137   
0320            138   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            139   
0320            140   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            141   
0320            142   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            143   
0320            144   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            145   ; P0 is in connector JPIO.
0320            146   
0320            147   ;Added correct I/O definitions
0320            148   ;-- LCD Pins ---
0320            149   ELCD_RS equ P1.7
0320            150   ELCD_E  equ P1.1
0320            151   ELCD_D4 equ P0.7
0320            152   ELCD_D5 equ P0.5
0320            153   ELCD_D6 equ P0.3
0320            154   ELCD_D7 equ P0.1
0320            155   
0320            156   ; -- Buttons --
0320            157   BTN_SOAK_TEMP equ P0.0
0320            158   BTN_SOAK_TIME equ P0.2
0320            159   BTN_REFL_TEMP equ P0.4
0320            160   BTN_REFL_TIME equ P0.6
0320            161   
0320            162   ; --- KEYPAD ---
0320            163   ROW1 equ P1.2
0320            164   ROW2 equ P1.4
0320            165   ROW3 equ P1.6
0320            166   ROW4 equ P2.0
0320            167   COL1 equ P2.2
0320            168   COL2 equ P2.4
0320            169   COL3 equ P2.6
0320            170   COL4 equ P3.0
0320            171   
0320            172   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   173   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   174   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   175   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            176   
0350            177   ; --- UI STRINGS (REQUIRED FOR KEYPAD LOGIC), <- I can fix if duplicates
0350 53656C65   178   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   179   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   180   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   181   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   182   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            183   
03A5            184   ;                       1234567890123456
03A5 53657420   185   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   186   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   187   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   188   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   189   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            190   
03E5            191   ;                     1234567890123456
03E5 52616D70   192   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03F5 536F616B   193   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
0405 52616D70   194   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
0415 5265666C   195   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
0425 436F6F6C   196   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
0435 50726F63   197   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
0445            198   
0445 20202020   199   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
0456            200   
0456            201   ;-------------------------------------------------------------------------------
0456            202   ; Timers Setting:
0456            203   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
0456            204   ;   Timer 1: Serial port baud rate 57600 generator
0456            205   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
0456            206   ;-------------------------------------------------------------------------------
0456            207   ; Routine to initialize the ISR for Timer 0 ;
0456            208   Timer0_Init:
0456 E589       209       mov a, TMOD
0458 54F0       210       anl a, #0xf0 ; Clear the bits for timer 0
045A 4401       211       orl a, #0x01 ; Configure timer 0 as 16-timer
045C F589       212       mov TMOD, a
045E 758CFD     213       mov TH0, #high(TIMER0_RELOAD)
0461 758A5A     214       mov TL0, #low(TIMER0_RELOAD)
0464            215       ; Enable the timer and interrupts
0464 D2A9       216       setb ET0  ; Enable timer 0 interrupt
0466 D28C       217       setb TR0  ; Start timer 0
0468 22         218       ret
0469            219   ; ISR for timer 0.  Set to execute every 1/4096Hz 
0469            220   ; to generate a 2048 Hz square wave at pin P1.5 
0469            221   Timer0_ISR:
0469            222       ;clr TF0  ; According to the data sheet this is done for us already.
0469 758CFD     223       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
046C 758A5A     224       mov TL0, #low(TIMER0_RELOAD)
046F B295       225       cpl SOUND_OUT ; Connect speaker to P1.5
0471 32         226       reti
0472            227   ; -----------------------------------------------------------------------------------------------;
0472            228   
0472            229   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0472            230   Initialize_Serial_Port:
0472            231       ; Configure serial port and baud rate
0472 C28E       232       clr TR1 ; Disable timer 1
0474 53890F     233       anl TMOD, #0x0f ; Mask the bits for timer 1
0477 438920     234       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047A 438780     235       orl PCON, #80H ; Set SMOD to 1
047D 758DFD     236       mov TH1, #low(TIMER_1_RELOAD)
0480 758BFD     237       mov TL1, #low(TIMER_1_RELOAD) 
0483 D28E       238       setb TR1 ; Enable timer 1
0485 759852     239       mov SCON, #52H
0488 22         240       ret
0489            241   
0489            242   ; uart sending functions
0489            243   putchar:
0489 109902     244       jbc TI, putchar_L1
048C 80FB       245       sjmp putchar
048E            246   putchar_L1:
048E F599       247       mov SBUF,a
0490 22         248       ret
0491            249   
0491            250   SendString:
0491 E4         251       clr a
0492 93         252       movc a, @a+dptr
0493 6006       253       jz SendString_L1
0495 120489     254       lcall putchar
0498 A3         255       inc dptr
0499 80F6       256       sjmp SendString  
049B            257   SendString_L1:
049B 22         258       ret
049C            259   
049C            260   ;-------------------------------------------------------------------------------
049C            261   ; serial debugging
049C            262   ; send a four byte number via serial to laptop
049C            263   ; need to be used with python script
049C            264   ; content needed to be sent should be stored in the varaible x
049C            265   ;-------------------------------------------------------------------------------
049C            266   Send32:
049C            267       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
049C 74AA       268       mov A, #0AAH
049E 120489     269       lcall putchar
04A1 7455       270       mov A, #055H
04A3 120489     271       lcall putchar
04A6            272   
04A6 E535       273       mov A, x+3
04A8 120489     274       lcall putchar
04AB E534       275       mov A, x+2
04AD 120489     276       lcall putchar
04B0 E533       277       mov A, x+1
04B2 120489     278       lcall putchar
04B5 E532       279       mov A, x+0
04B7 120489     280       lcall putchar
04BA            281   
04BA 740A       282       mov A, #0AH
04BC 120489     283       lcall putchar
04BF 22         284       ret
04C0            285   ; -----------------------------------------------------------------------------------------------;
04C0            286   
04C0            287   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
04C0              1   ;-------------------------------------------------------------------------------
04C0              2   ; Timer2_ISR.inc
04C0              3   ; Contains Initialization and ISR for the 1ms System Timer
04C0              4   ;-------------------------------------------------------------------------------
04C0              5   
04C0              6   ;-------------------------------------------------------------------------------
04C0              7   ; Routine to initialize the ISR for timer 2
04C0              8   ;-------------------------------------------------------------------------------
04C0              9   Timer2_Init:
04C0 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
04C3 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
04C6 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
04C9             13       ; Set the reload value
04C9 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
04CC 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
04CF             16       
04CF C2CF        17       clr TF2       ; Clear flag just in case
04D1             18       ; Enable the timer and interrupts
04D1 D2AD        19       setb ET2      ; Enable timer 2 interrupt
04D3 D2CA        20       setb TR2      ; Enable timer 2
04D5 22          21       ret
04D6             22   
04D6             23   ;-------------------------------------------------------------------------------
04D6             24   ; ISR for timer 2.  Runs every 1 ms
04D6             25   ;-------------------------------------------------------------------------------
04D6             26   Timer2_ISR:
04D6 C0E0        27       push acc
04D8 C0D0        28       push psw
04DA             29       
04DA C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
04DC             31   
04DC             32       ; --- 1. Existing FSM Timers ---
04DC 0564        33       inc KEY1_DEB_timer
04DE 0565        34       inc SEC_FSM_timer
04E0 D202        35       setb one_ms_pwm_flag 
04E2             36   
04E2             37       ; --- 2. NEW: Non-Blocking Delay Counters ---
04E2             38       
04E2             39       ; A. BUTTON DELAY
04E2 30150B      40       jnb wait25_btn_active, T2_Check_Keypad
04E5 054B        41       inc wait25_btn_cnt
04E7 E54B        42       mov a, wait25_btn_cnt
04E9 B41904      43       cjne a, #25, T2_Check_Keypad
04EC D216        44       setb wait25_btn_done
04EE C215        45       clr wait25_btn_active
04F0             46       
04F0             47       ; B. KEYPAD DELAY
04F0             48   T2_Check_Keypad:
04F0 30170B      49       jnb wait25_keypad_active, T2_Check_ADC
04F3 054C        50       inc wait25_keypad_cnt
04F5 E54C        51       mov a, wait25_keypad_cnt
04F7 B41904      52       cjne a, #25, T2_Check_ADC
04FA D218        53       setb wait25_keypad_done
04FC C217        54       clr wait25_keypad_active
04FE             55   
04FE             56       ; C. ADC DELAY (Thermocouple)
04FE             57   T2_Check_ADC:
04FE 30190B      58       jnb wait25_adc_active, T2_Check_LCD
0501 054D        59       inc wait25_adc_cnt
0503 E54D        60       mov a, wait25_adc_cnt
0505 B41904      61       cjne a, #25, T2_Check_LCD
0508 D21A        62       setb wait25_adc_done
050A C219        63       clr wait25_adc_active
050C             64   
050C             65       ; D. LCD DELAY
050C             66   T2_Check_LCD:
050C 301B0B      67       jnb wait25_lcd_active, T2_Check_Generic
050F 054E        68       inc wait25_lcd_cnt
0511 E54E        69       mov a, wait25_lcd_cnt
0513 B41904      70       cjne a, #25, T2_Check_Generic
0516 D21C        71       setb wait25_lcd_done
0518 C21B        72       clr wait25_lcd_active
051A             73   
051A             74       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
051A             75   T2_Check_Generic:
051A 30130B      76       jnb wait25_active, Timer2_ISR_done
051D 054F        77       inc wait25_count
051F E54F        78       mov a, wait25_count
0521 B41904      79       cjne a, #25, Timer2_ISR_done
0524 D214        80       setb wait25_done      ; Tells Wait_25ms that we are finished
0526 C213        81       clr wait25_active     ; Stop counting
0528             82   
0528             83   Timer2_ISR_done:
0528 D0D0        84       pop psw
052A D0E0        85       pop acc
052C 32          86       reti
052D             87            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
052D              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
052D              2   cseg
052D              3   
052D              4   ; When using a 33.333333MHz crystal clock
052D              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
052D              6   
052D              7   ;---------------------------------;
052D              8   ; Wait 40 microseconds            ;
052D              9   ;---------------------------------;
052D             10   Wait40uSec:
052D C000        11            push AR0
052F 78BE        12            mov R0, #190
0531             13   L0: 
0531 00          14            nop
0532 00          15            nop
0533 00          16            nop
0534 00          17            nop
0535 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0537 D000        19            pop AR0
0539 22          20       ret
053A             21   
053A             22   ;---------------------------------;
053A             23   ; Wait 'R2' milliseconds          ;
053A             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
053A             31   
053A             32   ?Wait_Milli_Seconds:
053A C000        33            push AR0
053C C001        34            push AR1
053E 7932        35   L3: mov R1, #50
0540 78DF        36   L2: mov R0, #223
0542 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
0544 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
0546 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
0548 D001        40       pop AR1
054A D000        41       pop AR0
054C 22          42       ret
054D             43            
054D             44   ;---------------------------------;
054D             45   ; Toggles the 'E' pin in the LCD  ;
054D             46   ;---------------------------------;
054D             47   ELCD_pulse:
054D D291        48            setb ELCD_E
054F 12052D      49            lcall Wait40uSec
0552 C291        50            clr ELCD_E
0554 12052D      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
0557 22          52       ret
0558             53   
0558             54   ;---------------------------------;
0558             55   ; Writes acc to LCD in 4-bit mode ;
0558             56   ;---------------------------------;
0558             57   ELCD_byte:
0558             58            ; Write high 4 bits first
0558 A2E7        59            mov c, ACC.7
055A 9281        60            mov ELCD_D7, c
055C A2E6        61            mov c, ACC.6
055E 9283        62            mov ELCD_D6, c
0560 A2E5        63            mov c, ACC.5
0562 9285        64            mov ELCD_D5, c
0564 A2E4        65            mov c, ACC.4
0566 9287        66            mov ELCD_D4, c
0568 12054D      67       lcall ELCD_pulse
056B             68            ; Write low 4 bits next
056B A2E3        69            mov c, ACC.3
056D 9281        70            mov ELCD_D7, c
056F A2E2        71            mov c, ACC.2
0571 9283        72            mov ELCD_D6, c
0573 A2E1        73            mov c, ACC.1
0575 9285        74            mov ELCD_D5, c
0577 A2E0        75            mov c, ACC.0
0579 9287        76            mov ELCD_D4, c
057B 12054D      77       lcall ELCD_pulse
057E 22          78            ret
057F             79   
057F             80   ;---------------------------------;
057F             81   ; Write data to LCD               ;
057F             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
057F             87            
057F             88   ?WriteData:
057F D297        89            setb ELCD_RS
0581 020558      90            ljmp ELCD_byte
0584             91   
0584             92   ;---------------------------------;
0584             93   ; Write command to LCD            ;
0584             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
0584             99   
0584            100   ?WriteCommand:
0584 C297       101            clr ELCD_RS
0586 020558     102            ljmp ELCD_byte
0589            103   
0589            104   ;---------------------------------;
0589            105   ; Configure LCD in 4-bit mode     ;
0589            106   ;---------------------------------;
0589            107   ELCD_4BIT:
0589 C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
058B            109            ;clr ELCD_RW  ; RW forced to zero
058B            110            
058B            111            ; After power on, let the LCD start up before initializing
058B C002       112            push AR2
058D 7A28       112            mov R2, #40
058F 12053A     112            lcall ?Wait_Milli_Seconds
0592 D002       112            pop AR2
0594            112   
0594            113            
0594            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
0594 7433       115            mov a, #0x33
0596 120584     115            lcall ?WriteCommand
0599 7433       116            mov a, #0x33
059B 120584     116            lcall ?WriteCommand
059E 7432       117            mov a, #0x32
05A0 120584     117            lcall ?WriteCommand ; change to 4-bit mode
05A3            118   
05A3            119            ; Configure the LCD
05A3 7428       120            mov a, #0x28
05A5 120584     120            lcall ?WriteCommand
05A8 740C       121            mov a, #0x0c
05AA 120584     121            lcall ?WriteCommand
05AD 7401       122            mov a, #0x01
05AF 120584     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
05B2            123   
05B2            124       ;Wait for the clear screen command to finish.
05B2 C002       125            push AR2
05B4 7A02       125            mov R2, #2
05B6 12053A     125            lcall ?Wait_Milli_Seconds
05B9 D002       125            pop AR2
05BB            125   
05BB 22         126       ret
05BC            127   
05BC            128   ;---------------------------------;
05BC            129   ; Send a constant string to LCD   ;
05BC            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
05BC            141   
05BC            142   ?Send_Constant_String:
05BC E4         143       clr a
05BD 93         144       movc a, @a+dptr
05BE 6006       145       jz ?Send_Constant_String_Done
05C0 12057F     146       lcall ?WriteData
05C3 A3         147       inc dptr
05C4 80F6       148       sjmp ?Send_Constant_String
05C6            149   ?Send_Constant_String_Done:
05C6 22         150       ret  
05C7            151   
05C7            152   ;---------------------------------;
05C7            153   ; Set LCD cursor at row, column   ;
05C7            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
05C7            162   
05C7            163   ?Set_Cursor_2:
05C7 4440       164            orl a, #01000000B
05C9            165   ?Set_Cursor_1:
05C9 4480       166            orl a, #10000000B
05CB 020584     167            ljmp ?WriteCommand ; Select column and row
05CE            168   
05CE            169   ;---------------------------------;
05CE            170   ; Display a BCD number in the LCD ;
05CE            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
05CE            178   
05CE            179   ?Display_BCD:
05CE C0E0       180            push acc
05D0            181            ; Write most significant digit
05D0 E8         182            mov a, r0
05D1 C4         183            swap a
05D2 540F       184            anl a, #0fh
05D4 4430       185            orl a, #30h
05D6 12057F     186            lcall ?WriteData
05D9            187            ; write least significant digit
05D9 E8         188            mov a, r0
05DA 540F       189            anl a, #0fh
05DC 4430       190            orl a, #30h
05DE 12057F     191            lcall ?WriteData
05E1 D0E0       192            pop acc
05E3 22         193            ret
05E4            194   
05E4            195   ;------------------------------------;
05E4            196   ; Display a char in the LCD          ;
05E4            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
05E4            204   
05E4            290            ;-----------------------------------------------------------------------------------------------;
05E4            291   
05E4            292   ;-------------------------------------------------------------------------------
05E4            293   ; Display Function for 7-segment displays       
05E4            294   ;-------------------------------------------------------------------------------
05E4            295   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
05E4            296   T_7seg:
05E4 C0F9A4B0   297       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
05E9 9282F880   298       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
05EE 8883C6A1   299       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
05F4            300   
05F4            301   ; Displays a BCD number pased in R0 in HEX5-HEX0
05F4            302   Display_BCD_7_Seg_HEX10:
05F4 9005E4     303       mov dptr, #T_7seg
05F7 E8         304       mov a, R0
05F8 C4         305       swap a
05F9 540F       306       anl a, #0FH
05FB 93         307       movc a, @a+dptr
05FC F592       308       mov HEX1, a
05FE E8         309       mov a, R0
05FF 540F       310       anl a, #0FH
0601 93         311       movc a, @a+dptr
0602 F591       312       mov HEX0, a
0604 22         313       ret
0605            314   
0605            315   Display_BCD_7_Seg_HEX32:
0605 9005E4     316       mov dptr, #T_7seg
0608 E8         317       mov a, R0
0609 C4         318       swap a
060A 540F       319       anl a, #0FH
060C 93         320       movc a, @a+dptr
060D F594       321       mov HEX3, a
060F E8         322       mov a, R0
0610 540F       323       anl a, #0FH
0612 93         324       movc a, @a+dptr
0613 F593       325       mov HEX2, a
0615 22         326       ret
0616            327   
0616            328   Display_BCD_7_Seg_HEX54:
0616 9005E4     329       mov dptr, #T_7seg
0619 E8         330       mov a, R0
061A C4         331       swap a
061B 540F       332       anl a, #0FH
061D 93         333       movc a, @a+dptr
061E F58F       334       mov HEX5, a
0620 E8         335       mov a, R0
0621 540F       336       anl a, #0FH
0623 93         337       movc a, @a+dptr
0624 F58E       338       mov HEX4, a
0626 22         339       ret
0627            340   
0627            341   ; The 8-bit hex number passed in the accumulator is converted to
0627            342   ; BCD and stored in [R1, R0]
0627            343   Hex_to_bcd_8bit:
0627 75F064     344       mov b, #100
062A 84         345       div ab
062B F9         346       mov R1, a   ; After dividing, a has the 100s
062C E5F0       347       mov a, b    ; Remainder is in register b
062E 75F00A     348       mov b, #10
0631 84         349       div ab ; The tens are stored in a, the units are stored in b 
0632 C4         350       swap a
0633 54F0       351       anl a, #0xf0
0635 45F0       352       orl a, b
0637 F8         353       mov R0, a
0638 22         354       ret
0639            355   ;-------------------------------------------------------------------------------
0639            356   ; Display Function for LCD                      
0639            357   ;-------------------------------------------------------------------------------
0639            358   LCD_Display_Update_func:
0639 C0E0       359       push acc
063B            360       
063B            361       ; ==========================================
063B            362       ; PART 1: STATIC TEXT (Title)
063B            363       ; Runs ONLY when the state changes
063B            364       ; ==========================================
063B            365       
063B            366       ; [FIX] "Trampoline" logic for long distance jump
063B            367       ; If signal is SET (1), we stay here and update.
063B            368       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
063B 200C03     369       jb state_change_signal, Do_Static_Update
063E 020777     370       ljmp Check_Live_Update
0641            371   
0641            372   Do_Static_Update:
0641 C20C       373       clr state_change_signal
0643            374       
0643            375       ; State Changed: Clear Screen and Write Title
0643 120EA4     376       lcall Clear_Screen_Func
0646 E568       377       mov a, Control_FSM_state
0648            378       
0648            379       ; State 0: Welcome
0648 B4003B     380       cjne a, #0, LCD_Check_1
064B C0E0       381            push acc
064D 7401       381            mov a, #1
064F 14         381            dec a
0650 1205C9     381            lcall ?Set_Cursor_1 ; Select column and row
0653 D0E0       381            pop acc
0655 C083       382            push dph
0657 C082       382            push dpl
0659 C0E0       382            push acc
065B 900330     382            mov dptr, #String_state0_1
065E 1205BC     382            lcall ?Send_Constant_String
0661 D0E0       382            pop acc
0663 D082       382            pop dpl
0665 D083       382            pop dph
0667 C0E0       383            push acc
0669 7401       383            mov a, #1
066B 14         383            dec a
066C 1205C7     383            lcall ?Set_Cursor_2 ; Select column and row
066F D0E0       383            pop acc
0671 C083       384            push dph
0673 C082       384            push dpl
0675 C0E0       384            push acc
0677 900340     384            mov dptr, #String_state0_2
067A 1205BC     384            lcall ?Send_Constant_String
067D D0E0       384            pop acc
067F D082       384            pop dpl
0681 D083       384            pop dph
0683 020774     385       ljmp LCD_Done_Bridge ; Exit
0686            386   
0686            387   LCD_Check_1: ; Setup
0686 B4011F     388       cjne a, #1, LCD_Check_2
0689 C0E0       389            push acc
068B 7401       389            mov a, #1
068D 14         389            dec a
068E 1205C9     389            lcall ?Set_Cursor_1 ; Select column and row
0691 D0E0       389            pop acc
0693 C083       390            push dph
0695 C082       390            push dpl
0697 C0E0       390            push acc
0699 9003A5     390            mov dptr, #String_state1
069C 1205BC     390            lcall ?Send_Constant_String
069F D0E0       390            pop acc
06A1 D082       390            pop dpl
06A3 D083       390            pop dph
06A5 020774     391       ljmp LCD_Done_Bridge
06A8            392   
06A8            393   LCD_Check_2: ; Ramp to Soak
06A8 B4021F     394       cjne a, #2, LCD_Check_3
06AB C0E0       395            push acc
06AD 7401       395            mov a, #1
06AF 14         395            dec a
06B0 1205C9     395            lcall ?Set_Cursor_1 ; Select column and row
06B3 D0E0       395            pop acc
06B5 C083       396            push dph
06B7 C082       396            push dpl
06B9 C0E0       396            push acc
06BB 9003E5     396            mov dptr, #String_state2
06BE 1205BC     396            lcall ?Send_Constant_String
06C1 D0E0       396            pop acc
06C3 D082       396            pop dpl
06C5 D083       396            pop dph
06C7 020797     397       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
06CA            398   
06CA            399   LCD_Check_3: ; Soak
06CA B4031F     400       cjne a, #3, LCD_Check_4
06CD C0E0       401            push acc
06CF 7401       401            mov a, #1
06D1 14         401            dec a
06D2 1205C9     401            lcall ?Set_Cursor_1 ; Select column and row
06D5 D0E0       401            pop acc
06D7 C083       402            push dph
06D9 C082       402            push dpl
06DB C0E0       402            push acc
06DD 9003F5     402            mov dptr, #String_state3
06E0 1205BC     402            lcall ?Send_Constant_String
06E3 D0E0       402            pop acc
06E5 D082       402            pop dpl
06E7 D083       402            pop dph
06E9 020797     403       ljmp LCD_Update_Temp_Value
06EC            404   
06EC            405   LCD_Check_4: ; Ramp to Peak
06EC B4041F     406       cjne a, #4, LCD_Check_5
06EF C0E0       407            push acc
06F1 7401       407            mov a, #1
06F3 14         407            dec a
06F4 1205C9     407            lcall ?Set_Cursor_1 ; Select column and row
06F7 D0E0       407            pop acc
06F9 C083       408            push dph
06FB C082       408            push dpl
06FD C0E0       408            push acc
06FF 900405     408            mov dptr, #String_state4
0702 1205BC     408            lcall ?Send_Constant_String
0705 D0E0       408            pop acc
0707 D082       408            pop dpl
0709 D083       408            pop dph
070B 020797     409       ljmp LCD_Update_Temp_Value
070E            410   
070E            411   LCD_Check_5: ; Reflow
070E B4051F     412       cjne a, #5, LCD_Check_6
0711 C0E0       413            push acc
0713 7401       413            mov a, #1
0715 14         413            dec a
0716 1205C9     413            lcall ?Set_Cursor_1 ; Select column and row
0719 D0E0       413            pop acc
071B C083       414            push dph
071D C082       414            push dpl
071F C0E0       414            push acc
0721 900415     414            mov dptr, #String_state5
0724 1205BC     414            lcall ?Send_Constant_String
0727 D0E0       414            pop acc
0729 D082       414            pop dpl
072B D083       414            pop dph
072D 020797     415       ljmp LCD_Update_Temp_Value
0730            416   
0730            417   LCD_Check_6: ; Cooling
0730 B4061F     418       cjne a, #6, LCD_Check_7
0733 C0E0       419            push acc
0735 7401       419            mov a, #1
0737 14         419            dec a
0738 1205C9     419            lcall ?Set_Cursor_1 ; Select column and row
073B D0E0       419            pop acc
073D C083       420            push dph
073F C082       420            push dpl
0741 C0E0       420            push acc
0743 900425     420            mov dptr, #String_state6
0746 1205BC     420            lcall ?Send_Constant_String
0749 D0E0       420            pop acc
074B D082       420            pop dpl
074D D083       420            pop dph
074F 020797     421       ljmp LCD_Update_Temp_Value
0752            422   
0752            423   LCD_Check_7: ; Done
0752            424       ; [FIX] Check distance safe logic for State 7
0752 B4071F     425       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
0755 C0E0       426            push acc
0757 7401       426            mov a, #1
0759 14         426            dec a
075A 1205C9     426            lcall ?Set_Cursor_1 ; Select column and row
075D D0E0       426            pop acc
075F C083       427            push dph
0761 C082       427            push dpl
0763 C0E0       427            push acc
0765 900435     427            mov dptr, #String_state7
0768 1205BC     427            lcall ?Send_Constant_String
076B D0E0       427            pop acc
076D D082       427            pop dpl
076F D083       427            pop dph
0771 020774     428       ljmp LCD_Done_Bridge
0774            429   
0774            430   ; Local bridge to reach the far-away LCD_Done
0774            431   LCD_Done_Bridge:
0774 0207D9     432       ljmp LCD_Done
0777            433   
0777            434   ; ==========================================
0777            435   ; PART 2: DYNAMIC VALUES (Temperature)
0777            436   ; Runs every time 'one_second_flag' is set
0777            437   ; ==========================================
0777            438   Check_Live_Update:
0777 3001FA     439       jnb one_second_flag, LCD_Done_Bridge
077A C201       440       clr one_second_flag
077C            441       
077C            442       ; Only update temp for States 2, 3, 4, 5, 6
077C E568       443       mov a, Control_FSM_state
077E B40202     444       cjne a, #2, Check_St3
0781 8014       445       sjmp LCD_Update_Temp_Value
0783            446   Check_St3:
0783 B40302     447       cjne a, #3, Check_St4
0786 800F       448       sjmp LCD_Update_Temp_Value
0788            449   Check_St4:
0788 B40402     450       cjne a, #4, Check_St5
078B 800A       451       sjmp LCD_Update_Temp_Value
078D            452   Check_St5:
078D B40502     453       cjne a, #5, Check_St6
0790 8005       454       sjmp LCD_Update_Temp_Value
0792            455   Check_St6:
0792 B40644     456       cjne a, #6, LCD_Done
0795 8000       457       sjmp LCD_Update_Temp_Value
0797            458   
0797            459   ; --- HELPER: Prints "XXX C" on Line 2 ---
0797            460   LCD_Update_Temp_Value:
0797 C0E0       461            push acc
0799 7401       461            mov a, #1
079B 14         461            dec a
079C 1205C7     461            lcall ?Set_Cursor_2 ; Select column and row
079F D0E0       461            pop acc
07A1            462       
07A1            463       ; Convert current_temp to BCD
07A1 853F32     464       mov x, current_temp
07A4 854033     465       mov x+1, current_temp+1
07A7 854134     466       mov x+2, current_temp+2
07AA 854235     467       mov x+3, current_temp+3
07AD 12002E     468       lcall hex2bcd
07B0            469       
07B0            470       ; Print Hundreds
07B0 E53B       471       mov a, bcd+1
07B2 540F       472       anl a, #0x0F
07B4 2430       473       add a, #0x30
07B6 12057F     474       lcall ?WriteData
07B9            475       
07B9            476       ; Print Tens
07B9 E53A       477       mov a, bcd+0
07BB C4         478       swap a
07BC 540F       479       anl a, #0x0F
07BE 2430       480       add a, #0x30
07C0 12057F     481       lcall ?WriteData
07C3            482       
07C3            483       ; Print Ones
07C3 E53A       484       mov a, bcd+0
07C5 540F       485       anl a, #0x0F
07C7 2430       486       add a, #0x30
07C9 12057F     487       lcall ?WriteData
07CC            488       
07CC            489       ; Print 'C'
07CC 7443       490       mov a, #'C'
07CE 12057F     491       lcall ?WriteData
07D1            492       
07D1            493       ; Clear remaining line space (prevents garbage)
07D1 7420       494       mov a, #' '
07D3 12057F     495       lcall ?WriteData
07D6 12057F     496       lcall ?WriteData
07D9            497   
07D9            498   LCD_Done:
07D9 D0E0       499       pop acc
07DB 22         500       ret
07DC            501   ;---------------------------------------------------------
07DC            502   
07DC            503   KEY1_DEB:
07DC            504   ;non-blocking state machine for KEY1 debounce
07DC E566       505       mov a, KEY1_DEB_state
07DE            506   KEY1_DEB_state0:
07DE B4000A     507       cjne a, #0, KEY1_DEB_state1
07E1 20F92D     508       jb KEY.1, KEY1_DEB_done
07E4 756400     509       mov KEY1_DEB_timer, #0
07E7 0566       510       inc KEY1_DEB_state
07E9 8026       511       sjmp KEY1_DEB_done
07EB            512   KEY1_DEB_state1:
07EB B40109     513       cjne a, #1, KEY1_DEB_state2
07EE            514       ; this is the debounce state
07EE E564       515       mov a, KEY1_DEB_timer
07F0 B4321E     516       cjne a, #50, KEY1_DEB_done ; 50 ms passed?
07F3 0566       517       inc KEY1_DEB_state
07F5 801A       518       sjmp KEY1_DEB_done  
07F7            519   KEY1_DEB_state2:
07F7 B4020C     520       cjne a, #2, KEY1_DEB_state3
07FA 20F904     521       jb KEY.1, KEY1_DEB_state2b
07FD 0566       522       inc KEY1_DEB_state
07FF 8010       523       sjmp KEY1_DEB_done  
0801            524   KEY1_DEB_state2b:
0801 756600     525       mov KEY1_DEB_state, #0
0804 800B       526       sjmp KEY1_DEB_done
0806            527   KEY1_DEB_state3:
0806 B40308     528       cjne a, #3, KEY1_DEB_done
0809 30F905     529       jnb KEY.1, KEY1_DEB_done
080C D20D       530       setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
080E 756600     531       mov KEY1_DEB_state, #0  
0811            532   KEY1_DEB_done:
0811 22         533       ret
0812            534   ; ------------------------------------------------------------------------------
0812            535   ; Non-blocking FSM for the one second counter
0812            536   ;-------------------------------------------------------------------------------
0812            537   SEC_FSM:
0812 E567       538       mov a, SEC_FSM_state
0814            539   SEC_FSM_state0:
0814 B4000C     540       cjne a, #0, SEC_FSM_state1
0817 E565       541       mov a, SEC_FSM_timer
0819 B4FA4B     542       cjne a, #250, SEC_FSM_done ; 250 ms passed?
081C 756500     543       mov SEC_FSM_timer, #0
081F 0567       544       inc SEC_FSM_state
0821 8044       545       sjmp SEC_FSM_done
0823            546   SEC_FSM_state1: 
0823 B4010E     547       cjne a, #1, SEC_FSM_state2
0826 D2E9       548       setb LEDRA.1
0828 E565       549       mov a, SEC_FSM_timer
082A B4FA3A     550       cjne a, #250, SEC_FSM_done ; 250 ms passed?
082D 756500     551       mov SEC_FSM_timer, #0
0830 0567       552       inc SEC_FSM_state
0832 8033       553       sjmp SEC_FSM_done
0834            554   SEC_FSM_state2: 
0834 B4020E     555       cjne a, #2, SEC_FSM_state3
0837 D2EA       556       setb LEDRA.2
0839 E565       557       mov a, SEC_FSM_timer
083B B4FA29     558       cjne a, #250, SEC_FSM_done ; 250 ms passed?
083E 756500     559       mov SEC_FSM_timer, #0
0841 0567       560       inc SEC_FSM_state
0843 8022       561       sjmp SEC_FSM_done
0845            562   SEC_FSM_state3: 
0845 B4031F     563       cjne a, #3, SEC_FSM_done
0848 D2EB       564       setb LEDRA.3
084A E565       565       mov a, SEC_FSM_timer
084C B4FA18     566       cjne a, #250, SEC_FSM_done ; 250 ms passed?
084F 756500     567       mov SEC_FSM_timer, #0
0852 756700     568       mov SEC_FSM_state, #0
0855            569       
0855            570       ; --- 1 Second has passed! ---
0855 D201       571       setb one_second_flag
0857            572       
0857 E530       573       mov a, current_time_sec
0859 B43B07     574       cjne a, #59, IncCurrentTimeSec 
085C            575       
085C            576       ; --- FIX: 59s -> 0s AND Increment Minute ---
085C 753000     577       mov current_time_sec, #0
085F 0531       578       inc current_time_minute    ; <--- YOU WERE MISSING THIS!
0861            579       ; -------------------------------------------
0861            580       
0861 8004       581       sjmp SEC_FSM_done
0863            582   
0863            583   IncCurrentTimeSec:
0863 0530       584       inc current_time_sec
0865 B2E8       585       cpl LEDRA.0 
0867            586   SEC_FSM_done:
0867 22         587       ret
0868            588   ;-------------------------------------------------------------------------------
0868            589   ; PWM
0868            590   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0868            591   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0868            592   ; ------------------------------------------------------------------------------
0868            593   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0868 100202     594       jbc one_ms_pwm_flag, pwm_wave_generator
086B 8071       595       sjmp end_pwm_generator
086D            596   
086D            597   pwm_wave_generator:
086D C200       598       clr mf
086F            599       ; move pwm counter value into x for comparison purpose
086F 856032     600       mov x, pwm_counter
0872 856133     601       mov x+1, pwm_counter+1
0875 856234     602       mov x+2, pwm_counter+2
0878 856335     603       mov x+3, pwm_counter+3
087B            604   
087B 7536DB     605            mov y+0, #low (PWM_PERIOD % 0x10000) 
087E 753705     605            mov y+1, #high(PWM_PERIOD % 0x10000) 
0881 753800     605            mov y+2, #low (PWM_PERIOD / 0x10000) 
0884 753900     605            mov y+3, #high(PWM_PERIOD / 0x10000) 
0887            606   
0887            607       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0887            608       ; increase x by 1
0887 120152     609       lcall x_eq_y 
088A 20001D     610       jb mf, wrap_pwm_counter
088D            611       ; x not equal 1499, increment by 1
088D 753601     612            mov y+0, #low (1 % 0x10000) 
0890 753700     612            mov y+1, #high(1 % 0x10000) 
0893 753800     612            mov y+2, #low (1 / 0x10000) 
0896 753900     612            mov y+3, #high(1 / 0x10000) 
0899 1200D3     613       lcall add32
089C            614       ; update pwm_counter
089C 853260     615       mov pwm_counter, x
089F 853361     616       mov pwm_counter+1, x+1
08A2 853462     617       mov pwm_counter+2, x+2
08A5 853563     618       mov pwm_counter+3, x+3
08A8 8018       619       sjmp set_pwm
08AA            620   
08AA            621   wrap_pwm_counter:
08AA            622       ; x equal 1499, wrap to 0
08AA 753200     623            mov x+0, #low (0 % 0x10000) 
08AD 753300     623            mov x+1, #high(0 % 0x10000) 
08B0 753400     623            mov x+2, #low (0 / 0x10000) 
08B3 753500     623            mov x+3, #high(0 / 0x10000) 
08B6 853260     624       mov pwm_counter, x
08B9 853361     625       mov pwm_counter+1, x+1
08BC 853462     626       mov pwm_counter+2, x+2
08BF 853563     627       mov pwm_counter+3, x+3
08C2            628   
08C2            629   set_pwm:
08C2            630       ; compare with power_output, if pwm counter smaller than power_output, 
08C2            631       ; set pwm pin high; else set pwm pin low load y with power output value
08C2 855C36     632       mov y, power_output
08C5 855D37     633       mov y+1, power_output+1
08C8 855E38     634       mov y+2, power_output+2
08CB 855F39     635       mov y+3, power_output+3
08CE            636   
08CE            637       ; compare x(pwm counter) with y(power output)
08CE 12011A     638       lcall x_lt_y
08D1 200006     639       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
08D4            640       ;output set pwm pin low if pwm counter greater than power output
08D4 C293       641       clr PWM_OUT
08D6 C2EC       642       clr LEDRA.4
08D8 8004       643       sjmp end_pwm_generator
08DA            644   
08DA            645   set_pwm_high:
08DA D293       646       setb PWM_OUT
08DC D2EC       647       setb LEDRA.4
08DE            648   
08DE            649   end_pwm_generator:
08DE 22         650       ret
08DF            651   
08DF            652   ;-------------------------------------------------------------------------------;
08DF            653   ; Temp_Compare
08DF            654   ; Checks if we have reached the user's target temperatures.
08DF            655   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
08DF            656   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
08DF            657   ;-------------------------------------------------------------------------------;
08DF            658   Temp_Compare:
08DF            659       ; Reset flags initially
08DF C203       660       clr soak_temp_reached
08E1 C204       661       clr reflow_temp_reached
08E3            662   
08E3 C0E0       663       push acc
08E5 C0D0       664       push psw
08E7 C000       665       push AR0
08E9 C001       666       push AR1
08EB C002       667       push AR2
08ED            668       
08ED            669       ; --- 1. CHECK SOAK TEMP ---
08ED            670       ; Copy current_temp to X
08ED 783F       671       mov R0, #current_temp
08EF 7932       672       mov R1, #x
08F1 120965     673       lcall Copy4_Bytes_R0_to_R1
08F4            674   
08F4            675       ; Copy soak_temp to Y
08F4 7843       676       mov R0, #soak_temp
08F6 7936       677       mov R1, #y
08F8 120965     678       lcall Copy4_Bytes_R0_to_R1
08FB            679   
08FB            680       ; Compare: Is X (Current) < Y (Target)?
08FB 12011A     681       lcall x_lt_y
08FE 200002     682       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
0901            683       
0901            684       ; If we are here, Current >= Target
0901 D203       685       setb soak_temp_reached
0903            686   
0903            687   Check_Reflow_Threshold:
0903            688       ; --- 2. CHECK REFLOW TEMP ---
0903            689       ; Copy current_temp to X (Need to reload X because math32 destroys it)
0903 783F       690       mov R0, #current_temp
0905 7932       691       mov R1, #x
0907 120965     692       lcall Copy4_Bytes_R0_to_R1
090A            693   
090A            694       ; Copy reflow_temp to Y
090A 7847       695       mov R0, #reflow_temp
090C 7936       696       mov R1, #y
090E 120965     697       lcall Copy4_Bytes_R0_to_R1
0911            698   
0911            699       ; Compare
0911 12011A     700       lcall x_lt_y
0914 200002     701       jb mf, Temp_Compare_Done
0917            702       
0917            703       ; If Current >= Target
0917 D204       704       setb reflow_temp_reached
0919            705   
0919            706   Temp_Compare_Done:
0919 D002       707       pop AR2
091B D001       708       pop AR1
091D D000       709       pop AR0
091F D0D0       710       pop psw
0921 D0E0       711       pop acc
0923 22         712       ret
0924            713   ;-------------------------------------------------------------------------------;
0924            714   ; Time_Compare
0924            715   ;
0924            716   ; PURPOSE:
0924            717   ;   Compare the elapsed time against soak and reflow
0924            718   ;   time limits.
0924            719   ;
0924            720   ; BEHAVIOR:
0924            721   ;   - If current_time >= soak_time   if soak_time_reached    = 1
0924            722   ;   - If current_time >= reflow_time if reflow_time_reached = 1
0924            723   ;
0924            724   ; NOTES:
0924            725   ;   - Time values are treated as 32-bit UNSIGNED numbers
0924            726   ;     (e.g., milliseconds or seconds).
0924            727   ;   - Uses the SAME compare logic as Temp_Compare.
0924            728   ;   - This routine ONLY SETS flags.
0924            729   ;
0924            730   ; EXPECTED VARIABLES:
0924            731   ;   current_time[4], soak_time[4], reflow_time[4]
0924            732   ;   x[4], y[4]
0924            733   ;   mf, soak_time_reached, reflow_time_reached
0924            734   ;-------------------------------------------------------------------------------;
0924            735   Time_Compare:
0924 C0E0       736       push acc
0926 C0D0       737       push psw
0928 C000       738       push AR0
092A C001       739       push AR1
092C C002       740       push AR2
092E            741   
092E            742   ; Check: current_time >= soak_time ?
092E            743       ; Copy current_time of x
092E 7850       744       mov  R0, #current_time
0930 7932       745       mov  R1, #x
0932 120965     746       lcall Copy4_Bytes_R0_to_R1
0935            747   
0935            748       ; Copy soak_time of y
0935 7854       749       mov  R0, #soak_time
0937 7936       750       mov  R1, #y
0939 120965     751       lcall Copy4_Bytes_R0_to_R1
093C            752   
093C            753       ; Compare elapsed time vs soak time
093C 12011A     754       lcall x_lt_y
093F 200002     755       jb   mf, Time_Soak_NotReached
0942 D206       756       setb soak_time_reached
0944            757   
0944            758   ; Check: current_time >= reflow_time ?
0944            759   Time_Soak_NotReached:
0944            760       ; Copy current_time of x
0944 7850       761       mov  R0, #current_time
0946 7932       762       mov  R1, #x
0948 120965     763       lcall Copy4_Bytes_R0_to_R1
094B            764   
094B            765       ; Copy reflow_time of y
094B 7858       766       mov  R0, #reflow_time
094D 7936       767       mov  R1, #y
094F 120965     768       lcall Copy4_Bytes_R0_to_R1
0952            769   
0952            770       ; Compare elapsed time vs reflow time
0952 12011A     771       lcall x_lt_y
0955 200002     772       jb   mf, Time_Reflow_NotReached
0958 D207       773       setb reflow_time_reached
095A            774   
095A            775   Time_Reflow_NotReached:
095A D002       776       pop  AR2
095C D001       777       pop  AR1
095E D000       778       pop  AR0
0960 D0D0       779       pop  psw
0962 D0E0       780       pop  acc
0964 22         781       ret
0965            782   
0965            783   ;-------------------------------------------------------------------------------;
0965            784   ; Copy4_Bytes_R0_to_R1
0965            785   ;
0965            786   ; PURPOSE:
0965            787   ;   Utility routine to copy a 32-bit value (4 bytes)
0965            788   ;   from one memory location to another.
0965            789   ;
0965            790   ; INPUTS:
0965            791   ;   R0 st source address
0965            792   ;   R1 at destination address
0965            793   ;
0965            794   ; USES:
0965            795   ;   R2 as loop counter
0965            796   ;
0965            797   ; EXAMPLE:
0965            798   ;   mov R0, #current_temp
0965            799   ;   mov R1, #x
0965            800   ;   lcall Copy4_Bytes_R0_to_R1
0965            801   ;-------------------------------------------------------------------------------;
0965            802   Copy4_Bytes_R0_to_R1:
0965 7A04       803       mov  R2, #4
0967            804   Copy4_Loop:
0967 E6         805       mov  a, @R0
0968 F7         806       mov  @R1, a
0969 08         807       inc  R0
096A 09         808       inc  R1
096B DAFA       809       djnz R2, Copy4_Loop
096D 22         810       ret
096E            811   
096E            812   ;-------------------------------------------------------------------------------;
096E            813   ; Abort condition safety check Temperature time
096E            814   ;
096E            815   ; PURPOSE:
096E            816   ;   Automatic cycle termination on error:
096E            817   ;   Abort if oven fails to reach at least 50C in first 60s.
096E            818   ;
096E            819   ; TRIP CONDITION:
096E            820   ;   if (current_time >= 60s) AND (current_temp < 50C)
096E            821   ;       -> set tc_missing_abort
096E            822   ;       -> set stop_signal
096E            823   ;
096E            824   ; ASSUMPTIONS:
096E            825   ;   - current_time is in SECONDS (32-bit, little-endian)
096E            826   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
096E            827   ;
096E            828   ;   the Load_Y constants accordingly.
096E            829   ;-------------------------------------------------------------------------------;
096E            830   Safety_Check_TC:
096E C0E0       831       push acc
0970 C0D0       832       push psw
0972 C000       833       push AR0
0974 C001       834       push AR1
0976 C002       835       push AR2
0978            836   
0978            837       ; If already aborted or startup window closed, do nothing
0978 200E3D     838       jb   tc_missing_abort, Safety_TC_Done
097B 300F3A     839       jnb  tc_startup_window, Safety_TC_Done
097E            840   
097E            841       ; Check: current_time >= 60 ?
097E 7850       842       mov  R0, #current_time
0980 7932       843       mov  R1, #x
0982 120965     844       lcall Copy4_Bytes_R0_to_R1
0985            845   
0985 75363C     846            mov y+0, #low (60 % 0x10000) 
0988 753700     846            mov y+1, #high(60 % 0x10000) 
098B 753800     846            mov y+2, #low (60 / 0x10000) 
098E 753900     846            mov y+3, #high(60 / 0x10000) 
0991 12011A     847       lcall x_lt_y
0994 200021     848       jb   mf, Safety_TC_Done        ; still < 60s  keep waiting
0997            849   
0997            850       ; We reached 60s: close the startup window so it won't re-check later
0997 C20F       851       clr  tc_startup_window
0999            852   
0999            853       ; Now check: current_temp < 50 ?
0999 783F       854       mov  R0, #current_temp
099B 7932       855       mov  R1, #x
099D 120965     856       lcall Copy4_Bytes_R0_to_R1
09A0            857   
09A0 753632     858            mov y+0, #low (50 % 0x10000) 
09A3 753700     858            mov y+1, #high(50 % 0x10000) 
09A6 753800     858            mov y+2, #low (50 / 0x10000) 
09A9 753900     858            mov y+3, #high(50 / 0x10000) 
09AC 12011A     859       lcall x_lt_y
09AF 300006     860       jnb  mf, Safety_TC_Done        ; temp >= 50  pass
09B2            861   
09B2            862       ; FAIL: at 60s, still below 50C  abort
09B2 D20E       863       setb tc_missing_abort
09B4 D209       864       setb stop_signal
09B6 C293       865       clr  PWM_OUT
09B8            866   
09B8            867   Safety_TC_Done:
09B8 D002       868       pop  AR2
09BA D001       869       pop  AR1
09BC D000       870       pop  AR0
09BE D0D0       871       pop  psw
09C0 D0E0       872       pop  acc
09C2 22         873       ret
09C3            874   
09C3            875   ;-------------------------------------------------------------------------------;
09C3            876   ; Main Control FSM for the entire process
09C3            877   ;-------------------------------------------------------------------------------;
09C3            878   ;-------------------------------------------------------------------------------;
09C3            879   ; FSM LOGIC (Button Logic Fixed)
09C3            880   ;-------------------------------------------------------------------------------;
09C3            881   Control_FSM:
09C3 E568       882       mov a, Control_FSM_state
09C5 8005       883       sjmp Control_FSM_state0
09C7            884   
09C7            885   Control_FSM_state0_a:
09C7 756800     886       mov Control_FSM_state, #0
09CA D20C       887       setb state_change_signal
09CC            888       
09CC            889   Control_FSM_state0:
09CC B40015     890       cjne a, #0, Control_FSM_state1
09CF 209005     891       jb P1.0, Control_FSM_done_bridge ; If Button High (Not Pressed), Exit
09D2 120ECE     892       lcall Wait_For_P1_0_Release      ; If Low (Pressed), Wait & Proceed
09D5 8001       893       sjmp Control_FSM_state1_a  
09D7            894       
09D7            895   Control_FSM_done_bridge:
09D7 22         896       ret
09D8            897   
09D8            898   Control_FSM_state1_a:
09D8 0568       899       inc Control_FSM_state
09DA 756900     900       mov Current_State, #0
09DD 120DA7     901       lcall Update_Screen_Full 
09E0 D20C       902       setb state_change_signal
09E2 E568       903       mov a, Control_FSM_state
09E4            904       
09E4            905   Control_FSM_state1:
09E4 B40116     906       cjne a, #1, Control_FSM_state2
09E7 120BDF     907       lcall Check_Buttons 
09EA 120C2B     908       lcall Check_Keypad
09ED            909       
09ED            910       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
09ED 209008     911       jb P1.0, Control_FSM_state1_ret
09F0            912       
09F0            913       ; If we get here, Button is LOW (Pressed)
09F0 120ECE     914       lcall Wait_For_P1_0_Release
09F3 120B63     915       lcall Update_FSM_Variables
09F6 8001       916       sjmp Control_FSM_state2_a
09F8            917   Control_FSM_state1_ret:
09F8 22         918       ret
09F9            919   
09F9            920   ; --- STATE 2: RAMP TO SOAK ---
09F9            921   Control_FSM_state2_a:
09F9 0568       922       inc Control_FSM_state
09FB D20C       923       setb state_change_signal
09FD            924   Control_FSM_state2:
09FD B4021A     925       cjne a, #2, Control_FSM_state3
0A00 301205     926       jnb PB2_flag, State2_Check
0A03 C212       927       clr PB2_flag
0A05 020A65     928       ljmp Control_FSM_state6_a ; Pause
0A08            929   State2_Check:
0A08 30030E     930       jnb soak_temp_reached, State2_Ret
0A0B C203       931       clr soak_temp_reached
0A0D 0568       932       inc Control_FSM_state
0A0F D20C       933       setb state_change_signal
0A11 753000     934       mov current_time_sec, #0
0A14 753100     935       mov current_time_minute, #0
0A17            936       
0A17            937       ; --- ADD THIS LINE ---
0A17 C206       938       clr soak_time_reached  ; Ensure we start fresh!
0A19            939       ; ---------------------
0A19            940   
0A19            941   State2_Ret:
0A19 22         942       ret
0A1A            943   
0A1A            944   ; --- STATE 3: SOAK PHASE ---
0A1A            945   Control_FSM_state3:
0A1A B40312     946       cjne a, #3, Control_FSM_state4
0A1D 301205     947       jnb PB2_flag, State3_Check
0A20 C212       948       clr PB2_flag
0A22 020A65     949       ljmp Control_FSM_state6_a
0A25            950   State3_Check:
0A25 300606     951       jnb soak_time_reached, State3_Ret
0A28 C206       952       clr soak_time_reached
0A2A 0568       953       inc Control_FSM_state      
0A2C D20C       954       setb state_change_signal 
0A2E            955   State3_Ret:
0A2E 22         956       ret
0A2F            957   
0A2F            958   ; --- STATE 4: RAMP TO PEAK ---
0A2F            959   Control_FSM_state4:
0A2F B4041A     960       cjne a, #4, Control_FSM_state5
0A32 301205     961       jnb PB2_flag, State4_Check
0A35 C212       962       clr PB2_flag
0A37 020A65     963       ljmp Control_FSM_state6_a
0A3A            964   State4_Check:
0A3A 30040E     965       jnb reflow_temp_reached, State4_Ret
0A3D C204       966       clr reflow_temp_reached
0A3F 0568       967       inc Control_FSM_state
0A41 D20C       968       setb state_change_signal
0A43 753000     969       mov current_time_sec, #0
0A46 753100     970       mov current_time_minute, #0
0A49            971       ; --- ADD THIS LINE ---
0A49 C207       972       clr reflow_time_reached ; Kill the ghost flag
0A4B            973       ; ---------------------
0A4B            974   State4_Ret:
0A4B 22         975       ret
0A4C            976   
0A4C            977   ; --- STATE 5: REFLOW PHASE ---
0A4C            978   Control_FSM_state5:
0A4C B40502     979       cjne a, #5, Control_FSM_state6_trampoline
0A4F 8003       980       sjmp State5_Logic
0A51            981   Control_FSM_state6_trampoline:
0A51 020A69     982       ljmp Control_FSM_state6
0A54            983   
0A54            984   State5_Logic:
0A54 301205     985       jnb PB2_flag, State5_Check
0A57 C212       986       clr PB2_flag
0A59 020A65     987       ljmp Control_FSM_state6_a
0A5C            988   State5_Check:
0A5C 300705     989       jnb reflow_time_reached, State5_Ret
0A5F C207       990       clr reflow_time_reached
0A61 020A65     991       ljmp Control_FSM_state6_a
0A64            992   State5_Ret:
0A64 22         993       ret
0A65            994   
0A65            995   ; --- STATE 6: COOLING ---
0A65            996   Control_FSM_state6_a:
0A65 0568       997       inc Control_FSM_state
0A67 D20C       998       setb state_change_signal
0A69            999   Control_FSM_state6:
0A69 B4060A    1000       cjne a, #6, Control_FSM_state7
0A6C           1001       ; Wait for Cooling Temp Reached
0A6C 300506    1002       jnb cooling_temp_reached, State6_Ret
0A6F C205      1003       clr cooling_temp_reached
0A71 0568      1004       inc Control_FSM_state
0A73 D20C      1005       setb state_change_signal
0A75           1006   State6_Ret:
0A75 22        1007       ret
0A76           1008   
0A76           1009   ; --- STATE 7: DONE ---
0A76           1010   Control_FSM_state7:
0A76 B40711    1011       cjne a, #7, Control_FSM_done
0A79           1012       
0A79           1013       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0A79 201009    1014       jb PB0_flag, Control_FSM_Reset_Logic ; Wait, PB0_flag is software flag?
0A7C           1015       
0A7C           1016       ; Let's assume you meant the physical button P1.0 like State 0
0A7C 20900B    1017       jb P1.0, Control_FSM_done
0A7F           1018       
0A7F 120ECE    1019       lcall Wait_For_P1_0_Release
0A82 0209C7    1020       ljmp Control_FSM_state0_a
0A85           1021   
0A85           1022   Control_FSM_Reset_Logic:
0A85           1023       ; If using PB0_flag from ISR, handle here
0A85 C210      1024       clr PB0_flag
0A87 0209C7    1025       ljmp Control_FSM_state0_a
0A8A           1026   
0A8A           1027   Control_FSM_done:
0A8A 22        1028       ret
0A8B           1029   ;-------------------------------------------------------------------------------;
0A8B           1030   ;         Main program.          
0A8B           1031   ;-------------------------------------------------------------------------------;
0A8B           1032   main:
0A8B           1033   
0A8B           1034       ; --------------------------------------------------------
0A8B           1035       ; 1. SAFETY SHUTDOWN
0A8B           1036       ; --------------------------------------------------------
0A8B C2AF      1037       clr EA              ; FORCE Interrupts OFF immediately
0A8D 7581C0    1038       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0A90           1039       
0A90           1040       ; --------------------------------------------------------
0A90           1041       ; 2. THE "DIRTY DELAY" (Fixes Reset Garbage)
0A90           1042       ; We burn ~100ms here using a raw loop. 
0A90           1043       ; We cannot use timers yet because they aren't initialized.
0A90           1044       ; --------------------------------------------------------
0A90 78FA      1045       mov R0, #250
0A92           1046   Reset_Delay_Outer:
0A92 79FF      1047       mov R1, #255
0A94           1048   Reset_Delay_Inner:
0A94 D9FE      1049       djnz R1, Reset_Delay_Inner
0A96 D8FA      1050       djnz R0, Reset_Delay_Outer
0A98           1051       ; --------------------------------------------------------
0A98           1052   
0A98           1053       ; ... NOW continue with your normal Port Configuration ...
0A98           1054       
0A98           1055       ; --- PORT CONFIGURATION ---
0A98 759AAA    1056       mov P0MOD, #0xAA
0A9B           1057   
0A9B           1058       ; P1: Mixed usage 
0A9B           1059       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0A9B           1060       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0A9B           1061       ; P1.0 (Unused/RX) -> Input
0A9B           1062       ; Binary: 11111110 -> Hex: 0xFE
0A9B 759BFE    1063       mov P1MOD, #0xFE
0A9E           1064   
0A9E           1065       ; P2: Row4(Out), Cols(In)
0A9E           1066       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0A9E           1067       ; Binary: 00000001 -> Hex: 0x01
0A9E 759C01    1068       mov P2MOD, #0x01
0AA1           1069   
0AA1           1070       ; P3: Col4(In)
0AA1           1071       ; P3.0 (Col4) is In (0).
0AA1 759D00    1072       mov P3MOD, #0x00
0AA4           1073       ; Turn off all the LEDs
0AA4 75E800    1074       mov LEDRA, #0 ; LEDRA is bit addressable
0AA7 759500    1075       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0AAA           1076   
0AAA           1077       ; Enable Global interrupts
0AAA D2AF      1078       setb EA  
0AAC           1079   
0AAC           1080       ; FSM initial states
0AAC 756600    1081       mov KEY1_DEB_state, #0
0AAF 756700    1082       mov SEC_FSM_state, #0
0AB2 756800    1083       mov Control_FSM_state, #0
0AB5 756900    1084       mov Current_State, #0
0AB8           1085       
0AB8           1086       ; FSM timers initialization
0AB8 756400    1087       mov KEY1_DEB_timer, #0
0ABB 756500    1088       mov SEC_FSM_timer, #0
0ABE           1089       ; time counters initialization
0ABE 753000    1090       mov current_time_sec, #0
0AC1 753100    1091       mov current_time_minute, #0
0AC4           1092       ; Initialize counter to zero
0AC4 756000    1093       mov pwm_counter, #0
0AC7 756100    1094       mov pwm_counter+1, #0
0ACA 756200    1095       mov pwm_counter+2, #0
0ACD 756300    1096       mov pwm_counter+3, #0
0AD0           1097       ; Initialize power output
0AD0 755F00    1098       mov power_output+3, #0
0AD3 755E00    1099       mov power_output+2, #0
0AD6 755D02    1100       mov power_output+1, #02H
0AD9 755CEE    1101       mov power_output, #0EEH ; (initilize to 750 for testing)
0ADC           1102   
0ADC           1103       ; Clear all the flags
0ADC C20E      1104       clr  tc_missing_abort
0ADE C209      1105       clr  stop_signal
0AE0 C210      1106       clr PB0_flag
0AE2 C211      1107       clr PB1_flag
0AE4 C212      1108       clr PB2_flag
0AE6 C201      1109       clr one_second_flag
0AE8 C20B      1110       clr config_finish_signal
0AEA C203      1111       clr soak_temp_reached
0AEC C206      1112       clr soak_time_reached
0AEE C204      1113       clr reflow_temp_reached
0AF0 C207      1114       clr reflow_time_reached
0AF2 C205      1115       clr cooling_temp_reached
0AF4 C20C      1116       clr state_change_signal
0AF6           1117       
0AF6 D20C      1118       setb state_change_signal
0AF8           1119   
0AF8           1120       ; Set bit
0AF8 D20F      1121       setb tc_startup_window
0AFA           1122   
0AFA 120456    1123       lcall Timer0_Init
0AFD 1204C0    1124       lcall Timer2_Init
0B00 120589    1125       lcall ELCD_4BIT
0B03           1126       ;----- Two new lines I added to initialize the UI
0B03 120D54    1127       lcall Init_All_Buffers
0B06 120DA7    1128       lcall Update_Screen_Full
0B09           1129       ;-----
0B09 120472    1130       lcall Initialize_Serial_Port
0B0C           1131   ;-------------------------------------------------------------------------------;
0B0C           1132   ; while(1) loop
0B0C           1133   ;-------------------------------------------------------------------------------;
0B0C           1134   loop:
0B0C           1135       ; Check the FSM for KEY1 debounce
0B0C 1207DC    1136       lcall KEY1_DEB
0B0F           1137       
0B0F           1138       ; Added to take temp readings
0B0F 120ED2    1139       lcall Read_Thermocouple
0B12           1140       
0B12           1141       ; 1. Check if we reached temp (Observer)
0B12 1208DF    1142       lcall Temp_Compare
0B15           1143       
0B15           1144       ; 2. Decide heater power based on flags (Driver)
0B15 120F31    1145       lcall Power_Control
0B18           1146       
0B18           1147       ; 3. [FIX] Calculate Total Seconds (Minutes * 60 + Seconds)
0B18           1148       ; ---------------------------------------------------------
0B18           1149       ; Load Minutes into X
0B18 853132    1150       mov x+0, current_time_minute
0B1B 753300    1151       mov x+1, #0
0B1E 753400    1152       mov x+2, #0
0B21 753500    1153       mov x+3, #0
0B24           1154       
0B24           1155       ; Multiply by 60 (Minutes -> Seconds)
0B24 75363C    1156            mov y+0, #low (60 % 0x10000) 
0B27 753700    1156            mov y+1, #high(60 % 0x10000) 
0B2A 753800    1156            mov y+2, #low (60 / 0x10000) 
0B2D 753900    1156            mov y+3, #high(60 / 0x10000) 
0B30 12018C    1157       lcall mul32
0B33           1158       
0B33           1159       ; Load Seconds into Y
0B33 853036    1160       mov y+0, current_time_sec
0B36 753700    1161       mov y+1, #0
0B39 753800    1162       mov y+2, #0
0B3C 753900    1163       mov y+3, #0
0B3F           1164       
0B3F           1165       ; Add them together (Total Seconds = X + Y)
0B3F 1200D3    1166       lcall add32
0B42           1167       
0B42           1168       ; Store Final Result into 'current_time'
0B42 853250    1169       mov current_time+0, x+0
0B45 853351    1170       mov current_time+1, x+1
0B48 853452    1171       mov current_time+2, x+2
0B4B 853553    1172       mov current_time+3, x+3
0B4E           1173       
0B4E 120924    1174       lcall Time_Compare
0B51           1175       
0B51 12096E    1176       lcall Safety_Check_TC
0B54           1177   
0B54           1178   
0B54           1179       ; Check the FSM for one second counter
0B54 120812    1180       lcall SEC_FSM
0B57           1181   
0B57           1182       ; Check the FSM for the overall control flow of the reflow process
0B57 1209C3    1183       lcall Control_FSM
0B5A           1184   
0B5A           1185       ; Update the LCD display based on the current state
0B5A 120639    1186       lcall LCD_Display_Update_func
0B5D           1187   
0B5D           1188       ; Update the pwm output for the ssr
0B5D 120868    1189       lcall PWM_Wave 
0B60           1190   
0B60           1191       ; After initialization the program stays in this 'forever' loop
0B60 020B0C    1192       ljmp loop
0B63           1193   ;-------------------------------------------------------------------------------;
0B63           1194   
0B63           1195   ; ================================================================
0B63           1196   ; UI & HELPER SUBROUTINES
0B63           1197   ; ================================================================
0B63           1198   
0B63           1199   ; ----------------------------------------------------------------
0B63           1200   ; MODULE: BRIDGE (Text to Integer Conversion)
0B63           1201   ; ----------------------------------------------------------------
0B63           1202   Update_FSM_Variables:
0B63           1203       ; --- 1. SOAK TEMP ---
0B63 786B      1204       mov R0, #Buf_Soak_Temp
0B65 120BA2    1205       lcall Parse_Temp_String
0B68 8F43      1206       mov soak_temp+0, R7
0B6A 754400    1207       mov soak_temp+1, #0
0B6D 754500    1208       mov soak_temp+2, #0
0B70 754600    1209       mov soak_temp+3, #0
0B73           1210   
0B73           1211       ; --- 2. REFLOW TEMP ---
0B73 7874      1212       mov R0, #Buf_Refl_Temp
0B75 120BA2    1213       lcall Parse_Temp_String
0B78 8F47      1214       mov reflow_temp+0, R7
0B7A 754800    1215       mov reflow_temp+1, #0
0B7D 754900    1216       mov reflow_temp+2, #0
0B80 754A00    1217       mov reflow_temp+3, #0
0B83           1218   
0B83           1219       ; --- 3. SOAK TIME ---
0B83 786F      1220       mov R0, #Buf_Soak_Time
0B85 120BB6    1221       lcall Parse_Time_String
0B88 8F54      1222       mov soak_time+0, R7
0B8A 8E55      1223       mov soak_time+1, R6
0B8C 755600    1224       mov soak_time+2, #0
0B8F 755700    1225       mov soak_time+3, #0
0B92           1226   
0B92           1227       ; --- 4. REFLOW TIME ---
0B92 7878      1228       mov R0, #Buf_Refl_Time
0B94 120BB6    1229       lcall Parse_Time_String
0B97 8F58      1230       mov reflow_time+0, R7
0B99 8E59      1231       mov reflow_time+1, R6
0B9B 755A00    1232       mov reflow_time+2, #0
0B9E 755B00    1233       mov reflow_time+3, #0
0BA1 22        1234       ret
0BA2           1235   
0BA2           1236   ; --- Helper: Parse "123" to Integer ---
0BA2           1237   Parse_Temp_String:
0BA2 7F00      1238       mov R7, #0              ; Clear Result
0BA4           1239   Parse_Temp_Loop:
0BA4 E6        1240       mov A, @R0
0BA5 600E      1241       jz Parse_Temp_Done      ; If Null, we are done
0BA7           1242       
0BA7           1243       ; Convert ASCII to Digit
0BA7 C3        1244       clr C
0BA8 9430      1245       subb A, #0x30
0BAA FD        1246       mov R5, A               ; R5 = New Digit
0BAB           1247       
0BAB           1248       ; Result = (Result * 10) + New Digit
0BAB EF        1249       mov A, R7
0BAC 75F00A    1250       mov B, #10
0BAF A4        1251       mul AB
0BB0 2D        1252       add A, R5
0BB1 FF        1253       mov R7, A
0BB2           1254       
0BB2 08        1255       inc R0
0BB3 80EF      1256       sjmp Parse_Temp_Loop
0BB5           1257   Parse_Temp_Done:
0BB5 22        1258       ret
0BB6           1259   
0BB6           1260   ; --- Helper: Parse "MMSS" to Seconds ---
0BB6           1261   Parse_Time_String:
0BB6           1262       ; 1. Minutes Tens
0BB6 E6        1263       mov A, @R0
0BB7 9430      1264       subb A, #0x30
0BB9 75F00A    1265       mov B, #10
0BBC A4        1266       mul AB
0BBD FD        1267       mov R5, A
0BBE 08        1268       inc R0
0BBF           1269       
0BBF           1270       ; 2. Minutes Ones
0BBF E6        1271       mov A, @R0
0BC0 9430      1272       subb A, #0x30
0BC2 2D        1273       add A, R5
0BC3 FD        1274       mov R5, A               ; R5 = Total Minutes
0BC4 08        1275       inc R0
0BC5           1276       
0BC5           1277       ; 3. Seconds Tens
0BC5 E6        1278       mov A, @R0
0BC6 9430      1279       subb A, #0x30
0BC8 75F00A    1280       mov B, #10
0BCB A4        1281       mul AB
0BCC FC        1282       mov R4, A
0BCD 08        1283       inc R0
0BCE           1284       
0BCE           1285       ; 4. Seconds Ones
0BCE E6        1286       mov A, @R0
0BCF 9430      1287       subb A, #0x30
0BD1 2C        1288       add A, R4               ; R4 = Total Seconds
0BD2           1289       
0BD2           1290       ; 5. Calculate Total Seconds = (Mins * 60) + Secs
0BD2 ED        1291       mov A, R5
0BD3 75F03C    1292       mov B, #60
0BD6 A4        1293       mul AB
0BD7 2C        1294       add A, R4
0BD8 FF        1295       mov R7, A               ; Low Byte
0BD9 E5F0      1296       mov A, B
0BDB 3400      1297       addc A, #0
0BDD FE        1298       mov R6, A               ; High Byte
0BDE 22        1299       ret
0BDF           1300   
0BDF           1301   ; ----------------------------------------------------------------
0BDF           1302   ; MODULE: BUTTON HANDLER (Mode Selection)
0BDF           1303   ; ----------------------------------------------------------------
0BDF           1304   Check_Buttons:
0BDF           1305       ; --- FORCE INPUT MODE ---
0BDF           1306       ; This clears any '0' the LCD library might have written to our buttons
0BDF 438055    1307       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0BE2           1308       ; ------------------------
0BE2           1309   
0BE2 30800A    1310       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0BE5 308212    1311       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0BE8 30841A    1312       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0BEB 308622    1313       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0BEE 22        1314       ret
0BEF           1315   
0BEF           1316   Btn_Soak_Temp_Press:
0BEF 120E9E    1317       lcall Wait_25ms_BLOCKING
0BF2 756901    1318       mov Current_State, #1
0BF5 756A00    1319       mov Cursor_Idx, #0
0BF8 8021      1320       sjmp Redraw_Screen
0BFA           1321   
0BFA           1322   Btn_Soak_Time_Press:
0BFA 120E9E    1323       lcall Wait_25ms_BLOCKING
0BFD 756902    1324       mov Current_State, #2
0C00 756A00    1325       mov Cursor_Idx, #0
0C03 8016      1326       sjmp Redraw_Screen
0C05           1327   
0C05           1328   Btn_Refl_Temp_Press:
0C05 120E9E    1329       lcall Wait_25ms_BLOCKING
0C08 756903    1330       mov Current_State, #3
0C0B 756A00    1331       mov Cursor_Idx, #0
0C0E 800B      1332       sjmp Redraw_Screen
0C10           1333   
0C10           1334   Btn_Refl_Time_Press:
0C10 120E9E    1335       lcall Wait_25ms_BLOCKING 
0C13 756904    1336       mov Current_State, #4
0C16 756A00    1337       mov Cursor_Idx, #0
0C19 8000      1338       sjmp Redraw_Screen
0C1B           1339   
0C1B           1340   Redraw_Screen:
0C1B           1341       ; Wait for button release
0C1B 3080FD    1342       jnb BTN_SOAK_TEMP, $
0C1E 3082FD    1343       jnb BTN_SOAK_TIME, $
0C21 3084FD    1344       jnb BTN_REFL_TEMP, $
0C24 3086FD    1345       jnb BTN_REFL_TIME, $
0C27           1346   
0C27 120DA7    1347       lcall Update_Screen_Full
0C2A 22        1348       ret
0C2B           1349   
0C2B           1350   ; ----------------------------------------------------------------
0C2B           1351   ; MODULE: KEYPAD HANDLER (Input Logic)
0C2B           1352   ; ----------------------------------------------------------------
0C2B           1353   Check_Keypad:
0C2B           1354       ; If State is 0 (Home), ignore keypad
0C2B E569      1355       mov A, Current_State
0C2D 6050      1356       jz Keypad_Exit
0C2F           1357       
0C2F 120C80    1358       lcall Keypad_Scan
0C32 504B      1359       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0C34           1360   
0C34           1361       ; --- Check Special Keys ---
0C34 EF        1362       mov A, R7
0C35 B40E0A    1363       cjne A, #14, Check_Hash ; 14 is Star (*)
0C38           1364       
0C38           1365       ; Star Key Pressed: Reset Buffer
0C38 120D84    1366       lcall Reset_Current_Buffer
0C3B 120DA7    1367       lcall Update_Screen_Full
0C3E 756A00    1368       mov Cursor_Idx, #0
0C41 22        1369       ret
0C42           1370   
0C42           1371   Check_Hash:
0C42 EF        1372       mov A, R7
0C43 B40C01    1373       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0C46 22        1374       ret                     ; Ignore Hash key
0C47           1375   
0C47           1376   Check_Numeric:
0C47           1377       ; Ensure key is 0-9
0C47 EF        1378       mov A, R7
0C48 C3        1379       clr C
0C49 940A      1380       subb A, #10
0C4B 5031      1381       jnc Symbol_Key_Ignored
0C4D           1382       
0C4D           1383       ; Convert to ASCII
0C4D EF        1384       mov A, R7
0C4E 2430      1385       add A, #0x30
0C50 FD        1386       mov R5, A
0C51           1387   
0C51           1388       ; Save to Buffer
0C51 120EB7    1389       lcall Get_Current_Buffer_Addr
0C54 E56A      1390       mov A, Cursor_Idx
0C56 28        1391       add A, R0
0C57 F8        1392       mov R0, A
0C58 ED        1393       mov A, R5
0C59 F6        1394       mov @R0, A
0C5A 056A      1395       inc Cursor_Idx
0C5C           1396   
0C5C           1397       ; --- Check Cursor Limits ---
0C5C E569      1398       mov A, Current_State
0C5E B40102    1399       cjne A, #1, Check_Limit_Time_1
0C61 8005      1400       sjmp Limit_Temp_3
0C63           1401   
0C63           1402   Check_Limit_Time_1:
0C63 B4030B    1403       cjne A, #3, Limit_Time_4
0C66 8000      1404       sjmp Limit_Temp_3
0C68           1405   
0C68           1406   Limit_Temp_3:
0C68 E56A      1407       mov A, Cursor_Idx
0C6A B4030D    1408       cjne A, #3, Do_Refresh
0C6D 156A      1409       dec Cursor_Idx          ; Stay at last digit
0C6F 8009      1410       sjmp Do_Refresh
0C71           1411   
0C71           1412   Limit_Time_4:
0C71 E56A      1413       mov A, Cursor_Idx
0C73 B40404    1414       cjne A, #4, Do_Refresh
0C76 156A      1415       dec Cursor_Idx          ; Stay at last digit
0C78 8000      1416       sjmp Do_Refresh
0C7A           1417   
0C7A           1418   Do_Refresh:
0C7A 120DA7    1419       lcall Update_Screen_Full
0C7D 22        1420       ret
0C7E           1421   
0C7E           1422   Symbol_Key_Ignored:
0C7E 22        1423       ret
0C7F           1424   Keypad_Exit:
0C7F 22        1425       ret
0C80           1426   
0C80           1427   ; ----------------------------------------------------------------
0C80           1428   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0C80           1429   ; ----------------------------------------------------------------
0C80           1430   Keypad_Scan:
0C80           1431       ; Step 1: Check if ANY key is pressed (All Rows Low)
0C80 C292      1432       clr ROW1
0C82 C294      1433       clr ROW2
0C84 C296      1434       clr ROW3
0C86 C2A0      1435       clr ROW4
0C88 A2A2      1436       mov C, COL1
0C8A 82A4      1437       anl C, COL2
0C8C 82A6      1438       anl C, COL3
0C8E 82B0      1439       anl C, COL4
0C90 5002      1440       jnc Keypad_Debounce
0C92 C3        1441       clr C
0C93 22        1442       ret
0C94           1443   
0C94           1444   Keypad_Debounce:
0C94 120E9E    1445       lcall Wait_25ms_BLOCKING
0C97 A2A2      1446       mov C, COL1
0C99 82A4      1447       anl C, COL2
0C9B 82A6      1448       anl C, COL3
0C9D 82B0      1449       anl C, COL4
0C9F 5002      1450       jnc Keypad_Find_Row
0CA1 C3        1451       clr C
0CA2 22        1452       ret
0CA3           1453   
0CA3           1454   Keypad_Find_Row:
0CA3 D292      1455       setb ROW1
0CA5 D294      1456       setb ROW2
0CA7 D296      1457       setb ROW3
0CA9 D2A0      1458       setb ROW4
0CAB           1459   
0CAB           1460       ; Row 1
0CAB C292      1461       clr ROW1
0CAD 30A23D    1462       jnb COL1, Keypad_Key_1
0CB0 30A43E    1463       jnb COL2, Keypad_Key_2
0CB3 30A63F    1464       jnb COL3, Keypad_Key_3
0CB6 30B040    1465       jnb COL4, Keypad_Key_A
0CB9 D292      1466       setb ROW1
0CBB           1467   
0CBB           1468       ; Row 2
0CBB C294      1469       clr ROW2
0CBD 30A23D    1470       jnb COL1, Keypad_Key_4
0CC0 30A43E    1471       jnb COL2, Keypad_Key_5
0CC3 30A63F    1472       jnb COL3, Keypad_Key_6
0CC6 30B040    1473       jnb COL4, Keypad_Key_B
0CC9 D294      1474       setb ROW2
0CCB           1475   
0CCB           1476       ; Row 3
0CCB C296      1477       clr ROW3
0CCD 30A23D    1478       jnb COL1, Keypad_Key_7
0CD0 30A43E    1479       jnb COL2, Keypad_Key_8
0CD3 30A63F    1480       jnb COL3, Keypad_Key_9
0CD6 30B040    1481       jnb COL4, Keypad_Key_C
0CD9 D296      1482       setb ROW3
0CDB           1483   
0CDB           1484       ; Row 4
0CDB C2A0      1485       clr ROW4
0CDD 30A23D    1486       jnb COL1, Keypad_Key_Star
0CE0 30A43E    1487       jnb COL2, Keypad_Key_0
0CE3 30A63F    1488       jnb COL3, Keypad_Key_Hash
0CE6 30B040    1489       jnb COL4, Keypad_Key_D
0CE9 D2A0      1490       setb ROW4
0CEB C3        1491       clr C
0CEC 22        1492       ret
0CED           1493   
0CED           1494   ; Key Mapping (Renamed to avoid conflicts)
0CED 7F01      1495   Keypad_Key_1: mov R7, #1
0CEF 803C      1496          sjmp Wait_Release
0CF1 7F02      1497   Keypad_Key_2: mov R7, #2
0CF3 8038      1498          sjmp Wait_Release
0CF5 7F03      1499   Keypad_Key_3: mov R7, #3
0CF7 8034      1500          sjmp Wait_Release
0CF9 7F0A      1501   Keypad_Key_A: mov R7, #10
0CFB 8030      1502          sjmp Wait_Release
0CFD 7F04      1503   Keypad_Key_4: mov R7, #4
0CFF 802C      1504          sjmp Wait_Release
0D01 7F05      1505   Keypad_Key_5: mov R7, #5
0D03 8028      1506          sjmp Wait_Release
0D05 7F06      1507   Keypad_Key_6: mov R7, #6
0D07 8024      1508          sjmp Wait_Release
0D09 7F0B      1509   Keypad_Key_B: mov R7, #11
0D0B 8020      1510          sjmp Wait_Release
0D0D 7F07      1511   Keypad_Key_7: mov R7, #7
0D0F 801C      1512          sjmp Wait_Release
0D11 7F08      1513   Keypad_Key_8: mov R7, #8
0D13 8018      1514          sjmp Wait_Release
0D15 7F09      1515   Keypad_Key_9: mov R7, #9
0D17 8014      1516          sjmp Wait_Release
0D19 7F0D      1517   Keypad_Key_C: mov R7, #13
0D1B 8010      1518          sjmp Wait_Release
0D1D 7F0E      1519   Keypad_Key_Star: mov R7, #14
0D1F 800C      1520          sjmp Wait_Release
0D21 7F00      1521   Keypad_Key_0: mov R7, #0
0D23 8008      1522          sjmp Wait_Release
0D25 7F0C      1523   Keypad_Key_Hash: mov R7, #12
0D27 8004      1524          sjmp Wait_Release
0D29 7F0F      1525   Keypad_Key_D: mov R7, #15
0D2B 8000      1526          sjmp Wait_Release
0D2D           1527   
0D2D           1528   Wait_Release:
0D2D A2A2      1529       mov C, COL1
0D2F 82A4      1530       anl C, COL2
0D31 82A6      1531       anl C, COL3
0D33 82B0      1532       anl C, COL4
0D35 50F6      1533       jnc Wait_Release
0D37 D3        1534       setb C
0D38 D292      1535       setb ROW1
0D3A D294      1536       setb ROW2
0D3C D296      1537       setb ROW3
0D3E D2A0      1538       setb ROW4
0D40 22        1539       ret
0D41           1540   
0D41           1541   Wait_25ms:
0D41           1542       ; 1. Check if we are already waiting
0D41 20130E    1543       jb wait25_active, Check_Timer_Status
0D44           1544       
0D44           1545       ; 2. Check if we just finished
0D44 301404    1546       jnb wait25_done, Start_New_Timer
0D47           1547       
0D47           1548       ; 3. Timer is DONE! Reset flags and return True
0D47 C214      1549       clr wait25_done
0D49 D3        1550       setb C          ; Carry = 1 means "Done"
0D4A 22        1551       ret
0D4B           1552   
0D4B           1553   Start_New_Timer:
0D4B           1554       ; 4. Start a new 25ms wait
0D4B 754F00    1555       mov wait25_count, #0
0D4E D213      1556       setb wait25_active
0D50 C3        1557       clr C           ; Carry = 0 means "Not Done Yet"
0D51 22        1558       ret
0D52           1559   
0D52           1560   Check_Timer_Status:
0D52           1561       ; 5. Still waiting... return False immediately
0D52 C3        1562       clr C           ; Carry = 0 means "Not Done Yet"
0D53 22        1563       ret
0D54           1564   
0D54           1565   ; ----------------------------------------------------------------
0D54           1566   ; MODULE: BUFFER INIT (Reset Logic)
0D54           1567   ; ----------------------------------------------------------------
0D54           1568   Init_All_Buffers:
0D54 786B      1569       mov R0, #Buf_Soak_Temp
0D56 120D69    1570       lcall Init_Temp_Template
0D59 7874      1571       mov R0, #Buf_Refl_Temp
0D5B 120D69    1572       lcall Init_Temp_Template
0D5E 786F      1573       mov R0, #Buf_Soak_Time
0D60 120D75    1574       lcall Init_Time_Template
0D63 7878      1575       mov R0, #Buf_Refl_Time
0D65 120D75    1576       lcall Init_Time_Template
0D68 22        1577       ret
0D69           1578   
0D69           1579   Init_Temp_Template:
0D69 7630      1580       mov @R0, #'0'
0D6B 08        1581       inc R0
0D6C 7630      1582       mov @R0, #'0'
0D6E 08        1583       inc R0
0D6F 7630      1584       mov @R0, #'0'
0D71 08        1585       inc R0
0D72 7600      1586       mov @R0, #0
0D74 22        1587       ret
0D75           1588   
0D75           1589   Init_Time_Template:
0D75 7630      1590       mov @R0, #'0'
0D77 08        1591       inc R0
0D78 7630      1592       mov @R0, #'0'
0D7A 08        1593       inc R0
0D7B 7630      1594       mov @R0, #'0'
0D7D 08        1595       inc R0
0D7E 7630      1596       mov @R0, #'0'
0D80 08        1597       inc R0
0D81 7600      1598       mov @R0, #0
0D83 22        1599       ret
0D84           1600   
0D84           1601   Reset_Current_Buffer:
0D84 E569      1602       mov A, Current_State
0D86 B40106    1603       cjne A, #1, Reset_Chk_2
0D89 786B      1604       mov R0, #Buf_Soak_Temp
0D8B 120D69    1605       lcall Init_Temp_Template
0D8E 22        1606       ret
0D8F           1607   Reset_Chk_2:
0D8F B40206    1608       cjne A, #2, Reset_Chk_3
0D92 786F      1609       mov R0, #Buf_Soak_Time
0D94 120D75    1610       lcall Init_Time_Template
0D97 22        1611       ret
0D98           1612   Reset_Chk_3:
0D98 B40306    1613       cjne A, #3, Reset_Chk_4
0D9B 7874      1614       mov R0, #Buf_Refl_Temp
0D9D 120D69    1615       lcall Init_Temp_Template
0DA0 22        1616       ret
0DA1           1617   Reset_Chk_4:
0DA1 7878      1618       mov R0, #Buf_Refl_Time
0DA3 120D75    1619       lcall Init_Time_Template
0DA6 22        1620       ret
0DA7           1621   
0DA7           1622   ; ----------------------------------------------------------------
0DA7           1623   ; MODULE: SCREEN UPDATE (Visual Logic)
0DA7           1624   ; ----------------------------------------------------------------
0DA7           1625   Update_Screen_Full:
0DA7 120EA4    1626       lcall Clear_Screen_Func
0DAA C0E0      1627            push acc
0DAC 7401      1627            mov a, #1
0DAE 14        1627            dec a
0DAF 1205C9    1627            lcall ?Set_Cursor_1 ; Select column and row
0DB2 D0E0      1627            pop acc
0DB4           1628   
0DB4           1629       ; --- Draw Line 1 (Titles) ---
0DB4 E569      1630       mov A, Current_State
0DB6 B40013    1631       cjne A, #0, Update_State_1
0DB9 C083      1632            push dph
0DBB C082      1632            push dpl
0DBD C0E0      1632            push acc
0DBF 900350    1632            mov dptr, #Txt_Home
0DC2 1205BC    1632            lcall ?Send_Constant_String
0DC5 D0E0      1632            pop acc
0DC7 D082      1632            pop dpl
0DC9 D083      1632            pop dph
0DCB 22        1633       ret 
0DCC           1634   Update_State_1:
0DCC B40114    1635       cjne A, #1, Update_State_2
0DCF C083      1636            push dph
0DD1 C082      1636            push dpl
0DD3 C0E0      1636            push acc
0DD5 900361    1636            mov dptr, #Txt_SoakT
0DD8 1205BC    1636            lcall ?Send_Constant_String
0DDB D0E0      1636            pop acc
0DDD D082      1636            pop dpl
0DDF D083      1636            pop dph
0DE1 8042      1637       sjmp Draw_Temp_Format
0DE3           1638   Update_State_2:
0DE3 B40214    1639       cjne A, #2, Update_State_3
0DE6 C083      1640            push dph
0DE8 C082      1640            push dpl
0DEA C0E0      1640            push acc
0DEC 900372    1640            mov dptr, #Txt_SoakTime
0DEF 1205BC    1640            lcall ?Send_Constant_String
0DF2 D0E0      1640            pop acc
0DF4 D082      1640            pop dpl
0DF6 D083      1640            pop dph
0DF8 8042      1641       sjmp Draw_Time_Format
0DFA           1642   Update_State_3:
0DFA B40314    1643       cjne A, #3, Update_State_4
0DFD C083      1644            push dph
0DFF C082      1644            push dpl
0E01 C0E0      1644            push acc
0E03 900383    1644            mov dptr, #Txt_ReflT
0E06 1205BC    1644            lcall ?Send_Constant_String
0E09 D0E0      1644            pop acc
0E0B D082      1644            pop dpl
0E0D D083      1644            pop dph
0E0F 8014      1645       sjmp Draw_Temp_Format
0E11           1646   Update_State_4:
0E11 C083      1647            push dph
0E13 C082      1647            push dpl
0E15 C0E0      1647            push acc
0E17 900394    1647            mov dptr, #Txt_ReflTime
0E1A 1205BC    1647            lcall ?Send_Constant_String
0E1D D0E0      1647            pop acc
0E1F D082      1647            pop dpl
0E21 D083      1647            pop dph
0E23 8017      1648       sjmp Draw_Time_Format
0E25           1649   
0E25           1650   ; --- Draw Line 2 (Values) ---
0E25           1651   Draw_Temp_Format:
0E25 C0E0      1652            push acc
0E27 7401      1652            mov a, #1
0E29 14        1652            dec a
0E2A 1205C7    1652            lcall ?Set_Cursor_2 ; Select column and row
0E2D D0E0      1652            pop acc
0E2F 120EB7    1653       lcall Get_Current_Buffer_Addr
0E32 120E94    1654       lcall Print_String_RAM
0E35 7443      1655       mov A, #'C'
0E37 12057F    1656       lcall ?WriteData
0E3A 802C      1657       sjmp Restore_Cursor
0E3C           1658   
0E3C           1659   Draw_Time_Format:
0E3C C0E0      1660            push acc
0E3E 7401      1660            mov a, #1
0E40 14        1660            dec a
0E41 1205C7    1660            lcall ?Set_Cursor_2 ; Select column and row
0E44 D0E0      1660            pop acc
0E46 120EB7    1661       lcall Get_Current_Buffer_Addr
0E49           1662       ; MM
0E49 E6        1663       mov A, @R0
0E4A 12057F    1664       lcall ?WriteData
0E4D 08        1665       inc R0
0E4E E6        1666       mov A, @R0
0E4F 12057F    1667       lcall ?WriteData
0E52 08        1668       inc R0
0E53           1669       ; Colon
0E53 743A      1670       mov A, #':'
0E55 12057F    1671       lcall ?WriteData
0E58           1672       ; SS
0E58 E6        1673       mov A, @R0
0E59 12057F    1674       lcall ?WriteData
0E5C 08        1675       inc R0
0E5D E6        1676       mov A, @R0
0E5E 12057F    1677       lcall ?WriteData
0E61           1678       ; Unit
0E61 7473      1679       mov A, #'s'
0E63 12057F    1680       lcall ?WriteData
0E66 8000      1681       sjmp Restore_Cursor
0E68           1682   
0E68           1683   ; --- Restore Cursor Position ---
0E68           1684   Restore_Cursor:
0E68 E569      1685       mov A, Current_State
0E6A B40202    1686       cjne A, #2, RC_Check_State_4  
0E6D 800D      1687       sjmp Adjust_Cursor_Time
0E6F           1688   RC_Check_State_4:             
0E6F B40402    1689       cjne A, #4, Normal_Cursor
0E72 8008      1690       sjmp Adjust_Cursor_Time
0E74           1691   
0E74           1692   Normal_Cursor:
0E74 E56A      1693       mov A, Cursor_Idx
0E76 24C0      1694       add A, #0xC0
0E78 120584    1695       lcall ?WriteCommand
0E7B 22        1696       ret
0E7C           1697   
0E7C           1698   Adjust_Cursor_Time:
0E7C           1699       ; Skip the colon index (2)
0E7C E56A      1700       mov A, Cursor_Idx
0E7E B40201    1701       cjne A, #2, No_Skip
0E81 04        1702       inc A 
0E82           1703   No_Skip:
0E82           1704       ; Add 1 if past the colon
0E82 C3        1705       clr C
0E83 9402      1706       subb A, #2
0E85 4005      1707       jc No_Add
0E87 E56A      1708       mov A, Cursor_Idx
0E89 04        1709       inc A
0E8A 8002      1710       sjmp Final_Cursor_Set
0E8C           1711   No_Add:
0E8C E56A      1712       mov A, Cursor_Idx
0E8E           1713   Final_Cursor_Set:
0E8E 24C0      1714       add A, #0xC0
0E90 120584    1715       lcall ?WriteCommand
0E93 22        1716       ret
0E94           1717   
0E94           1718   Print_String_RAM:
0E94 E6        1719       mov A, @R0
0E95 6006      1720       jz Print_String_Done
0E97 12057F    1721       lcall ?WriteData
0E9A 08        1722       inc R0
0E9B 80F7      1723       sjmp Print_String_RAM
0E9D           1724   Print_String_Done:
0E9D 22        1725       ret
0E9E           1726   
0E9E           1727   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0E9E           1728   Wait_25ms_BLOCKING:
0E9E 120D41    1729       lcall Wait_25ms
0EA1 50FB      1730       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0EA3 22        1731       ret
0EA4           1732   
0EA4           1733   Clear_Screen_Func:
0EA4 7401      1734       mov A, #0x01
0EA6 120584    1735       lcall ?WriteCommand
0EA9           1736       
0EA9           1737       ; --- FIX: HARDWARE DELAY LOOP (MAX STRENGTH) ---
0EA9           1738       ; The LCD needs ~2ms to clear. 
0EA9           1739       ; We use R0=255 to guarantee ~5ms+ delay.
0EA9           1740       ; This ensures the LCD is 100% ready before we send "Ramp to Soak".
0EA9 78FF      1741       mov R0, #255
0EAB           1742   Clear_Delay_Loop_Outer:
0EAB 79FF      1743       mov R1, #255
0EAD           1744   Clear_Delay_Loop_Inner:
0EAD D9FE      1745       djnz R1, Clear_Delay_Loop_Inner
0EAF D8FA      1746       djnz R0, Clear_Delay_Loop_Outer
0EB1           1747       ; -----------------------------------------------
0EB1           1748   
0EB1 740C      1749       mov A, #0x0C  ; Display ON, Cursor OFF
0EB3 120584    1750       lcall ?WriteCommand
0EB6 22        1751       ret
0EB7           1752   
0EB7           1753   Get_Current_Buffer_Addr:
0EB7 E569      1754       mov A, Current_State
0EB9 B40103    1755       cjne A, #1, Get_Buf_2
0EBC 786B      1756       mov R0, #Buf_Soak_Temp
0EBE 22        1757       ret
0EBF           1758   Get_Buf_2:
0EBF B40203    1759       cjne A, #2, Get_Buf_3
0EC2 786F      1760       mov R0, #Buf_Soak_Time
0EC4 22        1761       ret
0EC5           1762   Get_Buf_3:
0EC5 B40303    1763       cjne A, #3, Get_Buf_4
0EC8 7874      1764       mov R0, #Buf_Refl_Temp
0ECA 22        1765       ret
0ECB           1766   Get_Buf_4:
0ECB 7878      1767       mov R0, #Buf_Refl_Time
0ECD 22        1768       ret
0ECE           1769       
0ECE           1770   ; --- Helper to prevent "Machine Gun" button presses ---
0ECE           1771   Wait_For_P1_0_Release:
0ECE 3090FD    1772       jnb P1.0, $    ; Wait here while the button is still pressed (0)
0ED1 22        1773       ret
0ED2           1774       
0ED2           1775       
0ED2           1776   ; ================================================================
0ED2           1777   ; MODULE: THERMOCOUPLE ADC DRIVER
0ED2           1778   ; ================================================================
0ED2           1779   Read_Thermocouple:
0ED2           1780       ; 1. Check Non-Blocking Timer (Run once every 25ms)
0ED2 120D41    1781       lcall Wait_25ms
0ED5 5059      1782       jnc Read_TC_Exit ; If 25ms hasn't passed, exit immediately
0ED7           1783       
0ED7           1784       ; --- 25ms Passed! Time to Read ---
0ED7           1785       
0ED7           1786       ; 2. Initialize / Trigger ADC
0ED7           1787       ; Writing to ADC_C (0xA1) triggers the conversion
0ED7 75A180    1788       mov ADC_C, #0x80    ; Reset / Strobe
0EDA 00        1789       nop
0EDB 00        1790       nop
0EDC 75A100    1791       mov ADC_C, #0x00    ; Select Channel 0 (ADCINPUT 0) and Start
0EDF           1792       
0EDF           1793       ; 3. [FIX] Settle Delay
0EDF           1794       ; The DE10-Lite ADC bridge needs time to fetch data from the MAX10 chip.
0EDF           1795       ; We burn ~500 cycles to be absolutely safe.
0EDF 7DFA      1796       mov R5, #250
0EE1           1797   ADC_Settle_Loop:
0EE1 00        1798       nop
0EE2 00        1799       nop
0EE3 DDFC      1800       djnz R5, ADC_Settle_Loop
0EE5           1801       
0EE5           1802       ; 4. Read Raw Data
0EE5 85A232    1803       mov x+0, ADC_L      ; Read Low Byte (0xA2)
0EE8 85A333    1804       mov x+1, ADC_H      ; Read High Byte (0xA3)
0EEB 753400    1805       mov x+2, #0
0EEE 753500    1806       mov x+3, #0
0EF1           1807       
0EF1           1808       ; 5. [FIX] Mask the 12-bit Data
0EF1           1809       ; The ADC is 12-bit. We MUST zero out the upper 4 bits of the High Byte
0EF1           1810       ; or the math below will overflow and return 0.
0EF1 E533      1811       mov a, x+1
0EF3 540F      1812       anl a, #0x0F
0EF5 F533      1813       mov x+1, a
0EF7           1814       
0EF7           1815       ; 6. Convert to Voltage (Count * 5000 / 4095)
0EF7 753688    1816            mov y+0, #low (5000 % 0x10000) 
0EFA 753713    1816            mov y+1, #high(5000 % 0x10000) 
0EFD 753800    1816            mov y+2, #low (5000 / 0x10000) 
0F00 753900    1816            mov y+3, #high(5000 / 0x10000)         ; Vref = 5000mV
0F03 12018C    1817       lcall mul32         
0F06           1818       
0F06 7536FF    1819            mov y+0, #low (4095 % 0x10000) 
0F09 75370F    1819            mov y+1, #high(4095 % 0x10000) 
0F0C 753800    1819            mov y+2, #low (4095 / 0x10000) 
0F0F 753900    1819            mov y+3, #high(4095 / 0x10000)         ; 12-bit resolution
0F12 120280    1820       lcall div32         
0F15           1821       
0F15           1822       ; 7. Convert to Temp (Voltage / 10mV) -> e.g. 250mV / 10 = 25C
0F15           1823       ; Change this Load_y value if your amp gain is different!
0F15 75360A    1824            mov y+0, #low (10 % 0x10000) 
0F18 753700    1824            mov y+1, #high(10 % 0x10000) 
0F1B 753800    1824            mov y+2, #low (10 / 0x10000) 
0F1E 753900    1824            mov y+3, #high(10 / 0x10000)           
0F21 120280    1825       lcall div32         
0F24           1826       
0F24           1827       ; 8. Store Final Result
0F24 85323F    1828       mov current_temp+0, x+0
0F27 853340    1829       mov current_temp+1, x+1
0F2A 853441    1830       mov current_temp+2, x+2
0F2D 853542    1831       mov current_temp+3, x+3
0F30           1832   
0F30           1833   Read_TC_Exit:
0F30 22        1834       ret
0F31           1835       
0F31           1836   ; ================================================================
0F31           1837   ; MODULE: POWER CONTROLLER (The Brain)
0F31           1838   ; ================================================================
0F31           1839   Power_Control:
0F31           1840       ; Default: Turn Heat OFF (Safety)
0F31 755C00    1841       mov power_output+0, #0
0F34 755D00    1842       mov power_output+1, #0
0F37 755E00    1843       mov power_output+2, #0
0F3A 755F00    1844       mov power_output+3, #0
0F3D           1845   
0F3D E568      1846       mov a, Control_FSM_state
0F3F           1847   
0F3F           1848       ; --- State 2: RAMP TO SOAK ---
0F3F B40202    1849       cjne a, #2, PC_Check_Soak
0F42           1850       ; Mode: Full Speed Ahead
0F42 8016      1851       sjmp Set_Max_Power
0F44           1852   
0F44           1853   PC_Check_Soak:
0F44           1854       ; --- State 3: SOAK PHASE ---
0F44 B40305    1855       cjne a, #3, PC_Check_Ramp_Reflow
0F47           1856       ; Mode: Maintenance (Low Power)
0F47           1857       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
0F47 20030F    1858       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
0F4A 801B      1859       sjmp Set_20_Percent_Power     ; If cold, use 20%
0F4C           1860   
0F4C           1861   PC_Check_Ramp_Reflow:
0F4C           1862       ; --- State 4: RAMP TO REFLOW ---
0F4C B40402    1863       cjne a, #4, PC_Check_Reflow
0F4F           1864       ; Mode: Full Speed Ahead
0F4F 8009      1865       sjmp Set_Max_Power
0F51           1866   
0F51           1867   PC_Check_Reflow:
0F51           1868       ; --- State 5: REFLOW PHASE ---
0F51 B40505    1869       cjne a, #5, PC_Done
0F54           1870       ; Mode: Maintenance (Low Power)
0F54 200402    1871       jb reflow_temp_reached, PC_Done
0F57 800E      1872       sjmp Set_20_Percent_Power
0F59           1873   
0F59           1874   PC_Done:
0F59 22        1875       ret
0F5A           1876   
0F5A           1877   ; --- Power Helpers ---
0F5A           1878   
0F5A           1879   Set_Max_Power:
0F5A           1880       ; Load 1500 (0x05DC) = 100% Duty Cycle
0F5A 755CDC    1881       mov power_output+0, #0xDC
0F5D 755D05    1882       mov power_output+1, #0x05
0F60 755E00    1883       mov power_output+2, #0
0F63 755F00    1884       mov power_output+3, #0
0F66 22        1885       ret
0F67           1886   
0F67           1887   Set_20_Percent_Power:
0F67           1888       ; Load 300 (0x012C) = 20% Duty Cycle
0F67 755C2C    1889       mov power_output+0, #0x2C
0F6A 755D01    1890       mov power_output+1, #0x01
0F6D 755E00    1891       mov power_output+2, #0
0F70 755F00    1892       mov power_output+3, #0
0F73 22        1893       ret
0F74           1894   
0F74           1895   EN
