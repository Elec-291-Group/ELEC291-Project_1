0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 020D43       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 02046E      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 0206B0      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   current_time_sec:     ds 1
0031             38   current_time_minute:  ds 1
0032             39   ; math32 buffer variables
0032             40   x:      ds  4
0036             41   y:      ds  4
003A             42   bcd:    ds  5
003F             43   
003F             44   ; -------- UART RX line buffer (polling) --------
003F             45   rx_idx:    ds 1
0040             46   rx_ready:  ds 1
0041             47   rx_buf:    ds 40    ; null-terminated command line
0069             48   
0069             49   
0069             50   current_temp: ds 4 ;
006D             51   soak_temp:    ds 4 ;
0071             52   reflow_temp:  ds 4 ;
0075             53   
0075             54   wait25_btn_cnt:    ds 1
0076             55   wait25_keypad_cnt: ds 1
0077             56   wait25_adc_cnt:    ds 1
0078             57   wait25_lcd_cnt:    ds 1
0079             58   wait25_count: ds 1  
007A             59   
007A             60   current_time: ds 4 ;
007E             61   soak_time:    ds 4 ;
0082             62   reflow_time:  ds 4 ;
0086             63   
0086             64   power_output:  ds 4 ;
008A             65   pwm_counter: ds 4 ; counter for pwm (0-1500)
008E             66   
008E             67   KEY1_DEB_timer: ds 1
008F             68   SEC_FSM_timer:  ds 1
0090             69   KEY1_DEB_state:    ds 1
0091             70   SEC_FSM_state:     ds 1
0092             71   Control_FSM_state: ds 1 
0093             72   
0093             73   Current_State:     ds 1
0094             74   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
0098             75   proportional_gain_var: ds 4 ; power gain calculated from the proportional block
009C             76   ;-- UI buffers I added (ayaan)
009C             77   Cursor_Idx: ds 1
009D             78   
009D             79   ; These hold the TEXT (ASCII) safely
009D             80   ; Digits Only + Null Terminator, got rid of C,:, and s 
009D             81   
009D             82   ; Buzzer state
009D             83   beep_count:  ds 1      ; remaining beeps
009E             84   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
009F             85   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
00A1             86   
00A1             87   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
00A2             88   
0080             89   iseg at 0x80
0080             90   Buf_Soak_Temp: ds 4   
0084             91   Buf_Soak_Time: ds 5   
0089             92   Buf_Refl_Temp: ds 4   
008D             93   Buf_Refl_Time: ds 5
0092             94   
0092             95   
0092             96   
0092             97   ; 46d bytes used
0092             98   
0092             99   ;-------------------------------------------------------------------------------
0092            100   ; bit operation setb, clr, jb, and jnb
0000            101   bseg
0000            102   remote_config_mode: dbit 1
0001            103   mf:     dbit 1 ; math32 sign
0002            104   one_second_flag: dbit 1
0003            105   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0004            106   
0004            107   soak_temp_reached: dbit 1
0005            108   reflow_temp_reached: dbit 1
0006            109   cooling_temp_reached: dbit 1
0007            110   
0007            111   soak_time_reached: dbit 1
0008            112   reflow_time_reached: dbit 1
0009            113   
0009            114   reset_signal: dbit 1
000A            115   stop_signal: dbit 1
000B            116   start_signal: dbit 1
000C            117   config_finish_signal: dbit 1
000D            118   
000D            119   state_change_signal: dbit 1
000E            120   
000E            121   Key1_flag: dbit 1
000F            122   
000F            123   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
0010            124   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0011            125   PB0_flag: dbit 1 ; start entire program
0012            126   PB1_flag: dbit 1 ; start soak
0013            127   PB2_flag: dbit 1 ; pause process
0014            128   
0014            129   ;buzzer beep
0014            130   one_ms_beep_flag: dbit 1
0015            131   
0015            132   ; BSEG (Bit Segment)
0015            133   wait25_active: dbit 1 ; 1 = We are currently waiting
0016            134   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0017            135   wait25_btn_active:    dbit 1
0018            136   wait25_btn_done:      dbit 1
0019            137   wait25_keypad_active: dbit 1
001A            138   wait25_keypad_done:   dbit 1
001B            139   wait25_adc_active:    dbit 1
001C            140   wait25_adc_done:      dbit 1
001D            141   wait25_lcd_active:    dbit 1
001E            142   wait25_lcd_done:      dbit 1
001F            143   
001F            144   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
0020            145   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0021            146   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0022            147   ; 11 bits used
0022            148   
0022            149   ;-------------------------------------------------------------------------------
0320            150   cseg
0320            151   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            152   BAUD           EQU 57600
0320            153   
0320            154   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            155   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            156   ; is always 12 unlike the N76E003 where is selectable.
0320            157   
0320            158   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            159   
0320            160   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            161   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            162   
0320            163   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            164   
0320            165   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            166   
0320            167   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            168   
0320            169   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            170   ; P0 is in connector JPIO.
0320            171   
0320            172   ;Added correct I/O definitions
0320            173   ;-- LCD Pins ---
0320            174   ELCD_RS equ P1.7
0320            175   ELCD_E  equ P1.1
0320            176   ELCD_D4 equ P0.7
0320            177   ELCD_D5 equ P0.5
0320            178   ELCD_D6 equ P0.3
0320            179   ELCD_D7 equ P0.1
0320            180   
0320            181   ; -- Buttons --
0320            182   BTN_SOAK_TEMP equ P0.0
0320            183   BTN_SOAK_TIME equ P0.2
0320            184   BTN_REFL_TEMP equ P0.4
0320            185   BTN_REFL_TIME equ P0.6
0320            186   
0320            187   ; --- KEYPAD ---
0320            188   ROW1 equ P1.2
0320            189   ROW2 equ P1.4
0320            190   ROW3 equ P1.6
0320            191   ROW4 equ P2.0
0320            192   COL1 equ P2.2
0320            193   COL2 equ P2.4
0320            194   COL3 equ P2.6
0320            195   COL4 equ P3.0
0320            196   
0320            197   SERVO_OUT      EQU p3.6 ; servo pin
0320            198   
0320            199   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            200   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            201   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            202   
0320            203   COLD_JUNCTION_TEMP equ 20
0320            204   MAX_POWER           EQU 1500 ; max oven power
0320            205   NO_POWER            EQU 0    ; no power
0320            206   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
0320            207   KP                          EQU 5 ; proportional gain
0320            208   
0320            209   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   210   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   211   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   212   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            213   
0350            214   ; --- UI STRINGS (REQUIRED FOR KEYPAD LOGIC), <- I can fix if duplicates
0350 53656C65   215   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   216   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   217   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   218   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   219   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            220   
03A5            221   ;                       1234567890123456
03A5 53657420   222   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   223   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   224   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   225   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   226   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            227   
03E5 54656D70   228   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            229   
03EC            230   ;                     1234567890123456
03EC 52616D70   231   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   232   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   233   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   234   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   235   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   236   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C            237   
044C 20202020   238   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
045D            239   
045D            240   ;-------------------------------------------------------------------------------
045D            241   ; Timers Setting:
045D            242   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
045D            243   ;   Timer 1: Serial port baud rate 57600 generator
045D            244   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
045D            245   ;-------------------------------------------------------------------------------
045D            246   ; Routine to initialize the ISR for Timer 0 ;
045D            247   Timer0_Init:
045D E589       248       mov a, TMOD
045F 54F0       249       anl a, #0xf0 ; Clear the bits for timer 0
0461 4401       250       orl a, #0x01 ; Configure timer 0 as 16-timer
0463 F589       251       mov TMOD, a
0465 758CFD     252       mov TH0, #high(TIMER0_RELOAD)
0468 758A5A     253       mov TL0, #low(TIMER0_RELOAD)
046B            254       ; Enable the timer and interrupts
046B D2A9       255       setb ET0  ; Enable timer 0 interrupt
046D            256       ; setb TR0  (no need to open at first)
046D 22         257       ret
046E            258   ; ISR for timer 0.  Set to execute every 1/4096Hz 
046E            259   ; to generate a 2048 Hz square wave at pin P1.5 
046E            260   Timer0_ISR:
046E            261       ;clr TF0  ; According to the data sheet this is done for us already.
046E 758CFD     262       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0471 758A5A     263       mov TL0, #low(TIMER0_RELOAD)
0474 B295       264       cpl SOUND_OUT ; Connect speaker to P1.5
0476 32         265       reti
0477            266   ; -----------------------------------------------------------------------------------------------;
0477            267   
0477            268   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0477            269   Initialize_Serial_Port:
0477            270       ; Configure serial port and baud rate
0477 C28E       271       clr TR1 ; Disable timer 1
0479 53890F     272       anl TMOD, #0x0f ; Mask the bits for timer 1
047C 438920     273       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047F 438780     274       orl PCON, #80H ; Set SMOD to 1
0482 758DFD     275       mov TH1, #low(TIMER_1_RELOAD)
0485 758BFD     276       mov TL1, #low(TIMER_1_RELOAD) 
0488 D28E       277       setb TR1 ; Enable timer 1
048A 759852     278       mov SCON, #52H
048D 22         279       ret
048E            280   
048E            281   ; uart sending functions
048E            282   putchar:
048E 109902     283       jbc TI, putchar_L1
0491 80FB       284       sjmp putchar
0493            285   putchar_L1:
0493 F599       286       mov SBUF,a
0495 22         287       ret
0496            288   
0496            289   SendString:
0496 E4         290       clr a
0497 93         291       movc a, @a+dptr
0498 6006       292       jz SendString_L1
049A 12048E     293       lcall putchar
049D A3         294       inc dptr
049E 80F6       295       sjmp SendString  
04A0            296   SendString_L1:
04A0 22         297       ret
04A1            298   
04A1            299   ;------------------------------------------------------------
04A1            300   ; getchar_nb (non-blocking)
04A1            301   ; OUT: C=1 if got byte, A=byte
04A1            302   ;      C=0 if none
04A1            303   ;------------------------------------------------------------
04A1            304   getchar_nb:
04A1 309806     305       jnb RI, rx_none
04A4 E599       306       mov A, SBUF
04A6 C298       307       clr RI
04A8 D3         308       setb C
04A9 22         309       ret
04AA            310   rx_none:
04AA C3         311       clr C
04AB 22         312       ret
04AC            313   ;------------------------------------------------------------
04AC            314   ; Serial_RX_Pump
04AC            315   ; Builds a null-terminated line in rx_buf.
04AC            316   ; Sets rx_ready=1 when a full line received.
04AC            317   ;------------------------------------------------------------
04AC            318   Serial_RX_Pump:
04AC E540       319       mov A, rx_ready
04AE 7031       320       jnz rxp_done          ; don't overwrite unprocessed line
04B0            321   
04B0            322   rxp_more:
04B0 1204A1     323       lcall getchar_nb
04B3 502C       324       jnc rxp_done          ; no new byte
04B5            325   
04B5            326       ; ignore CR
04B5 B40D02     327       cjne A, #0DH, rxp_not_cr
04B8 80F6       328       sjmp rxp_more
04BA            329   
04BA            330   rxp_not_cr:
04BA            331       ; if LF -> finish line
04BA B40A0F     332       cjne A, #0AH, rxp_store
04BD            333   
04BD            334       ; terminate string
04BD E53F       335       mov A, rx_idx
04BF 2441       336       add A, #rx_buf
04C1 F8         337       mov R0, A
04C2 7600       338       mov @R0, #0
04C4 754001     339       mov rx_ready, #1
04C7 753F00     340       mov rx_idx, #0
04CA 8015       341       sjmp rxp_done
04CC            342   
04CC            343   rxp_store:
04CC            344       ; store char if room (max 39 chars)
04CC E53F       345       mov A, rx_idx
04CE B42705     346       cjne A, #39, rxp_ok
04D1 753F00     347       mov rx_idx, #0        ; overflow: reset
04D4 800B       348       sjmp rxp_done
04D6            349   
04D6            350   rxp_ok:
04D6 E53F       351       mov A, rx_idx
04D8 2441       352       add A, #rx_buf
04DA F8         353       mov R0, A
04DB A6E0       354       mov @R0, ACC
04DD 053F       355       inc rx_idx
04DF 80CF       356       sjmp rxp_more
04E1            357   
04E1            358   rxp_done:
04E1 22         359       ret
04E2            360   ; copies 3 ASCII digits to buffer at R1, null terminates
04E2            361   ; R0 = src (first digit), R1 = dst
04E2            362   Copy3DigitsToBuf:
04E2 E6         363       mov A, @R0
04E3 F7         364       mov @R1, A
04E4 08         365       inc R0
04E5 09         366       inc R1
04E6 E6         367       mov A, @R0
04E7 F7         368       mov @R1, A
04E8 08         369       inc R0
04E9 09         370       inc R1
04EA E6         371       mov A, @R0
04EB F7         372       mov @R1, A
04EC 09         373       inc R1
04ED 7700       374       mov @R1, #0
04EF 22         375       ret
04F0            376   
04F0            377   ; copies 4 ASCII digits to buffer at R1, null terminates
04F0            378   Copy4DigitsToBuf:
04F0 E6         379       mov A, @R0
04F1 F7         380       mov @R1, A
04F2 08         381       inc R0
04F3 09         382       inc R1
04F4 E6         383       mov A, @R0
04F5 F7         384       mov @R1, A
04F6 08         385       inc R0
04F7 09         386       inc R1
04F8 E6         387       mov A, @R0
04F9 F7         388       mov @R1, A
04FA 08         389       inc R0
04FB 09         390       inc R1
04FC E6         391       mov A, @R0
04FD F7         392       mov @R1, A
04FE 09         393       inc R1
04FF 7700       394       mov @R1, #0
0501 22         395       ret
0502            396   
0502            397   ;------------------------------------------------------------
0502            398   ; Serial_Process_Line
0502            399   ; Handles: S:TTT, K:MMSS, R:TTT, L:MMSS, CFG:APPLY, RUN:0/1
0502            400   ;------------------------------------------------------------
0502            401   Serial_Process_Line:
0502 E540       402       mov A, rx_ready
0504 7003       403       jnz SPL_HAVE
0506 020622     404       ljmp spl_done
0509            405   SPL_HAVE:
0509 754000     406       mov rx_ready, #0
050C            407   
050C 7841       408       mov R0, #rx_buf
050E            409   
050E            410   ; ---------------- S:TTT ----------------
050E E6         411       mov A, @R0
050F B45302     412       cjne A, #'S', S_NOT
0512 8003       413       sjmp S_MATCH
0514            414   S_NOT:
0514 02052A     415       ljmp chk_K
0517            416   
0517            417   S_MATCH:
0517 08         418       inc R0
0518 E6         419       mov A, @R0
0519 B43A02     420       cjne A, #':', S_BAD
051C 8003       421       sjmp S_GO
051E            422   S_BAD:
051E 020622     423       ljmp spl_done
0521            424   S_GO:
0521 08         425       inc R0
0522 7980       426       mov R1, #Buf_Soak_Temp
0524 1204E2     427       lcall Copy3DigitsToBuf
0527 020622     428       ljmp spl_done
052A            429   
052A            430   ; ---------------- K:MMSS ----------------
052A            431   chk_K:
052A 7841       432       mov R0, #rx_buf
052C E6         433       mov A, @R0
052D B44B02     434       cjne A, #'K', K_NOT
0530 8003       435       sjmp K_MATCH
0532            436   K_NOT:
0532 020548     437       ljmp chk_R
0535            438   
0535            439   K_MATCH:
0535 08         440       inc R0
0536 E6         441       mov A, @R0
0537 B43A02     442       cjne A, #':', K_BAD
053A 8003       443       sjmp K_GO
053C            444   K_BAD:
053C 020622     445       ljmp spl_done
053F            446   K_GO:
053F 08         447       inc R0
0540 7984       448       mov R1, #Buf_Soak_Time
0542 1204F0     449       lcall Copy4DigitsToBuf
0545 020622     450       ljmp spl_done
0548            451   
0548            452   ; ---------------- R:TTT ----------------
0548            453   chk_R:
0548 7841       454       mov R0, #rx_buf
054A E6         455       mov A, @R0
054B B45202     456       cjne A, #'R', R_NOT
054E 8003       457       sjmp R_MATCH
0550            458   R_NOT:
0550 020566     459       ljmp chk_L
0553            460   
0553            461   R_MATCH:
0553 08         462       inc R0
0554 E6         463       mov A, @R0
0555 B43A02     464       cjne A, #':', R_BAD
0558 8003       465       sjmp R_GO
055A            466   R_BAD:
055A 020622     467       ljmp spl_done
055D            468   R_GO:
055D 08         469       inc R0
055E 7989       470       mov R1, #Buf_Refl_Temp
0560 1204E2     471       lcall Copy3DigitsToBuf
0563 020622     472       ljmp spl_done
0566            473   
0566            474   ; ---------------- L:MMSS ----------------
0566            475   chk_L:
0566 7841       476       mov R0, #rx_buf
0568 E6         477       mov A, @R0
0569 B44C02     478       cjne A, #'L', L_NOT
056C 8003       479       sjmp L_MATCH
056E            480   L_NOT:
056E 020584     481       ljmp chk_CFG
0571            482   
0571            483   L_MATCH:
0571 08         484       inc R0
0572 E6         485       mov A, @R0
0573 B43A02     486       cjne A, #':', L_BAD
0576 8003       487       sjmp L_GO
0578            488   L_BAD:
0578 020622     489       ljmp spl_done
057B            490   L_GO:
057B 08         491       inc R0
057C 798D       492       mov R1, #Buf_Refl_Time
057E 1204F0     493       lcall Copy4DigitsToBuf
0581 020622     494       ljmp spl_done
0584            495   
0584            496   ; ---------------- CFG:APPLY (loose) ----------------
0584            497   chk_CFG:
0584 7841       498       mov R0, #rx_buf
0586 E6         499       mov A, @R0
0587 B44302     500       cjne A, #'C', CFG_NOT
058A 8003       501       sjmp CFG_C
058C            502   CFG_NOT:
058C 0205C1     503       ljmp chk_RUN
058F            504   
058F            505   CFG_C:
058F 08         506       inc R0
0590 E6         507       mov A, @R0
0591 B44602     508       cjne A, #'F', CFG_BAD
0594 8003       509       sjmp CFG_F
0596            510   CFG_BAD:
0596 0205C1     511       ljmp chk_RUN
0599            512   
0599            513   CFG_F:
0599 08         514       inc R0
059A E6         515       mov A, @R0
059B B44702     516       cjne A, #'G', CFG_BAD2
059E 8003       517       sjmp CFG_G
05A0            518   CFG_BAD2:
05A0 0205C1     519       ljmp chk_RUN
05A3            520   
05A3            521   CFG_G:
05A3 08         522       inc R0
05A4 E6         523       mov A, @R0
05A5 B43A02     524       cjne A, #':', CFG_BAD3
05A8 8003       525       sjmp CFG_COLON
05AA            526   CFG_BAD3:
05AA 0205C1     527       ljmp chk_RUN
05AD            528   
05AD            529   CFG_COLON:
05AD 08         530       inc R0
05AE E6         531       mov A, @R0
05AF B44102     532       cjne A, #'A', CFG_BAD4
05B2 8003       533       sjmp CFG_APPLY
05B4            534   CFG_BAD4:
05B4 0205C1     535       ljmp chk_RUN
05B7            536   
05B7            537   CFG_APPLY:
05B7 120E65     538       lcall Update_FSM_Variables
05BA C200       539       clr  remote_config_mode
05BC D20D       540       setb state_change_signal   ; force LCD redraw
05BE            541       ; optional: lcall Update_Screen_Full  ; if you want parameter page redraw instantly
05BE 020622     542       ljmp spl_done
05C1            543   
05C1            544   
05C1            545   ; ---------------- RUN:0 / RUN:1 ----------------
05C1            546   chk_RUN:
05C1 7841       547       mov R0, #rx_buf
05C3 E6         548       mov A, @R0
05C4 B45202     549       cjne A, #'R', RUN_BAD
05C7 8003       550       sjmp RUN_R
05C9            551   RUN_BAD:
05C9 020622     552       ljmp spl_done
05CC            553   
05CC            554   RUN_R:
05CC 08         555       inc R0
05CD E6         556       mov A, @R0
05CE B45502     557       cjne A, #'U', RUN_BAD2
05D1 8003       558       sjmp RUN_U
05D3            559   RUN_BAD2:
05D3 020622     560       ljmp spl_done
05D6            561   
05D6            562   RUN_U:
05D6 08         563       inc R0
05D7 E6         564       mov A, @R0
05D8 B44E02     565       cjne A, #'N', RUN_BAD3
05DB 8003       566       sjmp RUN_N
05DD            567   RUN_BAD3:
05DD 020622     568       ljmp spl_done
05E0            569   
05E0            570   RUN_N:
05E0 08         571       inc R0
05E1 E6         572       mov A, @R0
05E2 B43A02     573       cjne A, #':', RUN_BAD4
05E5 8003       574       sjmp RUN_COLON
05E7            575   RUN_BAD4:
05E7 020622     576       ljmp spl_done
05EA            577   
05EA            578   RUN_COLON:
05EA 08         579       inc R0
05EB E6         580       mov A, @R0
05EC B43102     581       cjne A, #'1', RUN_NOT1
05EF 8003       582       sjmp RUN_1
05F1            583   RUN_NOT1:
05F1 02060B     584       ljmp run_zero
05F4            585   
05F4            586   RUN_1:
05F4 C200       587       clr  remote_config_mode
05F6 759200     588       mov Control_FSM_state, #0
05F9 759300     589       mov Current_State, #0
05FC 753000     590       mov current_time_sec, #0
05FF 753100     591       mov current_time_minute, #0
0602 D20D       592       setb state_change_signal
0604 D210       593       setb tc_startup_window
0606 C20F       594       clr  tc_missing_abort
0608 020622     595       ljmp spl_done
060B            596   
060B            597   
060B            598   run_zero:
060B B43002     599       cjne A, #'0', RUN_BAD5
060E 8003       600       sjmp RUN_0
0610            601   RUN_BAD5:
0610 020622     602       ljmp spl_done
0613            603   
0613            604   RUN_0:
0613 C293       605       clr PWM_OUT
0615 D20A       606       setb stop_signal
0617 759200     607       mov Control_FSM_state, #0
061A 759300     608       mov Current_State, #0
061D D20D       609       setb state_change_signal
061F 020622     610       ljmp spl_done
0622            611   
0622            612   spl_done:
0622 22         613       ret
0623            614   
0623            615   
0623            616   ;-------------------------------------------------------------------------------
0623            617   ; serial debugging
0623            618   ; send a four byte number via serial to laptop
0623            619   ; need to be used with python script
0623            620   ; content needed to be sent should be stored in the varaible x
0623            621   ;-------------------------------------------------------------------------------
0623            622   Send32:
0623            623       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
0623 74AA       624       mov A, #0AAH
0625 12048E     625       lcall putchar
0628 7455       626       mov A, #055H
062A 12048E     627       lcall putchar
062D            628   
062D E535       629       mov A, x+3
062F 12048E     630       lcall putchar
0632 E534       631       mov A, x+2
0634 12048E     632       lcall putchar
0637 E533       633       mov A, x+1
0639 12048E     634       lcall putchar
063C E532       635       mov A, x+0
063E 12048E     636       lcall putchar
0641            637   
0641 740A       638       mov A, #0AH
0643 12048E     639       lcall putchar
0646 22         640       ret
0647            641   ; -----------------------------------------------------------------------------------------------;
0647            642   
0647            643   ;-------------------------------------------------------------------------------
0647            644   ; Serial temperature line for PuTTY/screen
0647            645   ; Outputs: "Temp: XXXC\r\n"
0647            646   ;-------------------------------------------------------------------------------
0647            647   Serial_Send_Temp_Line:
0647 9003E5     648       mov dptr, #String_temp_line
064A 120496     649       lcall SendString
064D            650   
064D            651       ; Convert current_temp to BCD (same as LCD)
064D 856932     652       mov x, current_temp
0650 856A33     653       mov x+1, current_temp+1
0653 856B34     654       mov x+2, current_temp+2
0656 856C35     655       mov x+3, current_temp+3
0659 12002E     656       lcall hex2bcd
065C            657   
065C 7F00       658       mov R7, #0          ; printed_flag = 0
065E            659   
065E            660       ; Print Hundreds (if non-zero)
065E E53B       661       mov a, bcd+1
0660 540F       662       anl a, #0x0F
0662 6007       663       jz Serial_Skip_Hundreds
0664 2430       664       add a, #0x30
0666 12048E     665       lcall putchar
0669 7F01       666       mov R7, #1
066B            667   Serial_Skip_Hundreds:
066B            668   
066B            669       ; Print Tens (if non-zero or if hundreds already printed)
066B E53A       670       mov a, bcd+0
066D C4         671       swap a
066E 540F       672       anl a, #0x0F
0670 7003       673       jnz Serial_Print_Tens
0672 EF         674       mov a, R7
0673 600C       675       jz Serial_Skip_Tens
0675            676   Serial_Print_Tens:
0675 E53A       677       mov a, bcd+0
0677 C4         678       swap a
0678 540F       679       anl a, #0x0F
067A 2430       680       add a, #0x30
067C 12048E     681       lcall putchar
067F 7F01       682       mov R7, #1
0681            683   Serial_Skip_Tens:
0681            684   
0681            685       ; Print Ones (always)
0681 E53A       686       mov a, bcd+0
0683 540F       687       anl a, #0x0F
0685 2430       688       add a, #0x30
0687 12048E     689       lcall putchar
068A            690   
068A            691       ; Print 'C' and newline
068A 7443       692       mov a, #'C'
068C 12048E     693       lcall putchar
068F 740D       694       mov a, #0DH     ; CR
0691 12048E     695       lcall putchar
0694 740A       696       mov a, #0AH     ; LF
0696 12048E     697       lcall putchar
0699 22         698       ret
069A            699   
069A            700   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
069A              1   ;-------------------------------------------------------------------------------
069A              2   ; Timer2_ISR.inc
069A              3   ; Contains Initialization and ISR for the 1ms System Timer
069A              4   ;-------------------------------------------------------------------------------
069A              5   
069A              6   ;-------------------------------------------------------------------------------
069A              7   ; Routine to initialize the ISR for timer 2
069A              8   ;-------------------------------------------------------------------------------
069A              9   Timer2_Init:
069A 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
069D 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
06A0 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
06A3             13       ; Set the reload value
06A3 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
06A6 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
06A9             16       
06A9 C2CF        17       clr TF2       ; Clear flag just in case
06AB             18       ; Enable the timer and interrupts
06AB D2AD        19       setb ET2      ; Enable timer 2 interrupt
06AD D2CA        20       setb TR2      ; Enable timer 2
06AF 22          21       ret
06B0             22   
06B0             23   ;-------------------------------------------------------------------------------
06B0             24   ; ISR for timer 2.  Runs every 1 ms
06B0             25   ;-------------------------------------------------------------------------------
06B0             26   Timer2_ISR:
06B0 C0E0        27       push acc
06B2 C0D0        28       push psw
06B4             29       
06B4 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
06B6             31   
06B6             32       ; --- 1. Existing FSM Timers ---
06B6 058E        33       inc KEY1_DEB_timer
06B8 058F        34       inc SEC_FSM_timer
06BA D203        35       setb one_ms_pwm_flag 
06BC D214        36       setb one_ms_beep_flag
06BE D21F        37       setb one_millisecond_flag_servo
06C0             38   
06C0             39       ; --- 2. NEW: Non-Blocking Delay Counters ---
06C0             40       
06C0             41       ; A. BUTTON DELAY
06C0 30170B      42       jnb wait25_btn_active, T2_Check_Keypad
06C3 0575        43       inc wait25_btn_cnt
06C5 E575        44       mov a, wait25_btn_cnt
06C7 B41904      45       cjne a, #25, T2_Check_Keypad
06CA D218        46       setb wait25_btn_done
06CC C217        47       clr wait25_btn_active
06CE             48       
06CE             49       ; B. KEYPAD DELAY
06CE             50   T2_Check_Keypad:
06CE 30190B      51       jnb wait25_keypad_active, T2_Check_ADC
06D1 0576        52       inc wait25_keypad_cnt
06D3 E576        53       mov a, wait25_keypad_cnt
06D5 B41904      54       cjne a, #25, T2_Check_ADC
06D8 D21A        55       setb wait25_keypad_done
06DA C219        56       clr wait25_keypad_active
06DC             57   
06DC             58       ; C. ADC DELAY (Thermocouple)
06DC             59   T2_Check_ADC:
06DC 301B0B      60       jnb wait25_adc_active, T2_Check_LCD
06DF 0577        61       inc wait25_adc_cnt
06E1 E577        62       mov a, wait25_adc_cnt
06E3 B41904      63       cjne a, #25, T2_Check_LCD
06E6 D21C        64       setb wait25_adc_done
06E8 C21B        65       clr wait25_adc_active
06EA             66   
06EA             67       ; D. LCD DELAY
06EA             68   T2_Check_LCD:
06EA 301D0B      69       jnb wait25_lcd_active, T2_Check_Generic
06ED 0578        70       inc wait25_lcd_cnt
06EF E578        71       mov a, wait25_lcd_cnt
06F1 B41904      72       cjne a, #25, T2_Check_Generic
06F4 D21E        73       setb wait25_lcd_done
06F6 C21D        74       clr wait25_lcd_active
06F8             75   
06F8             76       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
06F8             77   T2_Check_Generic:
06F8 30150B      78       jnb wait25_active, Timer2_ISR_done
06FB 0579        79       inc wait25_count
06FD E579        80       mov a, wait25_count
06FF B41904      81       cjne a, #25, Timer2_ISR_done
0702 D216        82       setb wait25_done      ; Tells Wait_25ms that we are finished
0704 C215        83       clr wait25_active     ; Stop counting
0706             84   
0706             85   Timer2_ISR_done:
0706 D0D0        86       pop psw
0708 D0E0        87       pop acc
070A 32          88       reti
070B             89            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
070B              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
070B              2   cseg
070B              3   
070B              4   ; When using a 33.333333MHz crystal clock
070B              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
070B              6   
070B              7   ;---------------------------------;
070B              8   ; Wait 40 microseconds            ;
070B              9   ;---------------------------------;
070B             10   Wait40uSec:
070B C000        11            push AR0
070D 78BE        12            mov R0, #190
070F             13   L0: 
070F 00          14            nop
0710 00          15            nop
0711 00          16            nop
0712 00          17            nop
0713 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0715 D000        19            pop AR0
0717 22          20       ret
0718             21   
0718             22   ;---------------------------------;
0718             23   ; Wait 'R2' milliseconds          ;
0718             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
0718             31   
0718             32   ?Wait_Milli_Seconds:
0718 C000        33            push AR0
071A C001        34            push AR1
071C 7932        35   L3: mov R1, #50
071E 78DF        36   L2: mov R0, #223
0720 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
0722 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
0724 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
0726 D001        40       pop AR1
0728 D000        41       pop AR0
072A 22          42       ret
072B             43            
072B             44   ;---------------------------------;
072B             45   ; Toggles the 'E' pin in the LCD  ;
072B             46   ;---------------------------------;
072B             47   ELCD_pulse:
072B D291        48            setb ELCD_E
072D 12070B      49            lcall Wait40uSec
0730 C291        50            clr ELCD_E
0732 12070B      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
0735 22          52       ret
0736             53   
0736             54   ;---------------------------------;
0736             55   ; Writes acc to LCD in 4-bit mode ;
0736             56   ;---------------------------------;
0736             57   ELCD_byte:
0736             58            ; Write high 4 bits first
0736 A2E7        59            mov c, ACC.7
0738 9281        60            mov ELCD_D7, c
073A A2E6        61            mov c, ACC.6
073C 9283        62            mov ELCD_D6, c
073E A2E5        63            mov c, ACC.5
0740 9285        64            mov ELCD_D5, c
0742 A2E4        65            mov c, ACC.4
0744 9287        66            mov ELCD_D4, c
0746 12072B      67       lcall ELCD_pulse
0749             68            ; Write low 4 bits next
0749 A2E3        69            mov c, ACC.3
074B 9281        70            mov ELCD_D7, c
074D A2E2        71            mov c, ACC.2
074F 9283        72            mov ELCD_D6, c
0751 A2E1        73            mov c, ACC.1
0753 9285        74            mov ELCD_D5, c
0755 A2E0        75            mov c, ACC.0
0757 9287        76            mov ELCD_D4, c
0759 12072B      77       lcall ELCD_pulse
075C 22          78            ret
075D             79   
075D             80   ;---------------------------------;
075D             81   ; Write data to LCD               ;
075D             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
075D             87            
075D             88   ?WriteData:
075D D297        89            setb ELCD_RS
075F 020736      90            ljmp ELCD_byte
0762             91   
0762             92   ;---------------------------------;
0762             93   ; Write command to LCD            ;
0762             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
0762             99   
0762            100   ?WriteCommand:
0762 C297       101            clr ELCD_RS
0764 020736     102            ljmp ELCD_byte
0767            103   
0767            104   ;---------------------------------;
0767            105   ; Configure LCD in 4-bit mode     ;
0767            106   ;---------------------------------;
0767            107   ELCD_4BIT:
0767 C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
0769            109            ;clr ELCD_RW  ; RW forced to zero
0769            110            
0769            111            ; After power on, let the LCD start up before initializing
0769 C002       112            push AR2
076B 7A28       112            mov R2, #40
076D 120718     112            lcall ?Wait_Milli_Seconds
0770 D002       112            pop AR2
0772            113            
0772            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
0772 7433       115            mov a, #0x33
0774 120762     115            lcall ?WriteCommand
0777 7433       116            mov a, #0x33
0779 120762     116            lcall ?WriteCommand
077C 7432       117            mov a, #0x32
077E 120762     117            lcall ?WriteCommand ; change to 4-bit mode
0781            118   
0781            119            ; Configure the LCD
0781 7428       120            mov a, #0x28
0783 120762     120            lcall ?WriteCommand
0786 740C       121            mov a, #0x0c
0788 120762     121            lcall ?WriteCommand
078B 7401       122            mov a, #0x01
078D 120762     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
0790            123   
0790            124       ;Wait for the clear screen command to finish.
0790 C002       125            push AR2
0792 7A02       125            mov R2, #2
0794 120718     125            lcall ?Wait_Milli_Seconds
0797 D002       125            pop AR2
0799 22         126       ret
079A            127   
079A            128   ;---------------------------------;
079A            129   ; Send a constant string to LCD   ;
079A            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
079A            141   
079A            142   ?Send_Constant_String:
079A E4         143       clr a
079B 93         144       movc a, @a+dptr
079C 6006       145       jz ?Send_Constant_String_Done
079E 12075D     146       lcall ?WriteData
07A1 A3         147       inc dptr
07A2 80F6       148       sjmp ?Send_Constant_String
07A4            149   ?Send_Constant_String_Done:
07A4 22         150       ret  
07A5            151   
07A5            152   ;---------------------------------;
07A5            153   ; Set LCD cursor at row, column   ;
07A5            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
07A5            162   
07A5            163   ?Set_Cursor_2:
07A5 4440       164            orl a, #01000000B
07A7            165   ?Set_Cursor_1:
07A7 4480       166            orl a, #10000000B
07A9 020762     167            ljmp ?WriteCommand ; Select column and row
07AC            168   
07AC            169   ;---------------------------------;
07AC            170   ; Display a BCD number in the LCD ;
07AC            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
07AC            178   
07AC            179   ?Display_BCD:
07AC C0E0       180            push acc
07AE            181            ; Write most significant digit
07AE E8         182            mov a, r0
07AF C4         183            swap a
07B0 540F       184            anl a, #0fh
07B2 4430       185            orl a, #30h
07B4 12075D     186            lcall ?WriteData
07B7            187            ; write least significant digit
07B7 E8         188            mov a, r0
07B8 540F       189            anl a, #0fh
07BA 4430       190            orl a, #30h
07BC 12075D     191            lcall ?WriteData
07BF D0E0       192            pop acc
07C1 22         193            ret
07C2            194   
07C2            195   ;------------------------------------;
07C2            196   ; Display a char in the LCD          ;
07C2            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
07C2            204   
07C2            703            ;-----------------------------------------------------------------------------------------------;
07C2            704   
07C2            705   ;-------------------------------------------------------------------------------
07C2            706   ; Display Function for 7-segment displays       
07C2            707   ;-------------------------------------------------------------------------------
07C2            708   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
07C2            709   T_7seg:
07C2 C0F9A4B0   710       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
07C7 9282F880   711       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
07CC 8883C6A1   712       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
07D2            713   
07D2            714   ; Displays a BCD number pased in R0 in HEX5-HEX0
07D2            715   Display_BCD_7_Seg_HEX10:
07D2 9007C2     716       mov dptr, #T_7seg
07D5 E8         717       mov a, R0
07D6 C4         718       swap a
07D7 540F       719       anl a, #0FH
07D9 93         720       movc a, @a+dptr
07DA F592       721       mov HEX1, a
07DC E8         722       mov a, R0
07DD 540F       723       anl a, #0FH
07DF 93         724       movc a, @a+dptr
07E0 F591       725       mov HEX0, a
07E2 22         726       ret
07E3            727   
07E3            728   Display_BCD_7_Seg_HEX32:
07E3 9007C2     729       mov dptr, #T_7seg
07E6 E8         730       mov a, R0
07E7 C4         731       swap a
07E8 540F       732       anl a, #0FH
07EA 93         733       movc a, @a+dptr
07EB F594       734       mov HEX3, a
07ED E8         735       mov a, R0
07EE 540F       736       anl a, #0FH
07F0 93         737       movc a, @a+dptr
07F1 F593       738       mov HEX2, a
07F3 22         739       ret
07F4            740   
07F4            741   Display_BCD_7_Seg_HEX54:
07F4 9007C2     742       mov dptr, #T_7seg
07F7 E8         743       mov a, R0
07F8 C4         744       swap a
07F9 540F       745       anl a, #0FH
07FB 93         746       movc a, @a+dptr
07FC F58F       747       mov HEX5, a
07FE E8         748       mov a, R0
07FF 540F       749       anl a, #0FH
0801 93         750       movc a, @a+dptr
0802 F58E       751       mov HEX4, a
0804 22         752       ret
0805            753   
0805            754   ; The 8-bit hex number passed in the accumulator is converted to
0805            755   ; BCD and stored in [R1, R0]
0805            756   Hex_to_bcd_8bit:
0805 75F064     757       mov b, #100
0808 84         758       div ab
0809 F9         759       mov R1, a   ; After dividing, a has the 100s
080A E5F0       760       mov a, b    ; Remainder is in register b
080C 75F00A     761       mov b, #10
080F 84         762       div ab ; The tens are stored in a, the units are stored in b 
0810 C4         763       swap a
0811 54F0       764       anl a, #0xf0
0813 45F0       765       orl a, b
0815 F8         766       mov R0, a
0816 22         767       ret
0817            768   ;-------------------------------------------------------------------------------
0817            769   ; Display Function for LCD                      
0817            770   ;-------------------------------------------------------------------------------
0817            771   LCD_Print_2Digits:
0817 120805     772       lcall Hex_to_bcd_8bit
081A E8         773       mov a, R0
081B C4         774       swap a
081C 540F       775       anl a, #0x0F
081E 2430       776       add a, #0x30
0820 12075D     777       lcall ?WriteData
0823 E8         778       mov a, R0
0824 540F       779       anl a, #0x0F
0826 2430       780       add a, #0x30
0828 12075D     781       lcall ?WriteData
082B 22         782       ret
082C            783   
082C            784   LCD_Display_Update_func:
082C C0E0       785       push acc
082E            786       
082E            787       ; ==========================================
082E            788       ; PART 1: STATIC TEXT (Title)
082E            789       ; Runs ONLY when the state changes
082E            790       ; ==========================================
082E            791       
082E            792       ; [FIX] "Trampoline" logic for long distance jump
082E            793       ; If signal is SET (1), we stay here and update.
082E            794       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
082E 200D03     795       jb state_change_signal, Do_Static_Update
0831 02096A     796       ljmp Check_Live_Update
0834            797   
0834            798   Do_Static_Update:
0834 C20D       799       clr state_change_signal
0836            800       
0836            801       ; State Changed: Clear Screen and Write Title
0836 1211A1     802       lcall Clear_Screen_Func
0839 E592       803       mov a, Control_FSM_state
083B            804       
083B            805       ; State 0: Welcome
083B B4003B     806       cjne a, #0, LCD_Check_1
083E C0E0       807            push acc
0840 7401       807            mov a, #1
0842 14         807            dec a
0843 1207A7     807            lcall ?Set_Cursor_1 ; Select column and row
0846 D0E0       807            pop acc
0848 C083       808            push dph
084A C082       808            push dpl
084C C0E0       808            push acc
084E 900330     808            mov dptr, #String_state0_1
0851 12079A     808            lcall ?Send_Constant_String
0854 D0E0       808            pop acc
0856 D082       808            pop dpl
0858 D083       808            pop dph
085A C0E0       809            push acc
085C 7401       809            mov a, #1
085E 14         809            dec a
085F 1207A5     809            lcall ?Set_Cursor_2 ; Select column and row
0862 D0E0       809            pop acc
0864 C083       810            push dph
0866 C082       810            push dpl
0868 C0E0       810            push acc
086A 900340     810            mov dptr, #String_state0_2
086D 12079A     810            lcall ?Send_Constant_String
0870 D0E0       810            pop acc
0872 D082       810            pop dpl
0874 D083       810            pop dph
0876 020967     811       ljmp LCD_Done_Bridge ; Exit
0879            812   
0879            813   LCD_Check_1: ; Setup
0879 B4011F     814       cjne a, #1, LCD_Check_2
087C C0E0       815            push acc
087E 7401       815            mov a, #1
0880 14         815            dec a
0881 1207A7     815            lcall ?Set_Cursor_1 ; Select column and row
0884 D0E0       815            pop acc
0886 C083       816            push dph
0888 C082       816            push dpl
088A C0E0       816            push acc
088C 9003A5     816            mov dptr, #String_state1
088F 12079A     816            lcall ?Send_Constant_String
0892 D0E0       816            pop acc
0894 D082       816            pop dpl
0896 D083       816            pop dph
0898 020967     817       ljmp LCD_Done_Bridge
089B            818   
089B            819   LCD_Check_2: ; Ramp to Soak
089B B4021F     820       cjne a, #2, LCD_Check_3
089E C0E0       821            push acc
08A0 7401       821            mov a, #1
08A2 14         821            dec a
08A3 1207A7     821            lcall ?Set_Cursor_1 ; Select column and row
08A6 D0E0       821            pop acc
08A8 C083       822            push dph
08AA C082       822            push dpl
08AC C0E0       822            push acc
08AE 9003EC     822            mov dptr, #String_state2
08B1 12079A     822            lcall ?Send_Constant_String
08B4 D0E0       822            pop acc
08B6 D082       822            pop dpl
08B8 D083       822            pop dph
08BA 02098A     823       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
08BD            824   
08BD            825   LCD_Check_3: ; Soak
08BD B4031F     826       cjne a, #3, LCD_Check_4
08C0 C0E0       827            push acc
08C2 7401       827            mov a, #1
08C4 14         827            dec a
08C5 1207A7     827            lcall ?Set_Cursor_1 ; Select column and row
08C8 D0E0       827            pop acc
08CA C083       828            push dph
08CC C082       828            push dpl
08CE C0E0       828            push acc
08D0 9003FC     828            mov dptr, #String_state3
08D3 12079A     828            lcall ?Send_Constant_String
08D6 D0E0       828            pop acc
08D8 D082       828            pop dpl
08DA D083       828            pop dph
08DC 02098A     829       ljmp LCD_Update_Temp_Value
08DF            830   
08DF            831   LCD_Check_4: ; Ramp to Peak
08DF B4041F     832       cjne a, #4, LCD_Check_5
08E2 C0E0       833            push acc
08E4 7401       833            mov a, #1
08E6 14         833            dec a
08E7 1207A7     833            lcall ?Set_Cursor_1 ; Select column and row
08EA D0E0       833            pop acc
08EC C083       834            push dph
08EE C082       834            push dpl
08F0 C0E0       834            push acc
08F2 90040C     834            mov dptr, #String_state4
08F5 12079A     834            lcall ?Send_Constant_String
08F8 D0E0       834            pop acc
08FA D082       834            pop dpl
08FC D083       834            pop dph
08FE 02098A     835       ljmp LCD_Update_Temp_Value
0901            836   
0901            837   LCD_Check_5: ; Reflow
0901 B4051F     838       cjne a, #5, LCD_Check_6
0904 C0E0       839            push acc
0906 7401       839            mov a, #1
0908 14         839            dec a
0909 1207A7     839            lcall ?Set_Cursor_1 ; Select column and row
090C D0E0       839            pop acc
090E C083       840            push dph
0910 C082       840            push dpl
0912 C0E0       840            push acc
0914 90041C     840            mov dptr, #String_state5
0917 12079A     840            lcall ?Send_Constant_String
091A D0E0       840            pop acc
091C D082       840            pop dpl
091E D083       840            pop dph
0920 02098A     841       ljmp LCD_Update_Temp_Value
0923            842   
0923            843   LCD_Check_6: ; Cooling
0923 B4061F     844       cjne a, #6, LCD_Check_7
0926 C0E0       845            push acc
0928 7401       845            mov a, #1
092A 14         845            dec a
092B 1207A7     845            lcall ?Set_Cursor_1 ; Select column and row
092E D0E0       845            pop acc
0930 C083       846            push dph
0932 C082       846            push dpl
0934 C0E0       846            push acc
0936 90042C     846            mov dptr, #String_state6
0939 12079A     846            lcall ?Send_Constant_String
093C D0E0       846            pop acc
093E D082       846            pop dpl
0940 D083       846            pop dph
0942 02098A     847       ljmp LCD_Update_Temp_Value
0945            848   
0945            849   LCD_Check_7: ; Done
0945            850       ; [FIX] Check distance safe logic for State 7
0945 B4071F     851       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
0948 C0E0       852            push acc
094A 7401       852            mov a, #1
094C 14         852            dec a
094D 1207A7     852            lcall ?Set_Cursor_1 ; Select column and row
0950 D0E0       852            pop acc
0952 C083       853            push dph
0954 C082       853            push dpl
0956 C0E0       853            push acc
0958 90043C     853            mov dptr, #String_state7
095B 12079A     853            lcall ?Send_Constant_String
095E D0E0       853            pop acc
0960 D082       853            pop dpl
0962 D083       853            pop dph
0964 020967     854       ljmp LCD_Done_Bridge
0967            855   
0967            856   ; Local bridge to reach the far-away LCD_Done
0967            857   LCD_Done_Bridge:
0967 0209EB     858       ljmp LCD_Done
096A            859   
096A            860   ; ==========================================
096A            861   ; PART 2: DYNAMIC VALUES (Temperature)
096A            862   ; Runs every time 'one_second_flag' is set
096A            863   ; ==========================================
096A            864   Check_Live_Update:
096A 3002FA     865       jnb one_second_flag, LCD_Done_Bridge
096D C202       866       clr one_second_flag
096F            867       
096F            868       ; Only update temp for States 2, 3, 4, 5, 6
096F E592       869       mov a, Control_FSM_state
0971 B40202     870       cjne a, #2, Check_St3
0974 8014       871       sjmp LCD_Update_Temp_Value
0976            872   Check_St3:
0976 B40302     873       cjne a, #3, Check_St4
0979 800F       874       sjmp LCD_Update_Temp_Value
097B            875   Check_St4:
097B B40402     876       cjne a, #4, Check_St5
097E 800A       877       sjmp LCD_Update_Temp_Value
0980            878   Check_St5:
0980 B40502     879       cjne a, #5, Check_St6
0983 8005       880       sjmp LCD_Update_Temp_Value
0985            881   Check_St6:
0985 B40663     882       cjne a, #6, LCD_Done
0988 8000       883       sjmp LCD_Update_Temp_Value
098A            884   
098A            885   ; --- HELPER: Prints "XXX C" on Line 2 ---
098A            886   LCD_Update_Temp_Value:
098A C0E0       887            push acc
098C 7401       887            mov a, #1
098E 14         887            dec a
098F 1207A5     887            lcall ?Set_Cursor_2 ; Select column and row
0992 D0E0       887            pop acc
0994            888       
0994            889       ; Convert current_temp to BCD
0994 856932     890       mov x, current_temp
0997 856A33     891       mov x+1, current_temp+1
099A 856B34     892       mov x+2, current_temp+2
099D 856C35     893       mov x+3, current_temp+3
09A0 12002E     894       lcall hex2bcd
09A3            895   
09A3            896       ; Update HEX2-HEX0 with temperature
09A3 1209EE     897       lcall Update_HEX_Temp
09A6            898       
09A6            899       ; Print Hundreds
09A6 E53B       900       mov a, bcd+1
09A8 540F       901       anl a, #0x0F
09AA 2430       902       add a, #0x30
09AC 12075D     903       lcall ?WriteData
09AF            904       
09AF            905       ; Print Tens
09AF E53A       906       mov a, bcd+0
09B1 C4         907       swap a
09B2 540F       908       anl a, #0x0F
09B4 2430       909       add a, #0x30
09B6 12075D     910       lcall ?WriteData
09B9            911       
09B9            912       ; Print Ones
09B9 E53A       913       mov a, bcd+0
09BB 540F       914       anl a, #0x0F
09BD 2430       915       add a, #0x30
09BF 12075D     916       lcall ?WriteData
09C2            917       
09C2            918       ; Print 'C'
09C2 7443       919       mov a, #'C'
09C4 12075D     920       lcall ?WriteData
09C7            921       
09C7            922       ; Clear remaining line space (prevents garbage)
09C7 7420       923       mov a, #' '
09C9 12075D     924       lcall ?WriteData
09CC 12075D     925       lcall ?WriteData
09CF            926   
09CF            927       ; Print time MM:SS at bottom right
09CF C0E0       928            push acc
09D1 740C       928            mov a, #12
09D3 14         928            dec a
09D4 1207A5     928            lcall ?Set_Cursor_2 ; Select column and row
09D7 D0E0       928            pop acc
09D9 E531       929       mov a, current_time_minute
09DB 120817     930       lcall LCD_Print_2Digits
09DE 743A       931       mov a, #':'
09E0 12075D     932       lcall ?WriteData
09E3 E530       933       mov a, current_time_sec
09E5 120817     934       lcall LCD_Print_2Digits
09E8            935   
09E8            936       ; Mirror temp to serial (PuTTY/screen)
09E8 120647     937       lcall Serial_Send_Temp_Line
09EB            938   
09EB            939   LCD_Done:
09EB D0E0       940       pop acc
09ED 22         941       ret
09EE            942   ;---------------------------------------------------------
09EE            943   
09EE            944   ;-------------------------------------------------------------------------------
09EE            945   ; Update HEX2-HEX0 with temperature (3 digits)
09EE            946   ;-------------------------------------------------------------------------------
09EE            947   Update_HEX_Temp:
09EE 9007C2     948       mov dptr, #T_7seg
09F1            949       ; Hundreds -> HEX2
09F1 E53B       950       mov a, bcd+1
09F3 540F       951       anl a, #0x0F
09F5 93         952       movc a, @a+dptr
09F6 F593       953       mov HEX2, a
09F8            954       ; Tens -> HEX1
09F8 E53A       955       mov a, bcd+0
09FA C4         956       swap a
09FB 540F       957       anl a, #0x0F
09FD 93         958       movc a, @a+dptr
09FE F592       959       mov HEX1, a
0A00            960       ; Ones -> HEX0
0A00 E53A       961       mov a, bcd+0
0A02 540F       962       anl a, #0x0F
0A04 93         963       movc a, @a+dptr
0A05 F591       964       mov HEX0, a
0A07 22         965       ret
0A08            966   
0A08            967   KEY1_DEB:
0A08            968   ;non-blocking state machine for KEY1 debounce
0A08 E590       969       mov a, KEY1_DEB_state
0A0A            970   KEY1_DEB_state0:
0A0A B4000A     971       cjne a, #0, KEY1_DEB_state1
0A0D 20F92D     972       jb KEY.1, KEY1_DEB_done
0A10 758E00     973       mov KEY1_DEB_timer, #0
0A13 0590       974       inc KEY1_DEB_state
0A15 8026       975       sjmp KEY1_DEB_done
0A17            976   KEY1_DEB_state1:
0A17 B40109     977       cjne a, #1, KEY1_DEB_state2
0A1A            978       ; this is the debounce state
0A1A E58E       979       mov a, KEY1_DEB_timer
0A1C B4321E     980       cjne a, #50, KEY1_DEB_done ; 50 ms passed?
0A1F 0590       981       inc KEY1_DEB_state
0A21 801A       982       sjmp KEY1_DEB_done  
0A23            983   KEY1_DEB_state2:
0A23 B4020C     984       cjne a, #2, KEY1_DEB_state3
0A26 20F904     985       jb KEY.1, KEY1_DEB_state2b
0A29 0590       986       inc KEY1_DEB_state
0A2B 8010       987       sjmp KEY1_DEB_done  
0A2D            988   KEY1_DEB_state2b:
0A2D 759000     989       mov KEY1_DEB_state, #0
0A30 800B       990       sjmp KEY1_DEB_done
0A32            991   KEY1_DEB_state3:
0A32 B40308     992       cjne a, #3, KEY1_DEB_done
0A35 30F905     993       jnb KEY.1, KEY1_DEB_done
0A38 D20E       994       setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
0A3A 759000     995       mov KEY1_DEB_state, #0  
0A3D            996   KEY1_DEB_done:
0A3D 22         997       ret
0A3E            998   ; ------------------------------------------------------------------------------
0A3E            999   ; Non-blocking FSM for the one second counter
0A3E           1000   ;-------------------------------------------------------------------------------
0A3E           1001   SEC_FSM:
0A3E E591      1002       mov a, SEC_FSM_state
0A40           1003   SEC_FSM_state0:
0A40 B4000C    1004       cjne a, #0, SEC_FSM_state1
0A43 E58F      1005       mov a, SEC_FSM_timer
0A45 B4FA4B    1006       cjne a, #250, SEC_FSM_done ; 250 ms passed?
0A48 758F00    1007       mov SEC_FSM_timer, #0
0A4B 0591      1008       inc SEC_FSM_state
0A4D 8044      1009       sjmp SEC_FSM_done
0A4F           1010   SEC_FSM_state1: 
0A4F B4010E    1011       cjne a, #1, SEC_FSM_state2
0A52 D2E9      1012       setb LEDRA.1
0A54 E58F      1013       mov a, SEC_FSM_timer
0A56 B4FA3A    1014       cjne a, #250, SEC_FSM_done ; 250 ms passed?
0A59 758F00    1015       mov SEC_FSM_timer, #0
0A5C 0591      1016       inc SEC_FSM_state
0A5E 8033      1017       sjmp SEC_FSM_done
0A60           1018   SEC_FSM_state2: 
0A60 B4020E    1019       cjne a, #2, SEC_FSM_state3
0A63 D2EA      1020       setb LEDRA.2
0A65 E58F      1021       mov a, SEC_FSM_timer
0A67 B4FA29    1022       cjne a, #250, SEC_FSM_done ; 250 ms passed?
0A6A 758F00    1023       mov SEC_FSM_timer, #0
0A6D 0591      1024       inc SEC_FSM_state
0A6F 8022      1025       sjmp SEC_FSM_done
0A71           1026   SEC_FSM_state3: 
0A71 B4031F    1027       cjne a, #3, SEC_FSM_done
0A74 D2EB      1028       setb LEDRA.3
0A76 E58F      1029       mov a, SEC_FSM_timer
0A78 B4FA18    1030       cjne a, #250, SEC_FSM_done ; 250 ms passed?
0A7B 758F00    1031       mov SEC_FSM_timer, #0
0A7E 759100    1032       mov SEC_FSM_state, #0
0A81           1033       
0A81           1034       ; --- 1 Second has passed! ---
0A81 D202      1035       setb one_second_flag
0A83           1036       
0A83 E530      1037       mov a, current_time_sec
0A85 B43B07    1038       cjne a, #59, IncCurrentTimeSec 
0A88           1039       
0A88           1040       ; --- FIX: 59s -> 0s AND Increment Minute ---
0A88 753000    1041       mov current_time_sec, #0
0A8B 0531      1042       inc current_time_minute    ; <--- YOU WERE MISSING THIS!
0A8D           1043       ; -------------------------------------------
0A8D           1044       
0A8D 8004      1045       sjmp SEC_FSM_done
0A8F           1046   
0A8F           1047   IncCurrentTimeSec:
0A8F 0530      1048       inc current_time_sec
0A91 B2E8      1049       cpl LEDRA.0 
0A93           1050   SEC_FSM_done:
0A93 22        1051       ret
0A94           1052   ;-------------------------------------------------------------------------------
0A94           1053   ; PWM
0A94           1054   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0A94           1055   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0A94           1056   ; ------------------------------------------------------------------------------
0A94           1057   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0A94 100302    1058       jbc one_ms_pwm_flag, pwm_wave_generator
0A97 8071      1059       sjmp end_pwm_generator
0A99           1060   
0A99           1061   pwm_wave_generator:
0A99 C201      1062       clr mf
0A9B           1063       ; move pwm counter value into x for comparison purpose
0A9B 858A32    1064       mov x, pwm_counter
0A9E 858B33    1065       mov x+1, pwm_counter+1
0AA1 858C34    1066       mov x+2, pwm_counter+2
0AA4 858D35    1067       mov x+3, pwm_counter+3
0AA7           1068   
0AA7 7536DB    1069            mov y+0, #low (PWM_PERIOD % 0x10000) 
0AAA 753705    1069            mov y+1, #high(PWM_PERIOD % 0x10000) 
0AAD 753800    1069            mov y+2, #low (PWM_PERIOD / 0x10000) 
0AB0 753900    1069            mov y+3, #high(PWM_PERIOD / 0x10000) 
0AB3           1070   
0AB3           1071       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0AB3           1072       ; increase x by 1
0AB3 120152    1073       lcall x_eq_y 
0AB6 20011D    1074       jb mf, wrap_pwm_counter
0AB9           1075       ; x not equal 1499, increment by 1
0AB9 753601    1076            mov y+0, #low (1 % 0x10000) 
0ABC 753700    1076            mov y+1, #high(1 % 0x10000) 
0ABF 753800    1076            mov y+2, #low (1 / 0x10000) 
0AC2 753900    1076            mov y+3, #high(1 / 0x10000) 
0AC5 1200D3    1077       lcall add32
0AC8           1078       ; update pwm_counter
0AC8 85328A    1079       mov pwm_counter, x
0ACB 85338B    1080       mov pwm_counter+1, x+1
0ACE 85348C    1081       mov pwm_counter+2, x+2
0AD1 85358D    1082       mov pwm_counter+3, x+3
0AD4 8018      1083       sjmp set_pwm
0AD6           1084   
0AD6           1085   wrap_pwm_counter:
0AD6           1086       ; x equal 1499, wrap to 0
0AD6 753200    1087            mov x+0, #low (0 % 0x10000) 
0AD9 753300    1087            mov x+1, #high(0 % 0x10000) 
0ADC 753400    1087            mov x+2, #low (0 / 0x10000) 
0ADF 753500    1087            mov x+3, #high(0 / 0x10000) 
0AE2 85328A    1088       mov pwm_counter, x
0AE5 85338B    1089       mov pwm_counter+1, x+1
0AE8 85348C    1090       mov pwm_counter+2, x+2
0AEB 85358D    1091       mov pwm_counter+3, x+3
0AEE           1092   
0AEE           1093   set_pwm:
0AEE           1094       ; compare with power_output, if pwm counter smaller than power_output, 
0AEE           1095       ; set pwm pin high; else set pwm pin low load y with power output value
0AEE 858636    1096       mov y, power_output
0AF1 858737    1097       mov y+1, power_output+1
0AF4 858838    1098       mov y+2, power_output+2
0AF7 858939    1099       mov y+3, power_output+3
0AFA           1100   
0AFA           1101       ; compare x(pwm counter) with y(power output)
0AFA 12011A    1102       lcall x_lt_y
0AFD 200106    1103       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
0B00           1104       ;output set pwm pin low if pwm counter greater than power output
0B00 C293      1105       clr PWM_OUT
0B02 C2EC      1106       clr LEDRA.4
0B04 8004      1107       sjmp end_pwm_generator
0B06           1108   
0B06           1109   set_pwm_high:
0B06 D293      1110       setb PWM_OUT
0B08 D2EC      1111       setb LEDRA.4
0B0A           1112   
0B0A           1113   end_pwm_generator:
0B0A 22        1114       ret
0B0B           1115   
0B0B           1116   ;-------------------------------------------------------------------------------;
0B0B           1117   ; Temp_Compare
0B0B           1118   ; Checks if we have reached the user's target temperatures.
0B0B           1119   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
0B0B           1120   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0B0B           1121   ;-------------------------------------------------------------------------------;
0B0B           1122   Temp_Compare:
0B0B           1123       ; Reset flags initially
0B0B C204      1124       clr soak_temp_reached
0B0D C205      1125       clr reflow_temp_reached
0B0F           1126   
0B0F C0E0      1127       push acc
0B11 C0D0      1128       push psw
0B13 C000      1129       push AR0
0B15 C001      1130       push AR1
0B17 C002      1131       push AR2
0B19           1132       
0B19           1133       ; --- 1. CHECK SOAK TEMP ---
0B19           1134       ; Copy current_temp to X
0B19 7869      1135       mov R0, #current_temp
0B1B 7932      1136       mov R1, #x
0B1D 120B91    1137       lcall Copy4_Bytes_R0_to_R1
0B20           1138   
0B20           1139       ; Copy soak_temp to Y
0B20 786D      1140       mov R0, #soak_temp
0B22 7936      1141       mov R1, #y
0B24 120B91    1142       lcall Copy4_Bytes_R0_to_R1
0B27           1143   
0B27           1144       ; Compare: Is X (Current) < Y (Target)?
0B27 12011A    1145       lcall x_lt_y
0B2A 200102    1146       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
0B2D           1147       
0B2D           1148       ; If we are here, Current >= Target
0B2D D204      1149       setb soak_temp_reached
0B2F           1150   
0B2F           1151   Check_Reflow_Threshold:
0B2F           1152       ; --- 2. CHECK REFLOW TEMP ---
0B2F           1153       ; Copy current_temp to X (Need to reload X because math32 destroys it)
0B2F 7869      1154       mov R0, #current_temp
0B31 7932      1155       mov R1, #x
0B33 120B91    1156       lcall Copy4_Bytes_R0_to_R1
0B36           1157   
0B36           1158       ; Copy reflow_temp to Y
0B36 7871      1159       mov R0, #reflow_temp
0B38 7936      1160       mov R1, #y
0B3A 120B91    1161       lcall Copy4_Bytes_R0_to_R1
0B3D           1162   
0B3D           1163       ; Compare
0B3D 12011A    1164       lcall x_lt_y
0B40 200102    1165       jb mf, Temp_Compare_Done
0B43           1166       
0B43           1167       ; If Current >= Target
0B43 D205      1168       setb reflow_temp_reached
0B45           1169   
0B45           1170   Temp_Compare_Done:
0B45 D002      1171       pop AR2
0B47 D001      1172       pop AR1
0B49 D000      1173       pop AR0
0B4B D0D0      1174       pop psw
0B4D D0E0      1175       pop acc
0B4F 22        1176       ret
0B50           1177   ;-------------------------------------------------------------------------------;
0B50           1178   ; Time_Compare
0B50           1179   ;
0B50           1180   ; PURPOSE:
0B50           1181   ;   Compare the elapsed time against soak and reflow
0B50           1182   ;   time limits.
0B50           1183   ;
0B50           1184   ; BEHAVIOR:
0B50           1185   ;   - If current_time >= soak_time   if soak_time_reached    = 1
0B50           1186   ;   - If current_time >= reflow_time if reflow_time_reached = 1
0B50           1187   ;
0B50           1188   ; NOTES:
0B50           1189   ;   - Time values are treated as 32-bit UNSIGNED numbers
0B50           1190   ;     (e.g., milliseconds or seconds).
0B50           1191   ;   - Uses the SAME compare logic as Temp_Compare.
0B50           1192   ;   - This routine ONLY SETS flags.
0B50           1193   ;
0B50           1194   ; EXPECTED VARIABLES:
0B50           1195   ;   current_time[4], soak_time[4], reflow_time[4]
0B50           1196   ;   x[4], y[4]
0B50           1197   ;   mf, soak_time_reached, reflow_time_reached
0B50           1198   ;-------------------------------------------------------------------------------;
0B50           1199   Time_Compare:
0B50 C0E0      1200       push acc
0B52 C0D0      1201       push psw
0B54 C000      1202       push AR0
0B56 C001      1203       push AR1
0B58 C002      1204       push AR2
0B5A           1205   
0B5A           1206   ; Check: current_time >= soak_time ?
0B5A           1207       ; Copy current_time of x
0B5A 787A      1208       mov  R0, #current_time
0B5C 7932      1209       mov  R1, #x
0B5E 120B91    1210       lcall Copy4_Bytes_R0_to_R1
0B61           1211   
0B61           1212       ; Copy soak_time of y
0B61 787E      1213       mov  R0, #soak_time
0B63 7936      1214       mov  R1, #y
0B65 120B91    1215       lcall Copy4_Bytes_R0_to_R1
0B68           1216   
0B68           1217       ; Compare elapsed time vs soak time
0B68 12011A    1218       lcall x_lt_y
0B6B 200102    1219       jb   mf, Time_Soak_NotReached
0B6E D207      1220       setb soak_time_reached
0B70           1221   
0B70           1222   ; Check: current_time >= reflow_time ?
0B70           1223   Time_Soak_NotReached:
0B70           1224       ; Copy current_time of x
0B70 787A      1225       mov  R0, #current_time
0B72 7932      1226       mov  R1, #x
0B74 120B91    1227       lcall Copy4_Bytes_R0_to_R1
0B77           1228   
0B77           1229       ; Copy reflow_time of y
0B77 7882      1230       mov  R0, #reflow_time
0B79 7936      1231       mov  R1, #y
0B7B 120B91    1232       lcall Copy4_Bytes_R0_to_R1
0B7E           1233   
0B7E           1234       ; Compare elapsed time vs reflow time
0B7E 12011A    1235       lcall x_lt_y
0B81 200102    1236       jb   mf, Time_Reflow_NotReached
0B84 D208      1237       setb reflow_time_reached
0B86           1238   
0B86           1239   Time_Reflow_NotReached:
0B86 D002      1240       pop  AR2
0B88 D001      1241       pop  AR1
0B8A D000      1242       pop  AR0
0B8C D0D0      1243       pop  psw
0B8E D0E0      1244       pop  acc
0B90 22        1245       ret
0B91           1246   
0B91           1247   ;-------------------------------------------------------------------------------;
0B91           1248   ; Copy4_Bytes_R0_to_R1
0B91           1249   ;
0B91           1250   ; PURPOSE:
0B91           1251   ;   Utility routine to copy a 32-bit value (4 bytes)
0B91           1252   ;   from one memory location to another.
0B91           1253   ;
0B91           1254   ; INPUTS:
0B91           1255   ;   R0 st source address
0B91           1256   ;   R1 at destination address
0B91           1257   ;
0B91           1258   ; USES:
0B91           1259   ;   R2 as loop counter
0B91           1260   ;
0B91           1261   ; EXAMPLE:
0B91           1262   ;   mov R0, #current_temp
0B91           1263   ;   mov R1, #x
0B91           1264   ;   lcall Copy4_Bytes_R0_to_R1
0B91           1265   ;-------------------------------------------------------------------------------;
0B91           1266   Copy4_Bytes_R0_to_R1:
0B91 7A04      1267       mov  R2, #4
0B93           1268   Copy4_Loop:
0B93 E6        1269       mov  a, @R0
0B94 F7        1270       mov  @R1, a
0B95 08        1271       inc  R0
0B96 09        1272       inc  R1
0B97 DAFA      1273       djnz R2, Copy4_Loop
0B99 22        1274       ret
0B9A           1275   
0B9A           1276   ;-------------------------------------------------------------------------------;
0B9A           1277   ; Abort condition safety check Temperature time
0B9A           1278   ;
0B9A           1279   ; PURPOSE:
0B9A           1280   ;   Automatic cycle termination on error:
0B9A           1281   ;   Abort if oven fails to reach at least 50C in first 60s.
0B9A           1282   ;
0B9A           1283   ; TRIP CONDITION:
0B9A           1284   ;   if (current_time >= 60s) AND (current_temp < 50C)
0B9A           1285   ;       -> set tc_missing_abort
0B9A           1286   ;       -> set stop_signal
0B9A           1287   ;
0B9A           1288   ; ASSUMPTIONS:
0B9A           1289   ;   - current_time is in SECONDS (32-bit, little-endian)
0B9A           1290   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0B9A           1291   ;
0B9A           1292   ;   the Load_Y constants accordingly.
0B9A           1293   ;-------------------------------------------------------------------------------;
0B9A           1294   Safety_Check_TC:
0B9A C0E0      1295       push acc
0B9C C0D0      1296       push psw
0B9E C000      1297       push AR0
0BA0 C001      1298       push AR1
0BA2 C002      1299       push AR2
0BA4           1300   
0BA4           1301       ; ---------------------------------------------------------
0BA4           1302       ; [FIX] GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0BA4           1303       ; ---------------------------------------------------------
0BA4 E592      1304       mov a, Control_FSM_state
0BA6 B40202    1305       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0BA9 8003      1306       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0BAB           1307   
0BAB           1308       Safety_TC_Exit_Bridge:
0BAB 020BF9    1309           ljmp Safety_TC_Done               ; Jump to the end
0BAE           1310   
0BAE           1311       Safety_Logic_Proceed:
0BAE           1312           ; If already aborted or startup window closed, do nothing
0BAE 200F48    1313           jb   tc_missing_abort, Safety_TC_Done
0BB1 301045    1314           jnb  tc_startup_window, Safety_TC_Done
0BB4           1315   
0BB4           1316       ; Check: current_time >= 60 ?
0BB4 787A      1317       mov  R0, #current_time
0BB6 7932      1318       mov  R1, #x
0BB8 120B91    1319       lcall Copy4_Bytes_R0_to_R1
0BBB           1320   
0BBB 75363C    1321            mov y+0, #low (60 % 0x10000) 
0BBE 753700    1321            mov y+1, #high(60 % 0x10000) 
0BC1 753800    1321            mov y+2, #low (60 / 0x10000) 
0BC4 753900    1321            mov y+3, #high(60 / 0x10000) 
0BC7 12011A    1322       lcall x_lt_y
0BCA 2001DE    1323       jb   mf, Safety_TC_Exit_Bridge        ; still < 60s ? keep waiting
0BCD           1324   
0BCD           1325       ; We reached 60s: close the startup window so it won't re-check later
0BCD C210      1326       clr  tc_startup_window
0BCF           1327   
0BCF           1328       ; Now check: current_temp < 50 ?
0BCF 7869      1329       mov  R0, #current_temp
0BD1 7932      1330       mov  R1, #x
0BD3 120B91    1331       lcall Copy4_Bytes_R0_to_R1
0BD6           1332   
0BD6 753632    1333            mov y+0, #low (50 % 0x10000) 
0BD9 753700    1333            mov y+1, #high(50 % 0x10000) 
0BDC 753800    1333            mov y+2, #low (50 / 0x10000) 
0BDF 753900    1333            mov y+3, #high(50 / 0x10000) 
0BE2 12011A    1334       lcall x_lt_y
0BE5 3001C3    1335       jnb  mf, Safety_TC_Exit_Bridge        ; temp >= 50 ? pass
0BE8           1336   
0BE8           1337       ; FAIL: at 60s, still below 50C ? abort
0BE8 C293      1338       clr  PWM_OUT
0BEA D20F      1339       setb tc_missing_abort
0BEC D20A      1340       setb stop_signal
0BEE 120C0E    1341            lcall Beep_Ten
0BF1           1342       ; 3. Force FSM to State 0 (Welcome)
0BF1 759200    1343       mov Control_FSM_state, #0
0BF4           1344       
0BF4           1345       ; 4. Force UI to State 0 (Home Screen)
0BF4 759300    1346       mov Current_State, #0
0BF7           1347       
0BF7           1348       ; 5. Trigger Screen Refresh
0BF7 D20D      1349       setb state_change_signal ; Tell loop to redraw "Welcome"
0BF9           1350   
0BF9           1351   Safety_TC_Done:
0BF9 D002      1352       pop  AR2
0BFB D001      1353       pop  AR1
0BFD D000      1354       pop  AR0
0BFF D0D0      1355       pop  psw
0C01 D0E0      1356       pop  acc
0C03 22        1357       ret
0C04           1358   
0C04           1359   ; ============================================================
0C04           1360   ; BUZZER STARTUP FUNCTIONS
0C04           1361   ; ============================================================
0C04           1362   
0C04           1363   Beep_Once:
0C04 759D01    1364       mov beep_count, #1
0C07 800A      1365       sjmp Beep_Start
0C09           1366   
0C09           1367   Beep_Five:
0C09 759D05    1368       mov beep_count, #5
0C0C 8005      1369       sjmp Beep_Start
0C0E           1370   
0C0E           1371   Beep_Ten:
0C0E 759D0A    1372       mov beep_count, #10
0C11 8000      1373       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0C13           1374   
0C13           1375   Beep_Start:
0C13 C28C      1376       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0C15 759E01    1377       mov beep_state, #1   ; Set State to ON
0C18 759F00    1378       mov beep_tmr, #0     ; Reset Timer High Byte
0C1B 75A000    1379       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0C1E D2A9      1380       setb ET0             ; [FIX] Ensure Interrupt is enabled
0C20 D28C      1381       setb TR0             ; START the 2kHz tone
0C22 22        1382       ret
0C23           1383   ;============================================================
0C23           1384   
0C23           1385   ;============================================================
0C23           1386   ; Buzzer beep Task 
0C23           1387   ; Purpose: beeps, holds, stop
0C23           1388   ; Buzzer task:
0C23           1389   ; Beep once when state changes
0C23           1390   ; Beep five times if finished
0C23           1391   ; Beep ten times if meets error
0C23           1392   ;============================================================
0C23           1393   
0C23           1394   Beep_Task:
0C23 301435    1395       jnb one_ms_beep_flag, Beep_Done
0C26 C214      1396       clr one_ms_beep_flag
0C28           1397   
0C28 E59E      1398       mov a, beep_state
0C2A 602F      1399       jz Beep_Done
0C2C           1400   
0C2C           1401   ; ---- increment 16-bit timer ----
0C2C 059F      1402       inc beep_tmr
0C2E E59F      1403       mov a, beep_tmr
0C30 7002      1404       jnz Beep_Check
0C32 05A0      1405       inc beep_tmr+1
0C34           1406   
0C34           1407   Beep_Check:
0C34           1408       ; [FIX] FUZZY TIMER CHECK
0C34           1409       ; Check if High Byte is non-zero (Time >= 256ms)
0C34 E5A0      1410       mov a, beep_tmr+1
0C36 6023      1411       jz Beep_Done        ; If 0, keep beeping
0C38           1412   
0C38           1413       ; --- Time Limit Reached ---
0C38 759F00    1414       mov beep_tmr, #0    ; Reset timer
0C3B 75A000    1415       mov beep_tmr+1, #0
0C3E           1416   
0C3E E59E      1417       mov a, beep_state
0C40 B40106    1418       cjne a, #1, Beep_Off_State
0C43           1419   
0C43           1420       ; State was 1 (ON) -> Turn OFF
0C43 C28C      1421       clr TR0             ; Hardware Silence
0C45 759E02    1422       mov beep_state, #2  ; Set State to OFF (Pause)
0C48 22        1423       ret
0C49           1424   
0C49           1425   Beep_Off_State:
0C49           1426   ; ---- OFF finished -> decrement count / next ON ----
0C49 159D      1427       dec beep_count
0C4B E59D      1428       mov a, beep_count
0C4D 6006      1429       jz  Beep_Stop
0C4F           1430   
0C4F 759E01    1431       mov beep_state, #1
0C52 D28C      1432       setb TR0
0C54 22        1433       ret
0C55           1434   
0C55           1435   Beep_Stop:
0C55 C28C      1436       clr TR0
0C57 759E00    1437       mov beep_state, #0
0C5A 22        1438       ret
0C5B           1439   
0C5B           1440   Beep_Done:
0C5B 22        1441       ret
0C5C           1442   ;==================================================================
0C5C           1443   
0C5C           1444   ;-------------------------------------------------------------------------------;
0C5C           1445   ; Main Control FSM for the entire process
0C5C           1446   ;-------------------------------------------------------------------------------;
0C5C           1447   ;-------------------------------------------------------------------------------;
0C5C           1448   ; FSM LOGIC (Button Logic Fixed)
0C5C           1449   ;-------------------------------------------------------------------------------;
0C5C           1450   Control_FSM:
0C5C E592      1451       mov a, Control_FSM_state
0C5E 8005      1452       sjmp Control_FSM_state0
0C60           1453   
0C60           1454   Control_FSM_state0_a:
0C60 759200    1455       mov Control_FSM_state, #0
0C63 D20D      1456       setb state_change_signal
0C65           1457            
0C65           1458   Control_FSM_state0:
0C65 B40015    1459       cjne a, #0, Control_FSM_state1
0C68 209005    1460       jb P1.0, Control_FSM_done_bridge ; If Button High (Not Pressed), Exit
0C6B 1211CB    1461       lcall Wait_For_P1_0_Release      ; If Low (Pressed), Wait & Proceed
0C6E 8001      1462       sjmp Control_FSM_state1_a  
0C70           1463       
0C70           1464   Control_FSM_done_bridge:
0C70 22        1465       ret
0C71           1466   
0C71           1467   Control_FSM_state1_a:
0C71 0592      1468       inc Control_FSM_state
0C73 759300    1469       mov Current_State, #0
0C76 1210A9    1470       lcall Update_Screen_Full 
0C79 D20D      1471       setb state_change_signal
0C7B E592      1472       mov a, Control_FSM_state
0C7D           1473       
0C7D           1474   Control_FSM_state1:
0C7D B40127    1475       cjne a, #1, Control_FSM_state2
0C80 120EE1    1476       lcall Check_Buttons 
0C83 120F2D    1477       lcall Check_Keypad
0C86           1478       
0C86           1479       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0C86 209008    1480       jb P1.0, Control_FSM_state1_ret
0C89           1481       
0C89           1482       ; If we get here, Button is LOW (Pressed)
0C89 1211CB    1483       lcall Wait_For_P1_0_Release
0C8C 120E65    1484       lcall Update_FSM_Variables
0C8F 8001      1485       sjmp Control_FSM_state2_a
0C91           1486   Control_FSM_state1_ret:
0C91 22        1487       ret
0C92           1488   
0C92           1489   ; --- STATE 2: RAMP TO SOAK ---
0C92           1490   Control_FSM_state2_a:
0C92 0592      1491       inc Control_FSM_state
0C94 E592      1492       mov a, Control_FSM_state   ; [FIX] RELOAD 'A' so it matches the new state!
0C96 D20D      1493       setb state_change_signal
0C98 120C04    1494       lcall Beep_Once
0C9B           1495   
0C9B D210      1496       setb tc_startup_window    ; OPEN the safety window
0C9D C20F      1497       clr tc_missing_abort      ; Clear any previous aborts
0C9F 753000    1498       mov current_time_sec, #0  ; Reset Seconds to 0
0CA2 753100    1499       mov current_time_minute, #0 ; Reset Minutes to 0
0CA5           1500       
0CA5           1501       ; [FIX] CLEAR FLAG ON ENTRY
0CA5           1502       ; Force the system to wait for at least one fresh temp reading
0CA5           1503       ; before deciding we are done.
0CA5 C204      1504       clr soak_temp_reached      
0CA7           1505   
0CA7           1506   Control_FSM_state2:
0CA7 B4021F    1507       cjne a, #2, Control_FSM_state3
0CAA 301305    1508       jnb PB2_flag, State2_Check
0CAD C213      1509       clr PB2_flag
0CAF 020D1A    1510       ljmp Control_FSM_state6_a ; Pause
0CB2           1511   
0CB2           1512   State2_Check:
0CB2 300413    1513       jnb soak_temp_reached, State2_Ret
0CB5           1514       
0CB5           1515       ; --- We reached Temp! Move to State 3 ---
0CB5 C204      1516       clr soak_temp_reached
0CB7 0592      1517       inc Control_FSM_state
0CB9           1518       
0CB9           1519       ; [FIX] RELOAD 'A' (Good practice)
0CB9 E592      1520       mov a, Control_FSM_state   
0CBB           1521       
0CBB D20D      1522       setb state_change_signal
0CBD 120C04    1523       lcall Beep_Once
0CC0           1524       
0CC0 753000    1525       mov current_time_sec, #0
0CC3 753100    1526       mov current_time_minute, #0
0CC6           1527       
0CC6           1528       ; Ensure we start State 3 fresh
0CC6 C207      1529       clr soak_time_reached 
0CC8           1530   
0CC8           1531   State2_Ret:
0CC8 22        1532       ret
0CC9           1533   
0CC9           1534   ; --- STATE 3: SOAK PHASE ---
0CC9           1535   Control_FSM_state3:
0CC9 B40315    1536       cjne a, #3, Control_FSM_state4
0CCC 301305    1537       jnb PB2_flag, State3_Check
0CCF C213      1538       clr PB2_flag
0CD1 020D1A    1539       ljmp Control_FSM_state6_a
0CD4           1540   State3_Check:
0CD4 300709    1541       jnb soak_time_reached, State3_Ret
0CD7 C207      1542       clr soak_time_reached
0CD9 0592      1543       inc Control_FSM_state      
0CDB D20D      1544       setb state_change_signal 
0CDD 120C04    1545            lcall Beep_Once
0CE0           1546   State3_Ret:
0CE0 22        1547       ret
0CE1           1548   
0CE1           1549   ; --- STATE 4: RAMP TO PEAK ---
0CE1           1550   Control_FSM_state4:
0CE1 B4041D    1551       cjne a, #4, Control_FSM_state5
0CE4 301305    1552       jnb PB2_flag, State4_Check
0CE7 C213      1553       clr PB2_flag
0CE9 020D1A    1554       ljmp Control_FSM_state6_a
0CEC           1555   State4_Check:
0CEC 300511    1556       jnb reflow_temp_reached, State4_Ret
0CEF C205      1557       clr reflow_temp_reached
0CF1 0592      1558       inc Control_FSM_state
0CF3 D20D      1559       setb state_change_signal
0CF5 120C04    1560            lcall Beep_Once
0CF8 753000    1561       mov current_time_sec, #0
0CFB 753100    1562       mov current_time_minute, #0
0CFE           1563       ; --- ADD THIS LINE ---
0CFE C208      1564       clr reflow_time_reached ; Kill the ghost flag
0D00           1565       ; ---------------------
0D00           1566   State4_Ret:
0D00 22        1567       ret
0D01           1568   
0D01           1569   ; --- STATE 5: REFLOW PHASE ---
0D01           1570   Control_FSM_state5:
0D01 B40502    1571       cjne a, #5, Control_FSM_state6_trampoline
0D04 8003      1572       sjmp State5_Logic
0D06           1573   Control_FSM_state6_trampoline:
0D06 020D21    1574       ljmp Control_FSM_state6
0D09           1575   
0D09           1576   State5_Logic:
0D09 301305    1577       jnb PB2_flag, State5_Check
0D0C C213      1578       clr PB2_flag
0D0E 020D1A    1579       ljmp Control_FSM_state6_a
0D11           1580   State5_Check:
0D11 300805    1581       jnb reflow_time_reached, State5_Ret
0D14 C208      1582       clr reflow_time_reached
0D16 020D1A    1583       ljmp Control_FSM_state6_a
0D19           1584   State5_Ret:
0D19 22        1585       ret
0D1A           1586   
0D1A           1587   ; --- STATE 6: COOLING ---
0D1A           1588   Control_FSM_state6_a:
0D1A 0592      1589       inc Control_FSM_state
0D1C D20D      1590       setb state_change_signal
0D1E 120C09    1591            lcall Beep_Five
0D21           1592   Control_FSM_state6:
0D21 B4060A    1593       cjne a, #6, Control_FSM_state7
0D24           1594       ; Wait for Cooling Temp Reached
0D24 300606    1595       jnb cooling_temp_reached, State6_Ret
0D27 C206      1596       clr cooling_temp_reached
0D29 0592      1597       inc Control_FSM_state
0D2B D20D      1598       setb state_change_signal
0D2D           1599   State6_Ret:
0D2D 22        1600       ret
0D2E           1601   
0D2E           1602   ; --- STATE 7: DONE ---
0D2E           1603   Control_FSM_state7:
0D2E B40711    1604       cjne a, #7, Control_FSM_done
0D31           1605       
0D31           1606       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0D31 201109    1607       jb PB0_flag, Control_FSM_Reset_Logic ; Wait, PB0_flag is software flag?
0D34           1608       
0D34           1609       ; Let's assume you meant the physical button P1.0 like State 0
0D34 20900B    1610       jb P1.0, Control_FSM_done
0D37           1611       
0D37 1211CB    1612       lcall Wait_For_P1_0_Release
0D3A 020C60    1613       ljmp Control_FSM_state0_a
0D3D           1614   
0D3D           1615   Control_FSM_Reset_Logic:
0D3D           1616       ; If using PB0_flag from ISR, handle here
0D3D C211      1617       clr PB0_flag
0D3F 020C60    1618       ljmp Control_FSM_state0_a
0D42           1619   
0D42           1620   Control_FSM_done:
0D42 22        1621       ret
0D43           1622   ;-------------------------------------------------------------------------------;
0D43           1623   ;         Main program.          
0D43           1624   ;-------------------------------------------------------------------------------;
0D43           1625   main:
0D43           1626   
0D43           1627       ; --------------------------------------------------------
0D43           1628       ; 1. SAFETY SHUTDOWN
0D43           1629       ; --------------------------------------------------------
0D43 C2AF      1630       clr EA              ; FORCE Interrupts OFF immediately
0D45 7581C0    1631       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0D48           1632       
0D48           1633       ; --------------------------------------------------------
0D48           1634       ; 2. THE "DIRTY DELAY" (Fixes Reset Garbage)
0D48           1635       ; We burn ~100ms here using a raw loop. 
0D48           1636       ; We cannot use timers yet because they aren't initialized.
0D48           1637       ; --------------------------------------------------------
0D48 78FA      1638       mov R0, #250
0D4A           1639   Reset_Delay_Outer:
0D4A 79FF      1640       mov R1, #255
0D4C           1641   Reset_Delay_Inner:
0D4C D9FE      1642       djnz R1, Reset_Delay_Inner
0D4E D8FA      1643       djnz R0, Reset_Delay_Outer
0D50           1644       ; --------------------------------------------------------
0D50           1645   
0D50           1646       ; ... NOW continue with your normal Port Configuration ...
0D50           1647       
0D50           1648       ; --- PORT CONFIGURATION ---
0D50 759AAA    1649       mov P0MOD, #0xAA
0D53           1650   
0D53           1651       ; P1: Mixed usage 
0D53           1652       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0D53           1653       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0D53           1654       ; P1.0 (Unused/RX) -> Input
0D53           1655       ; Binary: 11111110 -> Hex: 0xFE
0D53 759BFE    1656       mov P1MOD, #0xFE
0D56           1657   
0D56           1658       ; P2: Row4(Out), Cols(In)
0D56           1659       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0D56           1660       ; Binary: 00000001 -> Hex: 0x01
0D56 759C01    1661       mov P2MOD, #0x01
0D59           1662   
0D59           1663       ; P3: Col4(In)
0D59           1664       ; P3.0 (Col4) is In (0).
0D59 759D40    1665       mov P3MOD, #01000000B
0D5C           1666       ; Turn off all the LEDs
0D5C 75E800    1667       mov LEDRA, #0 ; LEDRA is bit addressable
0D5F 759500    1668       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0D62           1669   
0D62           1670       ; Enable Global interrupts
0D62 D2AF      1671       setb EA  
0D64           1672   
0D64           1673       ; FSM initial states
0D64 759000    1674       mov KEY1_DEB_state, #0
0D67 759100    1675       mov SEC_FSM_state, #0
0D6A 759200    1676       mov Control_FSM_state, #0
0D6D 759300    1677       mov Current_State, #0
0D70           1678       
0D70           1679       ; FSM timers initialization
0D70 758E00    1680       mov KEY1_DEB_timer, #0
0D73 758F00    1681       mov SEC_FSM_timer, #0
0D76           1682       ; time counters initialization
0D76 753000    1683       mov current_time_sec, #0
0D79 753100    1684       mov current_time_minute, #0
0D7C           1685       ; Initialize counter to zero
0D7C 758A00    1686       mov pwm_counter, #0
0D7F 758B00    1687       mov pwm_counter+1, #0
0D82 758C00    1688       mov pwm_counter+2, #0
0D85 758D00    1689       mov pwm_counter+3, #0
0D88           1690       ; Initialize power output
0D88 758900    1691       mov power_output+3, #0
0D8B 758800    1692       mov power_output+2, #0
0D8E 758702    1693       mov power_output+1, #02H
0D91 7586EE    1694       mov power_output, #0EEH ; (initilize to 750 for testing)
0D94           1695   
0D94           1696       ; Clear all the flags
0D94 C20F      1697       clr  tc_missing_abort
0D96 C20A      1698       clr  stop_signal
0D98 C211      1699       clr PB0_flag
0D9A C212      1700       clr PB1_flag
0D9C C213      1701       clr PB2_flag
0D9E C202      1702       clr one_second_flag
0DA0 C20C      1703       clr config_finish_signal
0DA2 C204      1704       clr soak_temp_reached
0DA4 C207      1705       clr soak_time_reached
0DA6 C205      1706       clr reflow_temp_reached
0DA8 C208      1707       clr reflow_time_reached
0DAA C206      1708       clr cooling_temp_reached
0DAC C20D      1709       clr state_change_signal
0DAE C21F      1710       clr one_millisecond_flag_servo
0DB0 C200      1711       clr remote_config_mode
0DB2           1712       
0DB2 D20D      1713       setb state_change_signal
0DB4           1714   
0DB4           1715       ; Set bit
0DB4 D210      1716       setb tc_startup_window
0DB6           1717   
0DB6           1718       ; --------------------------------------
0DB6           1719       ; [FIX] ADD THIS BLOCK TO STOP STARTUP BEEP
0DB6           1720       ; --------------------------------------
0DB6 759E00    1721       mov beep_state, #0
0DB9 759D00    1722       mov beep_count, #0
0DBC 759F00    1723       mov beep_tmr, #0
0DBF 75A000    1724       mov beep_tmr+1, #0
0DC2 C214      1725       clr one_ms_beep_flag
0DC4 C28C      1726       clr TR0              ; Force buzzer hardware OFF
0DC6           1727       ; --------------------------------------
0DC6           1728   
0DC6           1729   
0DC6 12045D    1730       lcall Timer0_Init
0DC9 12069A    1731       lcall Timer2_Init
0DCC 120767    1732       lcall ELCD_4BIT
0DCF           1733       ;----- Two new lines I added to initialize the UI
0DCF 121056    1734       lcall Init_All_Buffers
0DD2 1210A9    1735       lcall Update_Screen_Full
0DD5           1736       ;-----
0DD5 120477    1737       lcall Initialize_Serial_Port
0DD8 753F00    1738       mov rx_idx, #0
0DDB 754000    1739       mov rx_ready, #0
0DDE           1740   
0DDE           1741   ;-------------------------------------------------------------------------------;
0DDE           1742   ; while(1) loop
0DDE           1743   ;-------------------------------------------------------------------------------;
0DDE           1744   loop:
0DDE           1745       ; ALWAYS: keep serial alive so PC can send config
0DDE 1204AC    1746       lcall Serial_RX_Pump
0DE1 120502    1747       lcall Serial_Process_Line
0DE4           1748   
0DE4           1749       ; Full reset button on P3.7 (active-low to GND)
0DE4 30B702    1750        jnb P3_7, Full_Reset_Trig
0DE7 8003      1751       sjmp Full_Reset_Check_Done
0DE9           1752   
0DE9           1753   Full_Reset_Trig:
0DE9 0211D3    1754       ljmp Full_Reset
0DEC           1755   
0DEC           1756   Full_Reset_Check_Done:
0DEC           1757   
0DEC           1758       ; =========================================================
0DEC           1759       ; FREEZE CONTROL LOGIC DURING REMOTE CONFIG
0DEC           1760       ; (prevents speaker, FSM jumps, timers, etc.)
0DEC           1761       ; =========================================================
0DEC           1762       ; jb remote_config_mode, Remote_Config_Loop
0DEC           1763   
0DEC           1764       ; ---------------------------------------------------------
0DEC           1765       ; NORMAL RUN LOGIC
0DEC           1766       ; ---------------------------------------------------------
0DEC           1767   
0DEC           1768       ; Check the FSM for KEY1 debounce
0DEC 120A08    1769       lcall KEY1_DEB
0DEF           1770   
0DEF           1771       ; Take temp readings
0DEF 1211D9    1772       lcall Read_Thermocouple
0DF2           1773   
0DF2           1774       ; 1. Check if we reached temp (Observer)
0DF2 120B0B    1775       lcall Temp_Compare
0DF5           1776   
0DF5           1777       ; 2. Decide heater power based on flags (Driver)
0DF5 12131B    1778       lcall proportional_power_control
0DF8           1779   
0DF8           1780       ; 3. Calculate Total Seconds (Minutes * 60 + Seconds)
0DF8 853132    1781       mov x+0, current_time_minute
0DFB 753300    1782       mov x+1, #0
0DFE 753400    1783       mov x+2, #0
0E01 753500    1784       mov x+3, #0
0E04           1785   
0E04 75363C    1786            mov y+0, #low (60 % 0x10000) 
0E07 753700    1786            mov y+1, #high(60 % 0x10000) 
0E0A 753800    1786            mov y+2, #low (60 / 0x10000) 
0E0D 753900    1786            mov y+3, #high(60 / 0x10000) 
0E10 12018C    1787       lcall mul32
0E13           1788   
0E13 853036    1789       mov y+0, current_time_sec
0E16 753700    1790       mov y+1, #0
0E19 753800    1791       mov y+2, #0
0E1C 753900    1792       mov y+3, #0
0E1F           1793   
0E1F 1200D3    1794       lcall add32
0E22           1795   
0E22 85327A    1796       mov current_time+0, x+0
0E25 85337B    1797       mov current_time+1, x+1
0E28 85347C    1798       mov current_time+2, x+2
0E2B 85357D    1799       mov current_time+3, x+3
0E2E           1800   
0E2E 120B50    1801       lcall Time_Compare
0E31 120B9A    1802       lcall Safety_Check_TC
0E34           1803   
0E34           1804       ; one-second counter
0E34 120A3E    1805       lcall SEC_FSM
0E37           1806   
0E37           1807       ; overall FSM
0E37 120C5C    1808       lcall Control_FSM
0E3A           1809   
0E3A           1810       ; LCD update (normal)
0E3A 12082C    1811       lcall LCD_Display_Update_func
0E3D           1812   
0E3D           1813       ; buzzer tick sync
0E3D 300302    1814       jnb one_ms_pwm_flag, Skip_Beep_Sync
0E40 D214      1815       setb one_ms_beep_flag
0E42           1816   
0E42           1817   Skip_Beep_Sync:
0E42           1818       ; heater PWM
0E42 120A94    1819       lcall PWM_Wave
0E45           1820   
0E45           1821       ; buzzer
0E45 120C23    1822       lcall Beep_Task
0E48           1823   
0E48           1824       ; servo
0E48 1212AE    1825       lcall call_servo_control
0E4B           1826   
0E4B 020DDE    1827       ljmp loop
0E4E           1828   
0E4E           1829   
0E4E           1830   Remote_Config_Loop:
0E4E           1831       ; silence outputs
0E4E C28C      1832       clr TR0
0E50 C293      1833       clr PWM_OUT
0E52           1834   
0E52           1835       ; still allow UI navigation / redraw
0E52 120EE1    1836       lcall Check_Buttons
0E55 120F2D    1837       lcall Check_Keypad
0E58           1838       ; Only redraw when something changed (optional but recommended)
0E58 200D02    1839       jb state_change_signal, RC_REDRAW
0E5B 8005      1840       sjmp RC_DONE
0E5D           1841   RC_REDRAW:
0E5D C20D      1842       clr state_change_signal
0E5F 1210A9    1843       lcall Update_Screen_Full
0E62           1844   RC_DONE:
0E62 020DDE    1845       ljmp loop
0E65           1846   
0E65           1847   ;-------------------------------------------------------------------------------;
0E65           1848   
0E65           1849   ; ================================================================
0E65           1850   ; UI & HELPER SUBROUTINES
0E65           1851   ; ================================================================
0E65           1852   
0E65           1853   ; ----------------------------------------------------------------
0E65           1854   ; MODULE: BRIDGE (Text to Integer Conversion)
0E65           1855   ; ----------------------------------------------------------------
0E65           1856   Update_FSM_Variables:
0E65           1857       ; --- 1. SOAK TEMP ---
0E65 7880      1858       mov R0, #Buf_Soak_Temp
0E67 120EA4    1859       lcall Parse_Temp_String
0E6A 8F6D      1860       mov soak_temp+0, R7
0E6C 756E00    1861       mov soak_temp+1, #0
0E6F 756F00    1862       mov soak_temp+2, #0
0E72 757000    1863       mov soak_temp+3, #0
0E75           1864   
0E75           1865       ; --- 2. REFLOW TEMP ---
0E75 7889      1866       mov R0, #Buf_Refl_Temp
0E77 120EA4    1867       lcall Parse_Temp_String
0E7A 8F71      1868       mov reflow_temp+0, R7
0E7C 757200    1869       mov reflow_temp+1, #0
0E7F 757300    1870       mov reflow_temp+2, #0
0E82 757400    1871       mov reflow_temp+3, #0
0E85           1872   
0E85           1873       ; --- 3. SOAK TIME ---
0E85 7884      1874       mov R0, #Buf_Soak_Time
0E87 120EB8    1875       lcall Parse_Time_String
0E8A 8F7E      1876       mov soak_time+0, R7
0E8C 8E7F      1877       mov soak_time+1, R6
0E8E 758000    1878       mov soak_time+2, #0
0E91 758100    1879       mov soak_time+3, #0
0E94           1880   
0E94           1881       ; --- 4. REFLOW TIME ---
0E94 788D      1882       mov R0, #Buf_Refl_Time
0E96 120EB8    1883       lcall Parse_Time_String
0E99 8F82      1884       mov reflow_time+0, R7
0E9B 8E83      1885       mov reflow_time+1, R6
0E9D 758400    1886       mov reflow_time+2, #0
0EA0 758500    1887       mov reflow_time+3, #0
0EA3 22        1888       ret
0EA4           1889   
0EA4           1890   ; --- Helper: Parse "123" to Integer ---
0EA4           1891   Parse_Temp_String:
0EA4 7F00      1892       mov R7, #0              ; Clear Result
0EA6           1893   Parse_Temp_Loop:
0EA6 E6        1894       mov A, @R0
0EA7 600E      1895       jz Parse_Temp_Done      ; If Null, we are done
0EA9           1896       
0EA9           1897       ; Convert ASCII to Digit
0EA9 C3        1898       clr C
0EAA 9430      1899       subb A, #0x30
0EAC FD        1900       mov R5, A               ; R5 = New Digit
0EAD           1901       
0EAD           1902       ; Result = (Result * 10) + New Digit
0EAD EF        1903       mov A, R7
0EAE 75F00A    1904       mov B, #10
0EB1 A4        1905       mul AB
0EB2 2D        1906       add A, R5
0EB3 FF        1907       mov R7, A
0EB4           1908       
0EB4 08        1909       inc R0
0EB5 80EF      1910       sjmp Parse_Temp_Loop
0EB7           1911   Parse_Temp_Done:
0EB7 22        1912       ret
0EB8           1913   
0EB8           1914   ; --- Helper: Parse "MMSS" to Seconds ---
0EB8           1915   Parse_Time_String:
0EB8           1916       ; 1. Minutes Tens
0EB8 E6        1917       mov A, @R0
0EB9 9430      1918       subb A, #0x30
0EBB 75F00A    1919       mov B, #10
0EBE A4        1920       mul AB
0EBF FD        1921       mov R5, A
0EC0 08        1922       inc R0
0EC1           1923       
0EC1           1924       ; 2. Minutes Ones
0EC1 E6        1925       mov A, @R0
0EC2 9430      1926       subb A, #0x30
0EC4 2D        1927       add A, R5
0EC5 FD        1928       mov R5, A               ; R5 = Total Minutes
0EC6 08        1929       inc R0
0EC7           1930       
0EC7           1931       ; 3. Seconds Tens
0EC7 E6        1932       mov A, @R0
0EC8 9430      1933       subb A, #0x30
0ECA 75F00A    1934       mov B, #10
0ECD A4        1935       mul AB
0ECE FC        1936       mov R4, A
0ECF 08        1937       inc R0
0ED0           1938       
0ED0           1939       ; 4. Seconds Ones
0ED0 E6        1940       mov A, @R0
0ED1 9430      1941       subb A, #0x30
0ED3 2C        1942       add A, R4               ; R4 = Total Seconds
0ED4           1943       
0ED4           1944       ; 5. Calculate Total Seconds = (Mins * 60) + Secs
0ED4 ED        1945       mov A, R5
0ED5 75F03C    1946       mov B, #60
0ED8 A4        1947       mul AB
0ED9 2C        1948       add A, R4
0EDA FF        1949       mov R7, A               ; Low Byte
0EDB E5F0      1950       mov A, B
0EDD 3400      1951       addc A, #0
0EDF FE        1952       mov R6, A               ; High Byte
0EE0 22        1953       ret
0EE1           1954   
0EE1           1955   ; ----------------------------------------------------------------
0EE1           1956   ; MODULE: BUTTON HANDLER (Mode Selection)
0EE1           1957   ; ----------------------------------------------------------------
0EE1           1958   Check_Buttons:
0EE1           1959       ; --- FORCE INPUT MODE ---
0EE1           1960       ; This clears any '0' the LCD library might have written to our buttons
0EE1 438055    1961       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0EE4           1962       ; ------------------------
0EE4           1963   
0EE4 30800A    1964       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0EE7 308212    1965       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0EEA 30841A    1966       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0EED 308622    1967       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0EF0 22        1968       ret
0EF1           1969   
0EF1           1970   Btn_Soak_Temp_Press:
0EF1 12119B    1971       lcall Wait_25ms_BLOCKING
0EF4 759301    1972       mov Current_State, #1
0EF7 759C00    1973       mov Cursor_Idx, #0
0EFA 8021      1974       sjmp Redraw_Screen
0EFC           1975   
0EFC           1976   Btn_Soak_Time_Press:
0EFC 12119B    1977       lcall Wait_25ms_BLOCKING
0EFF 759302    1978       mov Current_State, #2
0F02 759C00    1979       mov Cursor_Idx, #0
0F05 8016      1980       sjmp Redraw_Screen
0F07           1981   
0F07           1982   Btn_Refl_Temp_Press:
0F07 12119B    1983       lcall Wait_25ms_BLOCKING
0F0A 759303    1984       mov Current_State, #3
0F0D 759C00    1985       mov Cursor_Idx, #0
0F10 800B      1986       sjmp Redraw_Screen
0F12           1987   
0F12           1988   Btn_Refl_Time_Press:
0F12 12119B    1989       lcall Wait_25ms_BLOCKING 
0F15 759304    1990       mov Current_State, #4
0F18 759C00    1991       mov Cursor_Idx, #0
0F1B 8000      1992       sjmp Redraw_Screen
0F1D           1993   
0F1D           1994   Redraw_Screen:
0F1D           1995       ; Wait for button release
0F1D 3080FD    1996       jnb BTN_SOAK_TEMP, $
0F20 3082FD    1997       jnb BTN_SOAK_TIME, $
0F23 3084FD    1998       jnb BTN_REFL_TEMP, $
0F26 3086FD    1999       jnb BTN_REFL_TIME, $
0F29           2000   
0F29 1210A9    2001       lcall Update_Screen_Full
0F2C 22        2002       ret
0F2D           2003   
0F2D           2004   ; ----------------------------------------------------------------
0F2D           2005   ; MODULE: KEYPAD HANDLER (Input Logic)
0F2D           2006   ; ----------------------------------------------------------------
0F2D           2007   Check_Keypad:
0F2D           2008       ; If State is 0 (Home), ignore keypad
0F2D E593      2009       mov A, Current_State
0F2F 6050      2010       jz Keypad_Exit
0F31           2011       
0F31 120F82    2012       lcall Keypad_Scan
0F34 504B      2013       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0F36           2014   
0F36           2015       ; --- Check Special Keys ---
0F36 EF        2016       mov A, R7
0F37 B40E0A    2017       cjne A, #14, Check_Hash ; 14 is Star (*)
0F3A           2018       
0F3A           2019       ; Star Key Pressed: Reset Buffer
0F3A 121086    2020       lcall Reset_Current_Buffer
0F3D 1210A9    2021       lcall Update_Screen_Full
0F40 759C00    2022       mov Cursor_Idx, #0
0F43 22        2023       ret
0F44           2024   
0F44           2025   Check_Hash:
0F44 EF        2026       mov A, R7
0F45 B40C01    2027       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0F48 22        2028       ret                     ; Ignore Hash key
0F49           2029   
0F49           2030   Check_Numeric:
0F49           2031       ; Ensure key is 0-9
0F49 EF        2032       mov A, R7
0F4A C3        2033       clr C
0F4B 940A      2034       subb A, #10
0F4D 5031      2035       jnc Symbol_Key_Ignored
0F4F           2036       
0F4F           2037       ; Convert to ASCII
0F4F EF        2038       mov A, R7
0F50 2430      2039       add A, #0x30
0F52 FD        2040       mov R5, A
0F53           2041   
0F53           2042       ; Save to Buffer
0F53 1211B4    2043       lcall Get_Current_Buffer_Addr
0F56 E59C      2044       mov A, Cursor_Idx
0F58 28        2045       add A, R0
0F59 F8        2046       mov R0, A
0F5A ED        2047       mov A, R5
0F5B F6        2048       mov @R0, A
0F5C 059C      2049       inc Cursor_Idx
0F5E           2050   
0F5E           2051       ; --- Check Cursor Limits ---
0F5E E593      2052       mov A, Current_State
0F60 B40102    2053       cjne A, #1, Check_Limit_Time_1
0F63 8005      2054       sjmp Limit_Temp_3
0F65           2055   
0F65           2056   Check_Limit_Time_1:
0F65 B4030B    2057       cjne A, #3, Limit_Time_4
0F68 8000      2058       sjmp Limit_Temp_3
0F6A           2059   
0F6A           2060   Limit_Temp_3:
0F6A E59C      2061       mov A, Cursor_Idx
0F6C B4030D    2062       cjne A, #3, Do_Refresh
0F6F 159C      2063       dec Cursor_Idx          ; Stay at last digit
0F71 8009      2064       sjmp Do_Refresh
0F73           2065   
0F73           2066   Limit_Time_4:
0F73 E59C      2067       mov A, Cursor_Idx
0F75 B40404    2068       cjne A, #4, Do_Refresh
0F78 159C      2069       dec Cursor_Idx          ; Stay at last digit
0F7A 8000      2070       sjmp Do_Refresh
0F7C           2071   
0F7C           2072   Do_Refresh:
0F7C 1210A9    2073       lcall Update_Screen_Full
0F7F 22        2074       ret
0F80           2075   
0F80           2076   Symbol_Key_Ignored:
0F80 22        2077       ret
0F81           2078   Keypad_Exit:
0F81 22        2079       ret
0F82           2080   
0F82           2081   ; ----------------------------------------------------------------
0F82           2082   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0F82           2083   ; ----------------------------------------------------------------
0F82           2084   Keypad_Scan:
0F82           2085       ; Step 1: Check if ANY key is pressed (All Rows Low)
0F82 C292      2086       clr ROW1
0F84 C294      2087       clr ROW2
0F86 C296      2088       clr ROW3
0F88 C2A0      2089       clr ROW4
0F8A A2A2      2090       mov C, COL1
0F8C 82A4      2091       anl C, COL2
0F8E 82A6      2092       anl C, COL3
0F90 82B0      2093       anl C, COL4
0F92 5002      2094       jnc Keypad_Debounce
0F94 C3        2095       clr C
0F95 22        2096       ret
0F96           2097   
0F96           2098   Keypad_Debounce:
0F96 12119B    2099       lcall Wait_25ms_BLOCKING
0F99 A2A2      2100       mov C, COL1
0F9B 82A4      2101       anl C, COL2
0F9D 82A6      2102       anl C, COL3
0F9F 82B0      2103       anl C, COL4
0FA1 5002      2104       jnc Keypad_Find_Row
0FA3 C3        2105       clr C
0FA4 22        2106       ret
0FA5           2107   
0FA5           2108   Keypad_Find_Row:
0FA5 D292      2109       setb ROW1
0FA7 D294      2110       setb ROW2
0FA9 D296      2111       setb ROW3
0FAB D2A0      2112       setb ROW4
0FAD           2113   
0FAD           2114       ; Row 1
0FAD C292      2115       clr ROW1
0FAF 30A23D    2116       jnb COL1, Keypad_Key_1
0FB2 30A43E    2117       jnb COL2, Keypad_Key_2
0FB5 30A63F    2118       jnb COL3, Keypad_Key_3
0FB8 30B040    2119       jnb COL4, Keypad_Key_A
0FBB D292      2120       setb ROW1
0FBD           2121   
0FBD           2122       ; Row 2
0FBD C294      2123       clr ROW2
0FBF 30A23D    2124       jnb COL1, Keypad_Key_4
0FC2 30A43E    2125       jnb COL2, Keypad_Key_5
0FC5 30A63F    2126       jnb COL3, Keypad_Key_6
0FC8 30B040    2127       jnb COL4, Keypad_Key_B
0FCB D294      2128       setb ROW2
0FCD           2129   
0FCD           2130       ; Row 3
0FCD C296      2131       clr ROW3
0FCF 30A23D    2132       jnb COL1, Keypad_Key_7
0FD2 30A43E    2133       jnb COL2, Keypad_Key_8
0FD5 30A63F    2134       jnb COL3, Keypad_Key_9
0FD8 30B040    2135       jnb COL4, Keypad_Key_C
0FDB D296      2136       setb ROW3
0FDD           2137   
0FDD           2138       ; Row 4
0FDD C2A0      2139       clr ROW4
0FDF 30A23D    2140       jnb COL1, Keypad_Key_Star
0FE2 30A43E    2141       jnb COL2, Keypad_Key_0
0FE5 30A63F    2142       jnb COL3, Keypad_Key_Hash
0FE8 30B040    2143       jnb COL4, Keypad_Key_D
0FEB D2A0      2144       setb ROW4
0FED C3        2145       clr C
0FEE 22        2146       ret
0FEF           2147   
0FEF           2148   ; Key Mapping (Renamed to avoid conflicts)
0FEF 7F01      2149   Keypad_Key_1: mov R7, #1
0FF1 803C      2150          sjmp Wait_Release
0FF3 7F02      2151   Keypad_Key_2: mov R7, #2
0FF5 8038      2152          sjmp Wait_Release
0FF7 7F03      2153   Keypad_Key_3: mov R7, #3
0FF9 8034      2154          sjmp Wait_Release
0FFB 7F0A      2155   Keypad_Key_A: mov R7, #10
0FFD 8030      2156          sjmp Wait_Release
0FFF 7F04      2157   Keypad_Key_4: mov R7, #4
1001 802C      2158          sjmp Wait_Release
1003 7F05      2159   Keypad_Key_5: mov R7, #5
1005 8028      2160          sjmp Wait_Release
1007 7F06      2161   Keypad_Key_6: mov R7, #6
1009 8024      2162          sjmp Wait_Release
100B 7F0B      2163   Keypad_Key_B: mov R7, #11
100D 8020      2164          sjmp Wait_Release
100F 7F07      2165   Keypad_Key_7: mov R7, #7
1011 801C      2166          sjmp Wait_Release
1013 7F08      2167   Keypad_Key_8: mov R7, #8
1015 8018      2168          sjmp Wait_Release
1017 7F09      2169   Keypad_Key_9: mov R7, #9
1019 8014      2170          sjmp Wait_Release
101B 7F0D      2171   Keypad_Key_C: mov R7, #13
101D 8010      2172          sjmp Wait_Release
101F 7F0E      2173   Keypad_Key_Star: mov R7, #14
1021 800C      2174          sjmp Wait_Release
1023 7F00      2175   Keypad_Key_0: mov R7, #0
1025 8008      2176          sjmp Wait_Release
1027 7F0C      2177   Keypad_Key_Hash: mov R7, #12
1029 8004      2178          sjmp Wait_Release
102B 7F0F      2179   Keypad_Key_D: mov R7, #15
102D 8000      2180          sjmp Wait_Release
102F           2181   
102F           2182   Wait_Release:
102F A2A2      2183       mov C, COL1
1031 82A4      2184       anl C, COL2
1033 82A6      2185       anl C, COL3
1035 82B0      2186       anl C, COL4
1037 50F6      2187       jnc Wait_Release
1039 D3        2188       setb C
103A D292      2189       setb ROW1
103C D294      2190       setb ROW2
103E D296      2191       setb ROW3
1040 D2A0      2192       setb ROW4
1042 22        2193       ret
1043           2194   
1043           2195   Wait_25ms:
1043           2196       ; 1. Check if we are already waiting
1043 20150E    2197       jb wait25_active, Check_Timer_Status
1046           2198       
1046           2199       ; 2. Check if we just finished
1046 301604    2200       jnb wait25_done, Start_New_Timer
1049           2201       
1049           2202       ; 3. Timer is DONE! Reset flags and return True
1049 C216      2203       clr wait25_done
104B D3        2204       setb C          ; Carry = 1 means "Done"
104C 22        2205       ret
104D           2206   
104D           2207   Start_New_Timer:
104D           2208       ; 4. Start a new 25ms wait
104D 757900    2209       mov wait25_count, #0
1050 D215      2210       setb wait25_active
1052 C3        2211       clr C           ; Carry = 0 means "Not Done Yet"
1053 22        2212       ret
1054           2213   
1054           2214   Check_Timer_Status:
1054           2215       ; 5. Still waiting... return False immediately
1054 C3        2216       clr C           ; Carry = 0 means "Not Done Yet"
1055 22        2217       ret
1056           2218   
1056           2219   ; ----------------------------------------------------------------
1056           2220   ; MODULE: BUFFER INIT (Reset Logic)
1056           2221   ; ----------------------------------------------------------------
1056           2222   Init_All_Buffers:
1056 7880      2223       mov R0, #Buf_Soak_Temp
1058 12106B    2224       lcall Init_Temp_Template
105B 7889      2225       mov R0, #Buf_Refl_Temp
105D 12106B    2226       lcall Init_Temp_Template
1060 7884      2227       mov R0, #Buf_Soak_Time
1062 121077    2228       lcall Init_Time_Template
1065 788D      2229       mov R0, #Buf_Refl_Time
1067 121077    2230       lcall Init_Time_Template
106A 22        2231       ret
106B           2232   
106B           2233   Init_Temp_Template:
106B 7630      2234       mov @R0, #'0'
106D 08        2235       inc R0
106E 7630      2236       mov @R0, #'0'
1070 08        2237       inc R0
1071 7630      2238       mov @R0, #'0'
1073 08        2239       inc R0
1074 7600      2240       mov @R0, #0
1076 22        2241       ret
1077           2242   
1077           2243   Init_Time_Template:
1077 7630      2244       mov @R0, #'0'
1079 08        2245       inc R0
107A 7630      2246       mov @R0, #'0'
107C 08        2247       inc R0
107D 7630      2248       mov @R0, #'0'
107F 08        2249       inc R0
1080 7630      2250       mov @R0, #'0'
1082 08        2251       inc R0
1083 7600      2252       mov @R0, #0
1085 22        2253       ret
1086           2254   
1086           2255   Reset_Current_Buffer:
1086 E593      2256       mov A, Current_State
1088 B40106    2257       cjne A, #1, Reset_Chk_2
108B 7880      2258       mov R0, #Buf_Soak_Temp
108D 12106B    2259       lcall Init_Temp_Template
1090 22        2260       ret
1091           2261   Reset_Chk_2:
1091 B40206    2262       cjne A, #2, Reset_Chk_3
1094 7884      2263       mov R0, #Buf_Soak_Time
1096 121077    2264       lcall Init_Time_Template
1099 22        2265       ret
109A           2266   Reset_Chk_3:
109A B40306    2267       cjne A, #3, Reset_Chk_4
109D 7889      2268       mov R0, #Buf_Refl_Temp
109F 12106B    2269       lcall Init_Temp_Template
10A2 22        2270       ret
10A3           2271   Reset_Chk_4:
10A3 788D      2272       mov R0, #Buf_Refl_Time
10A5 121077    2273       lcall Init_Time_Template
10A8 22        2274       ret
10A9           2275   
10A9           2276   ; ----------------------------------------------------------------
10A9           2277   ; MODULE: SCREEN UPDATE (Visual Logic)
10A9           2278   ; ----------------------------------------------------------------
10A9           2279   Update_Screen_Full:
10A9 1211A1    2280       lcall Clear_Screen_Func
10AC C0E0      2281            push acc
10AE 7401      2281            mov a, #1
10B0 14        2281            dec a
10B1 1207A7    2281            lcall ?Set_Cursor_1 ; Select column and row
10B4 D0E0      2281            pop acc
10B6           2282   
10B6           2283       ; --- Draw Line 1 (Titles) ---
10B6 E593      2284       mov A, Current_State
10B8 B40013    2285       cjne A, #0, Update_State_1
10BB C083      2286            push dph
10BD C082      2286            push dpl
10BF C0E0      2286            push acc
10C1 900350    2286            mov dptr, #Txt_Home
10C4 12079A    2286            lcall ?Send_Constant_String
10C7 D0E0      2286            pop acc
10C9 D082      2286            pop dpl
10CB D083      2286            pop dph
10CD 22        2287       ret 
10CE           2288   Update_State_1:
10CE B40114    2289       cjne A, #1, Update_State_2
10D1 C083      2290            push dph
10D3 C082      2290            push dpl
10D5 C0E0      2290            push acc
10D7 900361    2290            mov dptr, #Txt_SoakT
10DA 12079A    2290            lcall ?Send_Constant_String
10DD D0E0      2290            pop acc
10DF D082      2290            pop dpl
10E1 D083      2290            pop dph
10E3 8042      2291       sjmp Draw_Temp_Format
10E5           2292   Update_State_2:
10E5 B40214    2293       cjne A, #2, Update_State_3
10E8 C083      2294            push dph
10EA C082      2294            push dpl
10EC C0E0      2294            push acc
10EE 900372    2294            mov dptr, #Txt_SoakTime
10F1 12079A    2294            lcall ?Send_Constant_String
10F4 D0E0      2294            pop acc
10F6 D082      2294            pop dpl
10F8 D083      2294            pop dph
10FA 8042      2295       sjmp Draw_Time_Format
10FC           2296   Update_State_3:
10FC B40314    2297       cjne A, #3, Update_State_4
10FF C083      2298            push dph
1101 C082      2298            push dpl
1103 C0E0      2298            push acc
1105 900383    2298            mov dptr, #Txt_ReflT
1108 12079A    2298            lcall ?Send_Constant_String
110B D0E0      2298            pop acc
110D D082      2298            pop dpl
110F D083      2298            pop dph
1111 8014      2299       sjmp Draw_Temp_Format
1113           2300   Update_State_4:
1113 C083      2301            push dph
1115 C082      2301            push dpl
1117 C0E0      2301            push acc
1119 900394    2301            mov dptr, #Txt_ReflTime
111C 12079A    2301            lcall ?Send_Constant_String
111F D0E0      2301            pop acc
1121 D082      2301            pop dpl
1123 D083      2301            pop dph
1125 8017      2302       sjmp Draw_Time_Format
1127           2303   
1127           2304   ; --- Draw Line 2 (Values) ---
1127           2305   Draw_Temp_Format:
1127 C0E0      2306            push acc
1129 7401      2306            mov a, #1
112B 14        2306            dec a
112C 1207A5    2306            lcall ?Set_Cursor_2 ; Select column and row
112F D0E0      2306            pop acc
1131 1211B4    2307       lcall Get_Current_Buffer_Addr
1134 121191    2308       lcall Print_String_RAM
1137 7443      2309       mov A, #'C'
1139 12075D    2310       lcall ?WriteData
113C 8027      2311       sjmp Restore_Cursor
113E           2312   
113E           2313   Draw_Time_Format:
113E C0E0      2314            push acc
1140 7401      2314            mov a, #1
1142 14        2314            dec a
1143 1207A5    2314            lcall ?Set_Cursor_2 ; Select column and row
1146 D0E0      2314            pop acc
1148 1211B4    2315       lcall Get_Current_Buffer_Addr
114B           2316       ; MM
114B E6        2317       mov A, @R0
114C 12075D    2318       lcall ?WriteData
114F 08        2319       inc R0
1150 E6        2320       mov A, @R0
1151 12075D    2321       lcall ?WriteData
1154 08        2322       inc R0
1155           2323       ; Colon
1155 743A      2324       mov A, #':'
1157 12075D    2325       lcall ?WriteData
115A           2326       ; SS
115A E6        2327       mov A, @R0
115B 12075D    2328       lcall ?WriteData
115E 08        2329       inc R0
115F E6        2330       mov A, @R0
1160 12075D    2331       lcall ?WriteData
1163           2332       ; Unit
1163           2333       ;got rid of the "s"
1163           2334       ;mov A, #'s'
1163           2335       ;lcall ?WriteData
1163 8000      2336       sjmp Restore_Cursor
1165           2337   
1165           2338   ; --- Restore Cursor Position ---
1165           2339   Restore_Cursor:
1165 E593      2340       mov A, Current_State
1167 B40202    2341       cjne A, #2, RC_Check_State_4  
116A 800D      2342       sjmp Adjust_Cursor_Time
116C           2343   RC_Check_State_4:             
116C B40402    2344       cjne A, #4, Normal_Cursor
116F 8008      2345       sjmp Adjust_Cursor_Time
1171           2346   
1171           2347   Normal_Cursor:
1171 E59C      2348       mov A, Cursor_Idx
1173 24C0      2349       add A, #0xC0
1175 120762    2350       lcall ?WriteCommand
1178 22        2351       ret
1179           2352   
1179           2353   Adjust_Cursor_Time:
1179           2354       ; Skip the colon index (2)
1179 E59C      2355       mov A, Cursor_Idx
117B B40201    2356       cjne A, #2, No_Skip
117E 04        2357       inc A 
117F           2358   No_Skip:
117F           2359       ; Add 1 if past the colon
117F C3        2360       clr C
1180 9402      2361       subb A, #2
1182 4005      2362       jc No_Add
1184 E59C      2363       mov A, Cursor_Idx
1186 04        2364       inc A
1187 8002      2365       sjmp Final_Cursor_Set
1189           2366   No_Add:
1189 E59C      2367       mov A, Cursor_Idx
118B           2368   Final_Cursor_Set:
118B 24C0      2369       add A, #0xC0
118D 120762    2370       lcall ?WriteCommand
1190 22        2371       ret
1191           2372   
1191           2373   Print_String_RAM:
1191 E6        2374       mov A, @R0
1192 6006      2375       jz Print_String_Done
1194 12075D    2376       lcall ?WriteData
1197 08        2377       inc R0
1198 80F7      2378       sjmp Print_String_RAM
119A           2379   Print_String_Done:
119A 22        2380       ret
119B           2381   
119B           2382   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
119B           2383   Wait_25ms_BLOCKING:
119B 121043    2384       lcall Wait_25ms
119E 50FB      2385       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
11A0 22        2386       ret
11A1           2387   
11A1           2388   Clear_Screen_Func:
11A1 7401      2389       mov A, #0x01
11A3 120762    2390       lcall ?WriteCommand
11A6           2391       
11A6           2392       ; --- FIX: HARDWARE DELAY LOOP (MAX STRENGTH) ---
11A6           2393       ; The LCD needs ~2ms to clear. 
11A6           2394       ; We use R0=255 to guarantee ~5ms+ delay.
11A6           2395       ; This ensures the LCD is 100% ready before we send "Ramp to Soak".
11A6 78FF      2396       mov R0, #255
11A8           2397   Clear_Delay_Loop_Outer:
11A8 79FF      2398       mov R1, #255
11AA           2399   Clear_Delay_Loop_Inner:
11AA D9FE      2400       djnz R1, Clear_Delay_Loop_Inner
11AC D8FA      2401       djnz R0, Clear_Delay_Loop_Outer
11AE           2402       ; -----------------------------------------------
11AE           2403   
11AE 740C      2404       mov A, #0x0C  ; Display ON, Cursor OFF
11B0 120762    2405       lcall ?WriteCommand
11B3 22        2406       ret
11B4           2407   
11B4           2408   Get_Current_Buffer_Addr:
11B4 E593      2409       mov A, Current_State
11B6 B40103    2410       cjne A, #1, Get_Buf_2
11B9 7880      2411       mov R0, #Buf_Soak_Temp
11BB 22        2412       ret
11BC           2413   Get_Buf_2:
11BC B40203    2414       cjne A, #2, Get_Buf_3
11BF 7884      2415       mov R0, #Buf_Soak_Time
11C1 22        2416       ret
11C2           2417   Get_Buf_3:
11C2 B40303    2418       cjne A, #3, Get_Buf_4
11C5 7889      2419       mov R0, #Buf_Refl_Temp
11C7 22        2420       ret
11C8           2421   Get_Buf_4:
11C8 788D      2422       mov R0, #Buf_Refl_Time
11CA 22        2423       ret
11CB           2424       
11CB           2425   ; --- Helper to prevent "Machine Gun" button presses ---
11CB           2426   Wait_For_P1_0_Release:
11CB 3090FD    2427       jnb P1.0, $    ; Wait here while the button is still pressed (0)
11CE 22        2428       ret
11CF           2429   
11CF           2430   ; --- Full reset helper for P3.7 (active-low) ---
11CF           2431   Wait_For_P3_7_Release:
11CF 30B7FD    2432       jnb P3_7, $    ; Wait here while the button is still pressed (0)
11D2 22        2433       ret
11D3           2434   
11D3           2435   Full_Reset:
11D3 1211CF    2436       lcall Wait_For_P3_7_Release
11D6 020D43    2437       ljmp main
11D9           2438   
11D9           2439   ; ================================================================
11D9           2440   ; MODULE: THERMOCOUPLE ADC DRIVER (WITH NOISE SUPPRESSION & JUMP FIX)
11D9           2441   ; ================================================================
11D9           2442   Read_Thermocouple:
11D9           2443       ; 1. Check Non-Blocking Timer
11D9 121043    2444       lcall Wait_25ms
11DC           2445       
11DC           2446       ; [FIX] TRAMPOLINE JUMP
11DC           2447       ; "jnc" cannot jump to the end because the code is too long.
11DC           2448       ; We invert logic: If Carry=1 (Time is up), Jump NEARBY.
11DC 4001      2449       jc Proceed_Reading
11DE 22        2450       ret  ; If Carry=0, Return immediately.
11DF           2451   
11DF           2452   Proceed_Reading:
11DF           2453       ; --- 25ms Passed! Time to Read ---
11DF           2454   
11DF           2455       ; [FIX] SILENCE THE BUZZER (Noise Suppression)
11DF           2456       ; Save buzzer state and force it OFF during the sensitive read
11DF E588      2457       mov A, TCON      
11E1 5410      2458       anl A, #0x10     ; Isolate TR0 bit
11E3 C0E0      2459       push acc         ; Save it
11E5 C28C      2460       clr TR0          ; STOP NOISE
11E7           2461   
11E7           2462       ; 2. Initialize / Trigger ADC
11E7 75A180    2463       mov ADC_C, #0x80    ; Reset
11EA 00        2464       nop
11EB 00        2465       nop
11EC 75A101    2466       mov ADC_C, #0x01    ; Start Channel 0
11EF           2467       
11EF           2468       ; 3. Settle Delay
11EF 7DFA      2469       mov R5, #250
11F1           2470   ADC_Settle_Loop:
11F1 00        2471       nop
11F2 00        2472       nop
11F3 DDFC      2473       djnz R5, ADC_Settle_Loop
11F5           2474       
11F5           2475       ; 4. Read Raw Data
11F5 85A232    2476       mov x+0, ADC_L
11F8 85A333    2477       mov x+1, ADC_H
11FB 753400    2478       mov x+2, #0
11FE 753500    2479       mov x+3, #0
1201           2480       
1201           2481       ; 5. Mask Data
1201 E533      2482       mov a, x+1
1203 540F      2483       anl a, #0x0F
1205 F533      2484       mov x+1, a
1207           2485       
1207           2486       ; [FIX] RESTORE THE BUZZER
1207 D0E0      2487       pop acc          ; Get previous state
1209 6002      2488       jz Skip_Restore  ; If it was OFF, keep it OFF
120B D28C      2489       setb TR0         ; If it was ON, turn it back ON
120D           2490   Skip_Restore:
120D           2491   
120D           2492       ; 6. Math Conversions
120D 753616    2493            mov y+0, #low (4118 % 0x10000) 
1210 753710    2493            mov y+1, #high(4118 % 0x10000) 
1213 753800    2493            mov y+2, #low (4118 / 0x10000) 
1216 753900    2493            mov y+3, #high(4118 / 0x10000) 
1219 12018C    2494       lcall mul32       
121C           2495   
121C 75A104    2496       mov ADC_C, #0x04    ; Read LM4040
121F 85A236    2497       mov y+0, ADC_L      
1222 85A337    2498       mov y+1, ADC_H      
1225 753800    2499       mov y+2, #0
1228 753900    2500       mov y+3, #0
122B 75A100    2501       mov ADC_C, #0x00    ; Reset
122E           2502       
122E 120280    2503       lcall div32         
1231 753664    2504            mov y+0, #low (100 % 0x10000) 
1234 753700    2504            mov y+1, #high(100 % 0x10000) 
1237 753800    2504            mov y+2, #low (100 / 0x10000) 
123A 753900    2504            mov y+3, #high(100 / 0x10000) 
123D 12018C    2505       lcall mul32
1240 75362B    2506            mov y+0, #low (1323 % 0x10000) 
1243 753705    2506            mov y+1, #high(1323 % 0x10000) 
1246 753800    2506            mov y+2, #low (1323 / 0x10000) 
1249 753900    2506            mov y+3, #high(1323 / 0x10000)         
124C 120280    2507       lcall div32    
124F 753614    2508            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
1252 753700    2508            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
1255 753800    2508            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
1258 753900    2508            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
125B 1200D3    2509       lcall add32     
125E           2510       
125E           2511       ; 8. Store Result
125E 853269    2512       mov current_temp+0, x+0
1261 85336A    2513       mov current_temp+1, x+1
1264 85346B    2514       mov current_temp+2, x+2
1267 85356C    2515       mov current_temp+3, x+3
126A           2516   
126A 22        2517       ret
126B           2518       
126B           2519   ; ================================================================
126B           2520   ; MODULE: POWER CONTROLLER (The Brain)
126B           2521   ; ================================================================
126B           2522   Power_Control:
126B           2523       ; Default: Turn Heat OFF (Safety)
126B 758600    2524       mov power_output+0, #0
126E 758700    2525       mov power_output+1, #0
1271 758800    2526       mov power_output+2, #0
1274 758900    2527       mov power_output+3, #0
1277           2528   
1277 E592      2529       mov a, Control_FSM_state
1279           2530   
1279           2531       ; --- State 2: RAMP TO SOAK ---
1279 B40202    2532       cjne a, #2, PC_Check_Soak
127C           2533       ; Mode: Full Speed Ahead
127C 8016      2534       sjmp Set_Max_Power
127E           2535   
127E           2536   PC_Check_Soak:
127E           2537       ; --- State 3: SOAK PHASE ---
127E B40305    2538       cjne a, #3, PC_Check_Ramp_Reflow
1281           2539       ; Mode: Maintenance (Low Power)
1281           2540       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
1281 20040F    2541       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
1284 801B      2542       sjmp Set_20_Percent_Power     ; If cold, use 20%
1286           2543   
1286           2544   PC_Check_Ramp_Reflow:
1286           2545       ; --- State 4: RAMP TO REFLOW ---
1286 B40402    2546       cjne a, #4, PC_Check_Reflow
1289           2547       ; Mode: Full Speed Ahead
1289 8009      2548       sjmp Set_Max_Power
128B           2549   
128B           2550   PC_Check_Reflow:
128B           2551       ; --- State 5: REFLOW PHASE ---
128B B40505    2552       cjne a, #5, PC_Done
128E           2553       ; Mode: Maintenance (Low Power)
128E 200502    2554       jb reflow_temp_reached, PC_Done
1291 800E      2555       sjmp Set_20_Percent_Power
1293           2556   
1293           2557   PC_Done:
1293 22        2558       ret
1294           2559   
1294           2560   ; --- Power Helpers ---
1294           2561   
1294           2562   Set_Max_Power:
1294           2563       ; Load 1500 (0x05DC) = 100% Duty Cycle
1294 7586DC    2564       mov power_output+0, #0xDC
1297 758705    2565       mov power_output+1, #0x05
129A 758800    2566       mov power_output+2, #0
129D 758900    2567       mov power_output+3, #0
12A0 22        2568       ret
12A1           2569   
12A1           2570   Set_20_Percent_Power:
12A1           2571       ; Load 300 (0x012C) = 20% Duty Cycle
12A1 75862C    2572       mov power_output+0, #0x2C
12A4 758701    2573       mov power_output+1, #0x01
12A7 758800    2574       mov power_output+2, #0
12AA 758900    2575       mov power_output+3, #0
12AD 22        2576       ret
12AE           2577   
12AE           2578   
12AE           2579   ;--------------------------------------------------------------
12AE           2580   ; set servo angle according to the state
12AE           2581   ; call servo control function every 1ms
12AE           2582   ;--------------------------------------------------------------
12AE           2583   call_servo_control:
12AE           2584            ; check current state and change servo angle
12AE E592      2585            mov a, Control_FSM_state
12B0           2586            
12B0           2587            ; handle state 0
12B0 B40004    2588            cjne a, #0, servo_state1
12B3 C220      2589            clr servo_angle_zero ; close door at state 0
12B5 802C      2590            sjmp check_servo_flag
12B7           2591   
12B7           2592            ; handle state 1
12B7           2593            servo_state1:
12B7 B40104    2594            cjne a, #1, servo_state2
12BA D220      2595            setb servo_angle_zero ; open door at state 1
12BC 8025      2596            sjmp check_servo_flag
12BE           2597   
12BE           2598            ; handle state 2
12BE           2599            servo_state2:
12BE B40204    2600            cjne a, #2, servo_state3
12C1 C220      2601            clr servo_angle_zero ; close door at state 2
12C3 801E      2602            sjmp check_servo_flag
12C5           2603   
12C5           2604            ; handle state 3
12C5           2605            servo_state3:
12C5 B40304    2606            cjne a, #3, servo_state4
12C8 C220      2607            clr servo_angle_zero ; close door at state 3
12CA 8017      2608            sjmp check_servo_flag
12CC           2609   
12CC           2610            ; handle state 4
12CC           2611            servo_state4:
12CC B40404    2612            cjne a, #4, servo_state5
12CF C220      2613            clr servo_angle_zero ; close door at state 4
12D1 8010      2614            sjmp check_servo_flag
12D3           2615   
12D3           2616            ; handle state 5
12D3           2617            servo_state5:
12D3 B40504    2618            cjne a, #5, servo_state6
12D6 C220      2619            clr servo_angle_zero ; close door at state 5
12D8 8009      2620            sjmp check_servo_flag
12DA           2621   
12DA           2622            ; handle state 6
12DA           2623            servo_state6:
12DA B40604    2624            cjne a, #6, servo_state7
12DD C220      2625            clr servo_angle_zero ; close door at state 6
12DF 8002      2626            sjmp check_servo_flag
12E1           2627   
12E1           2628            ; handle state 7
12E1           2629            servo_state7:
12E1 D220      2630            setb servo_angle_zero ; open door at state 7
12E3           2631   
12E3           2632   check_servo_flag:
12E3           2633            ; check 1 ms flag
12E3 101F01    2634            jbc one_millisecond_flag_servo, run_servo_control
12E6 22        2635            ret
12E7           2636   
12E7           2637   run_servo_control:
12E7 1212EB    2638            lcall servo_control
12EA 22        2639            ret
12EB           2640   
12EB           2641   
12EB           2642   ;---------------------------------------------------------------
12EB           2643   ; servo control
12EB           2644   ; generate a 20 ms period pwm signal to control the servo motor
12EB           2645   ; able to make the servo motor stay at 0 degree and 180 degree
12EB           2646   ;---------------------------------------------------------------
12EB           2647   servo_control:
12EB D2ED      2648       setb LEDRA.5
12ED C0E0      2649            push acc
12EF C0D0      2650            push psw
12F1 E5A1      2651            mov a, servo_pwm_counter ; move servo counter to accumulator
12F3 04        2652            inc A ; a += 1
12F4 B41402    2653            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
12F7 7400      2654            mov a, #0
12F9           2655   
12F9           2656   servo_pwm_angle_compare: ; read target angle
12F9 F5A1      2657            mov servo_pwm_counter, A
12FB 202009    2658            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
12FE           2659            ; set servo motor to 180 degrees
12FE E5A1      2660            mov a, servo_pwm_counter
1300 C3        2661            clr c
1301 9402      2662            subb a, #SERVO_180
1303 400B      2663            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
1305 800D      2664            sjmp servo_pwm_set_low ; set low if greater
1307           2665   
1307           2666   set_zero_degree:
1307           2667            ; set servo motor to 0 degree
1307 E5A1      2668            mov a, servo_pwm_counter
1309 C3        2669            clr c
130A 9401      2670            subb a, #SERVO_0
130C 4002      2671            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
130E 8004      2672            sjmp servo_pwm_set_low ; set low if greater
1310           2673   
1310           2674   servo_pwm_set_high:
1310           2675            ; set pwm pin high
1310 D2B6      2676            setb SERVO_OUT
1312 8002      2677            sjmp servo_control_done
1314           2678   
1314           2679   servo_pwm_set_low:
1314           2680            ; set pwm pin low
1314 C2B6      2681            clr SERVO_OUT
1316           2682   
1316           2683   servo_control_done:
1316 D0D0      2684            pop psw
1318 D0E0      2685            pop acc
131A 22        2686            ret
131B           2687   
131B           2688   ;-------------------------------------------------------------------------------
131B           2689   ; power_control
131B           2690   ;-------------------------------------------------------------------------------
131B           2691   ; Determine the power output based on current state and current temperature 
131B           2692   ; input parameter: Control_FSM_state
131B           2693   ;-------------------------------------------------------------------------------
131B           2694   
131B           2695   proportional_power_control:
131B E592      2696            mov a, Control_FSM_state
131D           2697   
131D           2698   state0_power_control:
131D           2699            ; idle
131D           2700            ; 0% power
131D B4000F    2701            cjne a, #0, state1_power_control
1320 758600    2702            mov power_output, #low(NO_POWER)
1323 758700    2703            mov power_output+1, #low(NO_POWER)
1326 758800    2704            mov power_output+2, #0
1329 758900    2705            mov power_output+3, #0
132C 0214C7    2706            ljmp power_control_done
132F           2707   
132F           2708   state1_power_control:
132F           2709            ; idle
132F           2710            ; 0% power
132F B4010F    2711            cjne a, #1, state2_power_control
1332 758600    2712            mov power_output, #low(NO_POWER)
1335 758700    2713            mov power_output+1, #low(NO_POWER)
1338 758800    2714            mov power_output+2, #0
133B 758900    2715            mov power_output+3, #0
133E 0214C7    2716            ljmp power_control_done
1341           2717            
1341           2718   state2_power_control:
1341           2719            ; ramp to soak, ramp to ~150C
1341           2720            ; 100% power
1341 B4020F    2721            cjne a, #2, state3_power_control
1344 7586DC    2722            mov power_output, #low(MAX_POWER)
1347 758705    2723            mov power_output+1, #high(MAX_POWER)
134A 758800    2724            mov power_output+2, #0
134D 758900    2725            mov power_output+3, #0
1350 0214C7    2726            ljmp power_control_done
1353           2727   
1353           2728   state3_power_control:
1353           2729            ; soak period, hold at 150C
1353           2730            ; 20% base power + proportional calculated power
1353 B40302    2731            cjne a, #3, jump_state4_power_control
1356 8003      2732            sjmp state3_power_control_calculation
1358           2733   
1358           2734   jump_state4_power_control:
1358 021485    2735            ljmp state4_power_control
135B           2736   
135B           2737   state3_power_control_calculation:
135B           2738            ; move soak_temp to x
135B 856D32    2739            mov x, soak_temp
135E 856E33    2740            mov x+1, soak_temp+1
1361 856F34    2741            mov x+2, soak_temp+2
1364 857035    2742            mov x+3, soak_temp+3
1367           2743            ; move current_temp to y
1367 856936    2744            mov y, current_temp
136A 856A37    2745            mov y+1, current_temp+1
136D 856B38    2746            mov y+2, current_temp+2
1370 856C39    2747            mov y+3, current_temp+3
1373           2748   
1373           2749            ; compare between soak_temp and current_temp
1373 C201      2750            clr mf
1375 120178    2751            lcall x_gteq_y
1378 10012B    2752            jbc mf, st_sub_ct
137B           2753            ; current_temp - soak_temp if st < ct
137B C221      2754            clr soak_temp_greater
137D           2755            ; move current_temp to y
137D 856D36    2756            mov y, soak_temp
1380 856E37    2757            mov y+1, soak_temp+1
1383 856F38    2758            mov y+2, soak_temp+2
1386 857039    2759            mov y+3, soak_temp+3
1389           2760            ; move current_temp to x
1389 856932    2761            mov x, current_temp
138C 856A33    2762            mov x+1, current_temp+1
138F 856B34    2763            mov x+2, current_temp+2
1392 856C35    2764            mov x+3, current_temp+3
1395 1200F6    2765            lcall sub32
1398 853294    2766            mov soak_temp_diff, x
139B 853395    2767            mov soak_temp_diff+1, x+1
139E 853496    2768            mov soak_temp_diff+2, x+2
13A1 853597    2769            mov soak_temp_diff+3, x+3
13A4 8011      2770            sjmp proportional_input_soak
13A6           2771   
13A6           2772   st_sub_ct:
13A6           2773            ; soak_temp - current_temp
13A6 D221      2774            setb soak_temp_greater
13A8 1200F6    2775            lcall sub32
13AB 853294    2776            mov soak_temp_diff, x
13AE 853395    2777            mov soak_temp_diff+1, x+1
13B1 853496    2778            mov soak_temp_diff+2, x+2
13B4 853597    2779            mov soak_temp_diff+3, x+3
13B7           2780   
13B7           2781   proportional_input_soak:
13B7           2782            ; proportaional block calculation       
13B7           2783            ; move soak_temp_diff to x
13B7 859432    2784            mov x, soak_temp_diff
13BA 859533    2785            mov x+1, soak_temp_diff+1
13BD 859634    2786            mov x+2, soak_temp_diff+2
13C0 859735    2787            mov x+3, soak_temp_diff+3
13C3           2788            ; move proportional gain to y
13C3 753605    2789            mov y+0, #low (KP % 0x10000) 
13C6 753700    2789            mov y+1, #high(KP % 0x10000) 
13C9 753800    2789            mov y+2, #low (KP / 0x10000) 
13CC 753900    2789            mov y+3, #high(KP / 0x10000) 
13CF 12018C    2790            lcall mul32 ; proportional_output = proportional_gain * difference
13D2           2791            
13D2 853298    2792            mov proportional_gain_var, x
13D5 853399    2793            mov proportional_gain_var+1, x+1
13D8 85349A    2794            mov proportional_gain_var+2, x+2
13DB 85359B    2795            mov proportional_gain_var+3, x+3
13DE           2796   
13DE           2797            ; base_power + soak_power when soak_temp > current_temp
13DE 302129    2798            jnb soak_temp_greater, sub_proportional_soak
13E1 859832    2799            mov x, proportional_gain_var
13E4 859933    2800            mov x+1, proportional_gain_var+1
13E7 859A34    2801            mov x+2, proportional_gain_var+2
13EA 859B35    2802            mov x+3, proportional_gain_var+3
13ED 75362C    2803            mov y+0, #low (BASE_POWER % 0x10000) 
13F0 753701    2803            mov y+1, #high(BASE_POWER % 0x10000) 
13F3 753800    2803            mov y+2, #low (BASE_POWER / 0x10000) 
13F6 753900    2803            mov y+3, #high(BASE_POWER / 0x10000) 
13F9 1200D3    2804            lcall add32
13FC           2805            ; x now holds the power output before the saturator
13FC 853298    2806            mov proportional_gain_var, x
13FF 853399    2807            mov proportional_gain_var+1, x+1
1402 85349A    2808            mov proportional_gain_var+2, x+2
1405 85359B    2809            mov proportional_gain_var+3, x+3
1408 803D      2810            sjmp saturator_soak
140A           2811   
140A           2812   sub_proportional_soak:
140A           2813            ; base_power - soak_power when soak_temp <= current_temp
140A 75322C    2814            mov x+0, #low (BASE_POWER % 0x10000) 
140D 753301    2814            mov x+1, #high(BASE_POWER % 0x10000) 
1410 753400    2814            mov x+2, #low (BASE_POWER / 0x10000) 
1413 753500    2814            mov x+3, #high(BASE_POWER / 0x10000) 
1416 859836    2815            mov y, proportional_gain_var
1419 859937    2816            mov y+1, proportional_gain_var+1
141C 859A38    2817            mov y+2, proportional_gain_var+2
141F 859B39    2818            mov y+3, proportional_gain_var+3
1422           2819   
1422           2820            ; compare whether base_power < proportional_gain_var
1422 C201      2821            clr mf
1424 12011A    2822            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
1427 30010E    2823            jnb mf, bp_gteq_pgv
142A 759800    2824            mov proportional_gain_var, #low(NO_POWER)
142D 759900    2825            mov proportional_gain_var+1, #high(NO_POWER)
1430 759A00    2826            mov proportional_gain_var+2, #0
1433 759B00    2827            mov proportional_gain_var+3, #0
1436 800F      2828            sjmp saturator_soak
1438           2829   
1438           2830   bp_gteq_pgv:
1438           2831            ; calculate subtracted gain
1438 1200F6    2832            lcall sub32
143B           2833            ; x now holds the power output before the saturator
143B 853298    2834            mov proportional_gain_var, x
143E 853399    2835            mov proportional_gain_var+1, x+1
1441 85349A    2836            mov proportional_gain_var+2, x+2
1444 85359B    2837            mov proportional_gain_var+3, x+3
1447           2838   
1447           2839   saturator_soak:
1447           2840            ; proportional_gain_var now holds the power output before the saturator
1447           2841            ; saturate power output to max power
1447 859832    2842            mov x, proportional_gain_var
144A 859933    2843            mov x+1, proportional_gain_var+1
144D 859A34    2844            mov x+2, proportional_gain_var+2
1450 859B35    2845            mov x+3, proportional_gain_var+3
1453           2846   
1453 7536DC    2847            mov y+0, #low (MAX_POWER % 0x10000) 
1456 753705    2847            mov y+1, #high(MAX_POWER % 0x10000) 
1459 753800    2847            mov y+2, #low (MAX_POWER / 0x10000) 
145C 753900    2847            mov y+3, #high(MAX_POWER / 0x10000) 
145F           2848   
145F C201      2849            clr mf
1461 120136    2850            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
1464 20010F    2851            jb mf, saturated_soak
1467           2852            ; set power_output to calculated power if not saturated
1467 859886    2853            mov power_output, proportional_gain_var
146A 859987    2854            mov power_output+1, proportional_gain_var+1
146D 859A88    2855            mov power_output+2, proportional_gain_var+2
1470 859B89    2856            mov power_output+3, proportional_gain_var+3
1473 0214C7    2857            ljmp power_control_done
1476           2858   
1476           2859   saturated_soak:
1476 7586DC    2860            mov power_output, #low(MAX_POWER)
1479 758705    2861            mov power_output+1, #high(MAX_POWER)
147C 758800    2862            mov power_output+2, #0
147F 758900    2863            mov power_output+3, #0
1482 0214C7    2864            ljmp power_control_done
1485           2865   
1485           2866   
1485           2867   state4_power_control:
1485           2868            ; ramp to reflow, max power
1485 B4040F    2869            cjne a, #4, state5_power_control
1488 7586DC    2870            mov power_output, #low(MAX_POWER)
148B 758705    2871            mov power_output+1, #high(MAX_POWER)
148E 758800    2872            mov power_output+2, #0
1491 758900    2873            mov power_output+3, #0
1494 0214C7    2874            ljmp power_control_done
1497           2875   
1497           2876   state5_power_control:
1497           2877            ; reflow 20% base power
1497 B4050F    2878            cjne a, #5, state6_power_control
149A 75862C    2879            mov power_output, #low(BASE_POWER)  
149D 758701    2880            mov power_output+1, #high(BASE_POWER)
14A0 758800    2881            mov power_output+2, #0
14A3 758900    2882            mov power_output+3, #0
14A6 0214C7    2883            ljmp power_control_done
14A9           2884   
14A9           2885   state6_power_control:
14A9           2886            ; cooling 0% power
14A9 B4060F    2887            cjne a, #6, state_7_power_control
14AC 758600    2888            mov power_output, #low(NO_POWER)
14AF 758700    2889            mov power_output+1, #high(NO_POWER)
14B2 758800    2890            mov power_output+2, #0
14B5 758900    2891            mov power_output+3, #0
14B8 0214C7    2892            ljmp power_control_done
14BB           2893   
14BB           2894   state_7_power_control:
14BB           2895            ; idle 0% power
14BB 758600    2896            mov power_output, #low(NO_POWER)
14BE 758700    2897            mov power_output+1, #high(NO_POWER)
14C1 758800    2898            mov power_output+2, #0
14C4 758900    2899            mov power_output+3, #0
14C7           2900   
14C7           2901   power_control_done:
14C7 22        2902            ret
14C8           2903   
14C8           2904   END
